---
title: "Day10"
date: 2021-04-09T23:09:08+08:00
lastmod: 2021-04-09
author: "xiaonan"
math:
 enable: true

tags: [java]
categories: [王道]
---

### 子类对象初始化成员变量赋值的顺序是什么样的?

1. 默认初始化, 默认值

2. 去找创建子类对象会调用的构造方法，看第一行有没有 **this()**, **super()**, 如果有就去执行，如果没有，默认有 **super()** 仍然去执行

3. 肯定要跳到 **父类构造器** ，然后从 **上到下** 执行父类中的 **显示赋值** 和 **构造代码块** ，最后执行父类的构造器

4. 如果子类构造器中有 **this**, 回到子类 **this** 构造器. 如果没有 **this**, 直接就回去，从上到下执行子类中的显示赋值和构造代码块，然后执行 **this** 构造器，然后跳到最开始的构造器

5. 直接执行该构造器，而不会显式赋值和构造代码块

### 如何定义接口?

**语法**:

与 **class** 定义一样，接口是和 **class** 同等级别的数据类型

[访问权限修饰符] interface 接口名{}

### 接口的命名规范是什么?

采取 **大驼峰式** 的

有些程序员，喜欢在接口名的第一个单词之前加一个"I" 用来区分这是一个接口

```java
interface ISpecialSkills{

	public void walkUpright(){
	}
}
```

### 如何在接口中定义方法?

![20210409135933](https://img.fengqigang.cn//img/20210409135933.png)

接口中的抽象方法没有方法体

### 可以在接口中定义中加public abstract 定义方法体吗?

![20210409140240](https://img.fengqigang.cn//img/20210409140240.png)

不可以，默认已经加上了

在接口中的抽象方法，默认都是 **public abstract** 修饰的，这两个关键字无需再加，默认就有

### 接口中有继承的概念吗?

类与接口之间不用继承的概念，用 **实现** 的概念  (implements)

### 接口可以多实现吗?

继承有单继承限制，但是接口不受该限制，接口可以多实现

![20210409140941](https://img.fengqigang.cn//img/20210409140941.png)

### **is-a** 与 **like-a** 有什么区别?

**is-a** 关系的是 **两个类之间的关系** ，如果两个类没有任何实际联系，用继承是不合适的

**like-a** 关系的 **实现强调功能的扩展**， 它不必考虑两个类(接口)之间的实际关系

### 空接口，有什么作用?

一个类实现了一个接口，不管这个接口有没有东西，它都变成了 **这个接口的子类 **

### 类与接口有区别吗?


**类**

定义的是一个 **数据集合**，基于这个数据集的一组 **操作(行为)**

类所描述的这一组行为，它们是有关系的(间接) ， 都可以访问同一个数据集合

**接口**

表示数据类型，侧重于描述一组具有 **特殊功能的行为**

这些行为可以完全 **没有任何关系**, 接口中的方法，它们的关系比较的松散

### 接口可以实例化吗?

不可以

![20210409142030](https://img.fengqigang.cn//img/20210409142030.png)

### 接口和继承同时存在时，应该如何定义?

将接口放在继承类后面

![20210409141935](https://img.fengqigang.cn//img/20210409141935.png)

### 为什么接口不可以实现化? 

在接口的声明中， 默认有 **abstract**, 接口也是一个抽象的概念，它不能创建实例

这个关键字是可以省略的

### 接口的访问权限是什么?

普遍来说它的访问权限都是 **public** 的，是鼓励去实现接口的，但是 **public** 不是默认的，它的访问权限是可以修改的

### 接口的成员特征是什么样的?

接口中没有 **普通成员变量** 和 **静态成员变量**, 接口的成员变量默认 **public static final** 修饰的全局常量

**普通成员变量**

![20210409191414](https://img.fengqigang.cn//img/20210409191414.png)

**静态成员变量**

![20210409191459](https://img.fengqigang.cn//img/20210409191459.png)

**public static final**

![20210409191617](https://img.fengqigang.cn//img/20210409191617.png)

### 接口中声明全局常量的正确格式是什么样的?

接口的成员变量默认 **public static final**

![20210409191706](https://img.fengqigang.cn//img/20210409191706.png)

### 接口中可以放静态代码块吗?

不可以

虽然接口中的成员变量都是全局常量，但是接口中 **不允许静态代码块** ，所以接口中全局常量 **必须显式赋值**

![20210409191926](https://img.fengqigang.cn//img/20210409191926.png)

### 接口中有普通方法实现吗?

没有，接口中没有普通的方法实现，都是抽象方法， 并且默认是 **public abstract** 修饰的

![20210409192336](https://img.fengqigang.cn//img/20210409192336.png)


### 写接口实现类的格式, 其包名最好怎么取?

需要实现接口的包下, 新建一个包 **impl**

实现类, 类的命名为 **接口名 + Impl**

![20210409194221](https://img.fengqigang.cn//img/20210409194221.png)

### 接口中有没有构造方法?

接口中没有构造方法，没有需求，既不能创建对象，以没有成员给子类赋值

![20210409194520](https://img.fengqigang.cn//img/20210409194520.png)

### 接口的子类的特点是什么?

1. 接口的子类如果是一个 **普通类** ，必须 **实现全部抽象方法**

2. 接口的子类如果是一个 **抽象类**,  可以 **选择实现一部分**，也可以 **全部都不实现**

### 接口的子类可以是一个接口吗?

可以

### 什么样的关系是继承? 什么样的关系是实现?

类与类之间叫 **继承**

接口与接口之间叫 **继承**

类与接口之间叫 **实现**

**继承** 是不能跨越种族的，同种数据类型之间相互继承，**类是单继承的**，**接口是多继承的**

### 接口与接口成员默认是 **public** 还是 **private** 修饰的?

默认都是 **public** 修饰的, 鼓励继承，鼓励重写

### 接口与类之间是什么样的关系?

并列的数据类型

### 如何定义一个接口I, I中有test()方法， 类A继承I, 重写输出A, 

```java
public class Demo {
    public static void main(String[] args) {
    }
}

interface I {
    void test();
}

class A implements I {
    @Override
    public void test() {
        System.out.println("A");
    }
}
```

### ![20210409200449](https://img.fengqigang.cn//img/20210409200449.png) 如何定义方法，返回实现I接口的A对象, 还有通过I接口输出hello?

将方法定义在main函数体中， 用**static**修饰

```java
public class Demo {
    public static void main(String[] args) {
        I i;
        i = method();
        method(i);
        i.test();
    }

    public static I method() {
        return new A();
    }

    public static void method(I i) {
        System.out.println("hello");
    }
}

interface I {
    void test();
}

class A implements I {
    @Override
    public void test() {
        System.out.println("A");
    }
}
```

### ![20210409200855](https://img.fengqigang.cn//img/20210409200855.png) 如何从抽象类，接口，具体类的方面来实现?

**抽象类**:

教练， 运动员

**接口**

跳远

学英语

**具体类**

乒乓球, 篮球运行员以及教练



**抽象类**

```java
// 抽象的教练类
abstract class AbstractCoach {
    int age;
    String name;

    public abstract void teach();
}

//抽象的运动员类
abstract class AbstractSportsman {
    int age;
    double price;

    public abstract void train();
}
```


**接口**

```java
interface Learning {
    void learnEnglish();
}
```

**具体类**

```java
//具体类
class TableTennisCoach extends AbstractCoach implements Learning {
    @Override
    public void teach() {
        System.out.println("我教你打乒乓球");
    }

    @Override
    public void learnEnglish() {
        System.out.println("我要出国学英语");
    }
}

class BasketballSportsman extends AbstractSportsman {
    @Override
    public void train() {
        System.out.println("我会打篮球");
    }
}
```

### ![20210409203125](https://img.fengqigang.cn//img/20210409203125.png) 与![20210409203156](https://img.fengqigang.cn//img/20210409203156.png)会输出什么?

![20210409203222](https://img.fengqigang.cn//img/20210409203222.png)

### 什么是内部类?

嵌套定义在 **一个类的内部** 的类

### 内部类有什么用?

1. 封装

![20210409203437](https://img.fengqigang.cn//img/20210409203437.png)

私有化 **CPU** 这个类后，就不能在 **Computer** 外部访问这个类了

2. 内部类互相访问

两个独立的类之间受访问权限限制，而当一个类进入另一个类内部成为内部类就不再受访问权限限制了，可以互相访问私有成员

### 内部类如何分类? (成员位置， 局部位置)

**定义在成员位置**

1. 成员内部类

2. 普通成员内部类

3. 静态内部类

**定义在局部内部类**

1. 匿名局部内部类

2. lambda

### 什么是成员内部类?其定义是什么?

**成员内部类**

最普通的内部类， 它定义在另一个类的成员位置，可以看成该类的一个成员

**语法**

[访问权限修饰符] class EnclosedClazz{
	[访问权限修饰符] class InnerClazz{
	}
}

### 普通的类有几种访问权限修饰符?

两种，没有 **protected** , **private**

class 是用来被实例化的，所以只有 **默认** 和 **public** 访问权限修饰符

### 成员内部类的访问权限修饰符有哪些?

成员内部类相当于外围类的成员了，有4种访问权限

**public** , **protected** , 默认， **private**

其中 **private** 最为常见

### 什么是类加载? 类加载时机有哪些?

**类加载**:

是一种懒加载，用到的时候才加载，不得不加载才加载

**时机**

1. new 对象

2. 执行 main 方法

3. 访问类的静态成员

4. 子类类加载触发父类类加载, 并且在子类之前

### 成员内部类的类加载情况有哪些?

创建内部类对象

成员内部类想创建对象，**必须依赖于外围类**，在外围类对象的基础上，才能创建成员内部类对象

### 成员内部类中可以有普通成员变量，静态成员变量，全局变量吗?

1. 可以有普通成员变量

2. 不能有静态成员变量

3. 可以有全局常量, 但是那些会触发类加载的全局常量不能有

**普通成员变量与静态成员变量**

![20210409205101](https://img.fengqigang.cn//img/20210409205101.png)

**全局常量**

![20210409205253](https://img.fengqigang.cn//img/20210409205253.png)

**内部类只有依赖于外围类来触发类加载, 其他都不行**

### 成员内部类中成员方法特点是什么样的?

1. 可以 **有普通成员方法**

2. **没有静态成员方法**

**静态成员方法会触发类加载**

### 成员内部类中有没有构造器和代码块?

**构造器**

必须有，需要创建对象，需要给成员变量赋值

**代码块**

静态代码块 **没有**

构造代码块有

### 成员内部类与外围类相互依赖而存在吗?

不是

成员内部类对象 **依赖于** 外围类对象而存在

外围类对象 **并不依赖于** 成员内部类对象

### 外部的类可以继承内部类吗?

可以

### 成员内部类有什么特点?

1. 成员内部类和外围类是亲兄弟，自己人，它们之间的访问 **不受访问权限限制， 即便私有的，它们也可以互相访问**

2. 成员内部类的对象 **依赖于外围类对象** 而存在

### 成员内部类的成员方法中，有没有外围类对象?

有， 有外围类对象才能有内部类对象，内部类对象存在了，外围类对象必然存在

### 外围类的成员方法中，有没有成员内部类对象?

没有， 外围类对象和内部类对象没有依赖关系，如果想有，需要手动创建

### 若成员内部类中和外围类成员有同名，怎么办?

**普通成员变量同名**

1. 什么都不加，就近原则，优先选择内部类自身的成员

2. 可以用 **this** , 表示内部类自身的成员

3. 内部类的成员方法中必然有外围类对象，也有一个引用指向它，作类一个隐藏的传参，用 **外围类的类名.this** 表示

### 如果成员内部类中静态成员变量同名怎么办?

成员内部类中 **没有静态成员变量**

### 如果成员内部类中全局常量同名怎么办?

用类名去区分

### 外围类如何访问成员内部类成员?

1. 创建内部类对象






