---
title: "Day11"
date: 2021-04-10T22:36:59+08:00
lastmod: 2021-04-10
author: "xiaonan"
math:
 enable: true

tags: [java]
categories: [王道]
---

### **new 类名().new 类名()** 与 **new 类名.new** 这两种方式有什么区别?

**new 类名().new 类名()**

创建成员内部类

**new 外围类类名.new 静态内部类类名()**

创建静态内部类

### 局部内部类有什么优缺点?

**优点**

绝对的封装性，并且可以少创建一个 **class**, 相对来说简单一点

**缺点**

局部内部类作用域仅限于方法，如果别的类， 别的方法也想用这个类 做不到

### ![20210410192027](https://img.fengqigang.cn//img/20210410192027.png) 可以进行吗?为什么?

可以，**任何时候都有父类**，哪怕是实现了一个接口

### ![20210410192444](https://img.fengqigang.cn//img/20210410192444.png) , 为什么 **a++** 无法执行?

1. 生命周期的问题

方法的局部变量的生命周期和方法同生共死, 方法出栈就销毁

但是 **局部内部类的方法会创建对象**

于是出现方法出栈后，局部变量销毁了，但是对象仍然需要使用该局部变量的情况 

为了解决这种生命周期的冲突，**jvm** 会在创建局部内部类对象时，把方法的局部变量作为对象的成员变量加了进去

![20210410200236](https://img.fengqigang.cn//img/20210410200236.png)

2. 这个成员变量和局部变量值同步的问题

如果在局部内部类当中， 把这个局部变量给修改了，那就必须同步这个修改，否则程序就有问题

但是这样显然太复杂了，**java** 的开发都觉得不想做了，于是直接把这个局部变量声明为 **final** 做为一个常量，直接不修改，就不需要考虑同步问题

**Java8** 之前，如果想用局部内部类访问方法的局部变量， 该局部变量必须声明为 **final**

**Java8** 之后， 这个限制被解除了，改为在底层直接加上 **final**, 不需要程序再加了

这就是 **语法糖**

### **匿名内部类** 和 **lambda** 的局部变量有什么特殊的地方?

**匿名内部类** 和 **lambda** 本质的是 **局部内部类**

它们的局部变量仍然是 **final** 修饰的

### 内部类实现多继承的思路是什么?

![20210410200710](https://img.fengqigang.cn//img/20210410200710.png)

### 内部类有什么优缺点?

**优点**

1. 无条件地访问外围类的所有元素

**成员内部类**, **静态内部类**, **局部内部类**, **匿名内部类** 都可以无条件访问

2. 隐藏类

可以用 **private**, **protected** 修饰类

**private** 修饰成员内部类, 提供 **public** 的创建对象方法

3. 实现多继承

可以创建多个成员内部类继承外部多个类

然后创建内部类对象，实际上就是外围类继承了多个类的成员

![20210410200710](https://img.fengqigang.cn//img/20210410200710.png)

4. 通过匿名内部类来优化简单的接口实现

**缺点**

1. 语法复杂


**内部类就应该给外围类用，不需要给外部类用，给它用是有风险的**

### ![20210410201549](https://img.fengqigang.cn//img/20210410201549.png) 如何调用输出"我在学习局部内部类"?


![20210410201738](https://img.fengqigang.cn//img/20210410201738.png)


### 什么是匿名类(Anonymous Class)?

如果一个类没有名字，那么这个类就是匿名类

### 如何定义一个匿名内部类?


```java
new 接口名/类名(普通类, 抽象类) () {
};
```

![20210410202339](https://img.fengqigang.cn//img/20210410202339.png)




