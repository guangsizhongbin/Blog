---
title: "Day3"
date: 2021-03-31T22:56:56+08:00
lastmod: 2021-03-31
author: "xiaonan"
math:
 enable: true

tags: [java]
categories: [王道]
---

### 可变参数的实质是什么?

是用数组作为参数

```java
public static int sum(int[] arr) {
	int sumValue = 0;
	for (int i = 0; i < arr.length; i++) {
		sumValue += arr[i];
	}
	return sumValue;
}

public static int sum(int... a) {
	return 1;
}
```

![](https://img.fengqigang.cn//img/20210331194134.png)

### 在使用可参数列表的时候，需要注意什么?

1. 尽量不要使用带有两个可变参数的方法，构成方法重载时要慎重，因为很容易会导致两个方法都不可用

2. 可变参数一定要在参数列表的最后一个

否则有可能运行不了

![](https://img.fengqigang.cn//img/20210331195511.png)


### 什么是增强型 **for** 遍历数组?
```java
for (int i : arr) {
	System.out.print(i + "\t");
}
```

**此时这里的i, 相当于数组中的元素，而不是数组中的下标**

### 什么时候用普通for循环? 什么时候用增强for循环？

- 普通的 **for** 循环中有i， 是数组的下标

- 增强 **for** 中没有下标，直接获取数组的元素

**因此**

在遍历过程中，需要使用下标的话，必须要用普通for

直接遍历的话， 使用 **for** 形式比较简单

### 在定义可变参数时应注意什么?

### 什么是值传递? 什么是引用传递？

**值传递**

实际上参数只传入了它的拷贝

方法结束后，随着方法栈帧的出栈，这个拷贝被销毁了，对原先的参数变量 **没有影响**

**引用传递**

方法的实际参数传入的就是地址，就是把它本身传入了

方法结束后，随着方法出栈帧，装地址的变量是被销毁了，原先的变量要 **受到影响**

### 如果方法重载，同时有固定参数的方法恰好对应，方法调用时会怎样做?

会优先调用固定参数的方法

### 什么是语法糖？

在实现原理不变，实现效果不变的情况下，但是可以简化程序员的操作，在底层处理数据，底层进行封装

### 若基本类型的值传递,其JVM内存图是什么样的?![](https://img.fengqigang.cn//img/20210331200124.png)

1. 基本数据类型不会 **占用堆内存**

2. 值传递只是传递了它的拷贝， 方法结束后，随着方法栈帧出栈，这个拷贝被销毁.

![](https://img.fengqigang.cn//img/20210331200732.png)

若其是值传递的，获取的是a的拷贝

在方法中，a的取值变成了原先的2倍

方法执行结束后，栈帧出栈，该拷贝销毁了

原先的实参没有发生任何变化

### 若基本类型的引用传递,其JVM内存图是什么样的?![](https://img.fengqigang.cn//img/20210331200124.png)

1. 基本数据类型不会 **占用堆内存**

2. 引用传递，实际传递的就是其地址，就是将其本身传入进去了

![](https://img.fengqigang.cn//img/20210331201312.png)

如果它是引用传递的，获取的就是a的地址

在方法中，把a变成2倍

这样原先的实参a也变成2倍

### 交换两个数组的值传递，其JVM内存图是什么样的?![](https://img.fengqigang.cn//img/20210331203755.png)

1. 引用数据类型会 **占用堆内存空间**

2. 值传递只是传递了它的拷贝， 方法结束后，随着方法栈帧出栈，这个拷贝被销毁.

![](https://img.fengqigang.cn//img/20210331202014.png)

如果是值传递，拿到的是引用的拷贝

然后指向了原先的数组对象

方法中交换了两个引用(地址)

但是随着方法出栈，拷贝被销毁了

原先的（实参）引用，没有被交换了

### 交换两个数组的引用传递，其JVM内存图是什么样的?![](https://img.fengqigang.cn//img/20210331203755.png)

1. 引用数据类型会 **占用堆内存空间**

2. 引用传递，实际传递的就是其地址，就是将其本身传入进去了

![](https://img.fengqigang.cn//img/20210331202151.png)

如果是引用传递，拿到的是引用的地址

在方法中交换地址， 会成功

并且会体现到实参的引用中

### 引用数据类型（数组）的值传递是什么样的? 其JVM内存图是什么样的?![](https://img.fengqigang.cn//img/20210331203028.png)

1. 引用数据类型会 **占用堆内存空间**

2. 值传递只是传递了它的拷贝， 方法结束后，随着方法栈帧出栈，这个拷贝被销毁.

![](https://img.fengqigang.cn//img/20210331203121.png)

若它是值传递，获取的是引用的拷贝引用中装的是地址

于是拷贝也拿到了地址指向了同一个数组对象

那么用拷贝的引用修改原先的数组对象中的元素的取值，是能够成功的

并且实参的那个引用，再去访问原先的数组，数组元素也发生了变化

### 引用数据类型（数组）的引用传递是什么样的? 其JVM内存图是什么样的?![](https://img.fengqigang.cn//img/20210331203028.png)

1. 引用数据类型会 **占用堆内存空间**

2. 引用传递，实际传递的就是其地址，就是将其本身传入进去了

![](https://img.fengqigang.cn//img/20210331203446.png)

假设它是引用传递，获取的是引用的地址，这个地址就相当于拿到了这个引用

方法里面拿到引用然后修改数组元素的取值是可以成功的

然后方法出栈，这个装地址的变量被销毁了，原先的数组仍会被改变


