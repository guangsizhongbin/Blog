<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>java - Tag - xiaonan&#39;s Blog</title>
        <link>http://fengqigang.cn/tags/java/</link>
        <description>java - Tag - xiaonan&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>gaungsizhongbin@gmail.com (xiaonan)</managingEditor>
            <webMaster>gaungsizhongbin@gmail.com (xiaonan)</webMaster><lastBuildDate>Fri, 23 Apr 2021 09:17:16 &#43;0800</lastBuildDate><atom:link href="http://fengqigang.cn/tags/java/" rel="self" type="application/rss+xml" /><item>
    <title>Day21</title>
    <link>http://fengqigang.cn/posts/day21/</link>
    <pubDate>Fri, 23 Apr 2021 09:17:16 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day21/</guid>
    <description><![CDATA[同步方法中的锁对象是什么? 同步代码块中
任意java对象
任意方法中
this
静态方法中
字节码文件对象（.clsss） 补充代码
为什么在同步代码块中可以放一个任意的对象?  因为 java 当中所有对象， 内部都存在一个 标志位，表示加锁和解锁的状态 其实锁对象，就是充当锁的角色  所谓的加锁解锁，其实就是 设置锁对象的标志位，来表示加锁解锁的状态
当某个线程执行到同步代码块时，遇到加锁或无锁时会怎么处理?  当锁对象处于未加锁状态， jvm 就会设置锁对象的标志位(加锁)， 并在锁对象中记录，是哪个线程加的锁. 加锁成功， 执行同步代码块中的代码。 如果锁对象 已经被加锁, 且加锁线程不是当前线程，系统会让当前线程处于阻塞状态(等着)， 直到加锁线程，执行完了对共享变量的组操作，并释放锁。  加锁线程何时释放锁? 当加锁线程，执行完了同步代码块中的代码(对共享变量的一组操作)，在退出同步代码块之前,
jvm 自动清理锁对象的标志位，将锁对象变成未上锁状态(释放锁)
如何使用 Lock 锁住对象?  定义一把锁  Lock lock = new ReentrantLock();
美[ˌriˈɛntrənt]
public ReentrantLock()
Creates an instance of ReentrantLock. THis is equivalent to using ReentrantLock(false).
获取锁  lock.lock();
void lock()
Acquires the lock.
释放锁  lock.]]></description>
</item><item>
    <title>Day20</title>
    <link>http://fengqigang.cn/posts/day20/</link>
    <pubDate>Wed, 21 Apr 2021 17:00:51 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day20/</guid>
    <description><![CDATA[线程有哪5种状态? 新建:
刚创建的线程，没有执行 start() 方法， 没有资格去挣抢CPU资源
就绪
刚执行了 start 方法， 但是还没有获得CPU的执行权
执行
抢到了 CPU的执行权
阻塞
没有 CPU 的执行权，还缺少必要的条件（sleep 结束）
死亡
run 方法执行完之后
线程5个状态之间是如何转换? 用Runnable实现多线程?   实现 Runnable 接口
  重写 run 方法
  创建 Runnable 子类对象
  创建 Thread 对象， 并且把 Runnable 子类对象作为参数传递
  start 方法
  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class RunnableDemo { public static void main(String[] args) { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.]]></description>
</item><item>
    <title>Day19</title>
    <link>http://fengqigang.cn/posts/day19/</link>
    <pubDate>Tue, 20 Apr 2021 20:03:24 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day19/</guid>
    <description><![CDATA[如何实现程序睡眠3秒? TimeUnit.SECONDS.sleep(3)；
1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class TestSleep { static boolean flag = true; public static void main(String[] args) throws InterruptedException { sayHelloRecycling(); } private static void sayHelloRecycling() throws InterruptedException { while(flag){ System.out.println(&#34;你好&#34;); TimeUnit.SECONDS.sleep(3); } } }   什么是进程? 操作系统进行 资源分配与调度 的基本单位.
一个正在运行的程序，软件都可以称为进程
进程之间是互不干扰的
什么是线程? CPU 进行 资源分配与调试 的基本单位，从执行路径的角度来看在，每一条执行路径都是1个线程
进程和线程的关系？ 线程依赖于进程而存在
线程之间是共享进程资源的
一个进程可以有 最少一个线程
什么是串行, 并行，并发? 串行:]]></description>
</item><item>
    <title>Day18</title>
    <link>http://fengqigang.cn/posts/day18/</link>
    <pubDate>Mon, 19 Apr 2021 21:57:49 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day18/</guid>
    <description><![CDATA[为什么要将 FileOutputStream out = null; 放在外面，可以放在 try 语句里面? 不可以
放在 out 中， 其作用的域只能在 try 中， finally 中的 try 无法使用
reader 的继承关系是什么样的? InputStreamReader 的构造方法是什么样的? 1 2 3 4 5 6 7 8 9  public class CountNum { public static void main(String[] args) throws IOException { // 第一种构造方法  InputStreamReader in = new InputStreamReader(new FileInputStream(&#34;a.txt&#34;)); // 第二种构造方法  InputStreamReader input = new InputStreamReader(new FileInputStream(&#34;a.txt&#34;), &#34;GBK&#34;); } }   如何使用 InputStreamReader 实现单个 char 的构造方法?]]></description>
</item><item>
    <title>Day17</title>
    <link>http://fengqigang.cn/posts/day17/</link>
    <pubDate>Sun, 18 Apr 2021 23:19:15 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day17/</guid>
    <description><![CDATA[如何实现对 FilterInput 实现装饰器模式, 对接收到的字母转换成小写? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  public class Demo { public static void main(String[] args) throws IOException { // 方法一:  BufferedInputStream br = new BufferedInputStream(new FileInputStream(&#34;a.]]></description>
</item><item>
    <title>Day16</title>
    <link>http://fengqigang.cn/posts/day16/</link>
    <pubDate>Fri, 16 Apr 2021 21:49:13 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day16/</guid>
    <description><![CDATA[字节流是怎么分类的?   字节输出流 - 抽象基类 - OutputStream - 具体子类 - FileOutputStream - BufferedOutputStream
  字节输入流 - 抽象基类 - InputStream - 具体子类 - FielInputStream - BufferedInputStream
  字符流是怎么分类的？   字符输出流
  字符输入流
  什么是IO? i: input 输入
o: output 输出
为什么会有 IO? 需要长久保存的数据都是以文件的形式存储的，存储在外边设备当中
内存有限，需要把数据读取到内存才行，需要io交互
java 流模型是什么样的? java 中的流是怎么分类的?  按照流向分(以内存为参照)  输入流 input 输出流 output   按照数据类型分类  字节流: 一连串的 01 二进制数据 按字节传输 1B = 8 bit 0000 0000 字符流: 一连串的字符的字符序列，把它当做一种文化符号 &ldquo;abc&rdquo;, &ldquo;你&rdquo;    java IO抽象基类有哪些?]]></description>
</item><item>
    <title>Day15</title>
    <link>http://fengqigang.cn/posts/day15/</link>
    <pubDate>Thu, 15 Apr 2021 21:58:11 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day15/</guid>
    <description><![CDATA[如何 catch， 判断是否实现空接口?  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public class demo { public static void main(String[] args) { A a = new A(); try { checkCloneable(a); } catch (CloneNotSupportedException e) { e.printStackTrace(); System.out.println(&#34;请实现空接口!&#34;); } System.out.println(&#34;111&#34;); } private static void checkCloneable(A a) throws CloneNotSupportedException { if (a instanceof Cloneable) { System.]]></description>
</item><item>
    <title>Day14</title>
    <link>http://fengqigang.cn/posts/day14/</link>
    <pubDate>Wed, 14 Apr 2021 23:01:03 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day14/</guid>
    <description><![CDATA[什么是单分支的 try&hellip;catch, 其语法是什么? try { //可能出现异常的，正常的代码逻辑 } catch (要捕捉的异常对象){ //在catch分支中处理具体类型的代码异常 }
在 try&hellip;catch 中 的 catch 如何写? 1 2 3 4 5 6 7 8 9 10 11 12  public class Sort { public static void main(String[] args) { try { System.out.println(&#34;1111&#34;); System.out.println(10/0); System.out.println(&#34;2222&#34;); } catch (ArithmeticException ae){ System.out.println(&#34;发生了算数除0异常&#34;); } System.out.println(&#34;3333&#34;); } }   catch 中必须是一个抛出异常类的对象声明
try..catch 中代码是如何执行的?  如果 try 当中没有异常  那么 try 中的代码会正常执行完毕， catch 也叫异常处理器，如果没有异常，那么它不会工作，既然没有异常，整个 try&hellip;catch 后的代码正常执行]]></description>
</item><item>
    <title>Day13</title>
    <link>http://fengqigang.cn/posts/day13/</link>
    <pubDate>Tue, 13 Apr 2021 21:42:49 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day13/</guid>
    <description><![CDATA[在进行深拷贝时，如何实现一个空接口？ Cloneable 并不是自己实现的
如何将byte数组转成 String, 并输出它 在 JDK 源码当中， 涉及区间的方法，一般都是怎么规定区间的? 左闭右开
这种做法是为了适配数组从0开始的下标
会输出什么? 会直接输出整个 String
String 对象中的不可变性，JVM 内存图是什么样的? 静态常量池 是干什么的? 在用字面值常量给 String 对象赋值时，在编译时期就加入了 常量池
当常量池中已存在某位字符串对象时，当需要使用时，就不需要在堆上重新创建对象了，而是直接去指向这个常量池中的字符串对象
它们的值是什么? s.equals(s2) 是根据值来判断的
它们会输出什么? s3 == (s1 + s2) 肯定不能编译确定取值，必须运行期确定，那么它的对象就一定不在常量池，而在堆上
判断一个字符串是否为空可以采取什么样的方法? equals
1 2 3 4 5 6  public class supertest { public static void main(String[] args) { String s = &#34;abc&#34;; System.out.println(&#34;&#34;.equals(s)); } }   如果s是null, 会导致报错
如何比较这两个字符串，并忽略大小写? a.equalsIgnoreCase(b)
1 2 3 4 5 6 7  public class supertest { public static void main(String[] args) { String s = &#34;abc&#34;; String s1 = &#34;ABC&#34;; System.]]></description>
</item><item>
    <title>Day12</title>
    <link>http://fengqigang.cn/posts/day12/</link>
    <pubDate>Mon, 12 Apr 2021 23:48:15 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day12/</guid>
    <description><![CDATA[什么是 API ? Application Programming Interface(API)
应用程序编程接口，在Java 当中指的是一些先定义好的类和方法
作用
开发者可以在不关注具体实现细节的前提下，使用和这些已经预先定义好的类和方法实现自己的需求
Object 类有什么特点?   Object 类所有类继承层次的祖先类, 所有类(包括数组)都 直接或间接的继承 自该类，都实现了该类的方法
  在自定义类时，并不需要特别标注 extends Object
  如果一个类没有明确的的指出它的父类，Object 类就默认被认为是这个类的父类，extends Object 则被省略了
  为什么所有类都有一个默认无参?   当一个类没有定义构造方法的时候，就会自动添加默认构造方法
  一旦有默认构造方法，在创建子类对象的时候，就会执行子类对象的隐匿初始化
  隐式初始化，默认调用父类的无参构造
  最终，一定能保证，调用到 Object 类的无参构造方法，先初始化 Object 这个父类
  为什么不能访问 clone 方法 clone 方法是 protect 修饰的， 只能在自己的子类中访问
方法声明中 public final Class&lt;?&gt; getClass() 分另代表什么意思?   public 访问权限，调用时不必考虑权限问题
  final 该方法可以被继承但是不能被重写]]></description>
</item></channel>
</rss>
