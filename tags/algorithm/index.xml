<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>algorithm - Tag - xiaonan&#39;s Blog</title>
        <link>http://fengqigang.cn/tags/algorithm/</link>
        <description>algorithm - Tag - xiaonan&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>gaungsizhongbin@gmail.com (xiaonan)</managingEditor>
            <webMaster>gaungsizhongbin@gmail.com (xiaonan)</webMaster><lastBuildDate>Thu, 07 Jan 2021 09:34:11 &#43;0800</lastBuildDate><atom:link href="http://fengqigang.cn/tags/algorithm/" rel="self" type="application/rss+xml" /><item>
    <title>ShellSort</title>
    <link>http://fengqigang.cn/posts/shellsort/</link>
    <pubDate>Thu, 07 Jan 2021 09:34:11 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/shellsort/</guid>
    <description><![CDATA[<h2 id="shellsort">ShellSort</h2>
<p>Shell 排序动图</p>
<p></p>]]></description>
</item><item>
    <title>InsertionSort</title>
    <link>http://fengqigang.cn/posts/insertionsort/</link>
    <pubDate>Wed, 06 Jan 2021 16:31:09 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/insertionsort/</guid>
    <description><![CDATA[<h2 id="插入排序">插入排序</h2>
<p></p>]]></description>
</item><item>
    <title>Selection_Sort</title>
    <link>http://fengqigang.cn/posts/selectionsort/</link>
    <pubDate>Tue, 05 Jan 2021 19:30:27 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/selectionsort/</guid>
    <description><![CDATA[选择排序 C语言实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include &lt;stdio.h&gt; void swap(int *a, int *b) void selection_sort(int arr[], int len) void selection_sort(int arr[], int len) { int i, j; for(i=0; i&lt;len -1; i++) { int min = i; for(j = i+1; j &lt; len; j++) if (arr[j] &lt; arr[min]) min = j; swap(&amp;arr[min], &amp;arr[i]); } }   Note    前面的元素与后面的元素一一对比, 若后面的元素小，将最小元素的的序号替换成它, 最后前的元素的值与最小序号所对的值替换]]></description>
</item><item>
    <title>Bubble_Sort</title>
    <link>http://fengqigang.cn/posts/bubble_sort/</link>
    <pubDate>Mon, 04 Jan 2021 20:48:16 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/bubble_sort/</guid>
    <description><![CDATA[冒泡排序 C语言实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  #include &lt;stdio.h&gt; void print_list(int arr[], int len); void bubble_sort(int arr[], int len); void bubble_sort(int arr[], int len) { int i, j, temp; printf(&#34;初始list为:&#34;); print_list(arr, len); printf(&#34;\n&#34;); int k = 1; for(i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; printf(&#34;第%d次替换后的list : &#34;, k); print_list(arr, len); printf(&#34;\n&#34;); k+=1; } } void print_list(int arr[], int len) { int i; for (i=0; i&lt; len; i++) printf(&#34;%d &#34;, arr[i]); } int main() { int arr[] = { 22, 34, 3, 4}; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); return 0; }      次数 list 状态 解释 i j 是否有移动     0 22 34 3 4 初始化 0 0    1 22 34 3 4 22(前)与34(后)比较, 22小, 不移动, j+1 0 0-&gt;1    2 22 3 34 4 34(前)与3(后)比较, 3小, 移至前面, j+1 0 1-&gt;2 *   3 22 3 4 34 34(前)与4(后)比较, 4小, 移至前面，j+1(此时j+1后=len - 1 - i), 跳出当前循环，i+1, j变为0 0-&gt;1 2-&gt;3-&gt;0 *   4 3 22 4 34 22(前)与3(后)比较，3小, 移至前面，j+1 1 0-&gt;1 *   5 3 4 22 34 22(前)与4(后)比较，4小, 移至前面，j+1(此时j+1后=len - 1 - i), 跳出当前循环, i+1, j变为0 1-&gt;2 1-&gt;2-&gt;0 *   6 3 4 22 34 3(前)与4(后), 3小，不移动, j+1, (此时j+1=len - 1 - i), 跳出当前循环， i+1 (此时i=len -1)退出上层循环 2-&gt;3 0-&gt;1     标准冒泡排序时间复杂度与空间复杂度分析 时间复杂度 1 2 3 4 5 6 7 8 9 10 11 12  void bubble_sort(int arr[], int len) { int i, j, temp; for(i = 0; i &lt; len - 1; i++) for (j = 0; j &lt; len -1 -i; j++) if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; } }      语句 cost times     int i, j, temp $C_1$ 1   i &lt; len - 1 $C_2$ n(n次判断)   i++ $C_3$ n - 1(不满足条件不加)   j=0 $C_4$ i++只会执行n-1次，即j=0执行n-1次   j &lt; len - 1 - i $C_5$ $t_1$(i=0) + $t_1$(i=1) + &hellip; + $t_1$(i = n-2) + $t_1$(i = n-1), 最多执行n-1次   j++ $C_6$ $t_2$(i=0) + $t_2$(i=1) + &hellip; + $t_2$(i = n-2) + $t_2$(i = n-1)   arr[j + 1] &lt; arr[j] $C_7$ $t_3$(i=0) + $t_3$(i=1) + &hellip; + $t_3$(i = n-2) + $t_3$(i = n-1)   swap(arr, j, j+1) $C_8$ $t_4$(i=0) + $t_4$(i=1) + &hellip; + $t_4$(i = n-2) + $t_4$(i = n-1)    算法总的运行时间是第一条语句执行时间之和。如果执行一条语句需要c_i步，又共执行了n次这条语句。那么它在运行时间中占cin为计算总运行时间T[n], 对第一对cost与times这积求和。]]></description>
</item></channel>
</rss>
