<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>spring - Tag - xiaonan&#39;s Blog</title>
        <link>http://fengqigang.cn/tags/spring/</link>
        <description>spring - Tag - xiaonan&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>gaungsizhongbin@gmail.com (fengxiaonan)</managingEditor>
            <webMaster>gaungsizhongbin@gmail.com (fengxiaonan)</webMaster><lastBuildDate>Thu, 09 Sep 2021 22:30:23 &#43;0800</lastBuildDate><atom:link href="http://fengqigang.cn/tags/spring/" rel="self" type="application/rss+xml" /><item>
    <title>01 @Autowired与@Resource的区别</title>
    <link>http://fengqigang.cn/posts/01-autowired%E4%B8%8Eresource%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
    <pubDate>Thu, 09 Sep 2021 22:30:23 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/01-autowired%E4%B8%8Eresource%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
    <description><![CDATA[区别   来源不同   @Resource是java自带的
@AutoWired是spring带来的
 注入的方式不同   @Autowired 只按照 byType 注入
出现多个实现bean时可以用@Primary 来修饰也可以用@Qualifier来标注需要注入的类
@Resource 默认按 byName 注入
出现多个实现bean时可以用name=xxx来指定
实战  HumanController  1 2 3 4 5 6 7 8 9 10 11 12  @RestController @RequestMapping(&#34;/an&#34;) public class HumanController { @Autowired private Human human; @RequestMapping(&#34;/run&#34;) public String runMarathon(){ return human.runMarathon(); } }    Human  1 2 3  public interface Human { String runMarathon(); }    Man  1 2 3 4 5 6 7 8  @Service public class Man implements Human { @Override public String runMarathon() { return &#34;A man run marathon&#34;; } }    Woman  1 2 3 4 5 6 7  @Service public class Woman implements Human { @Override public String runMarathon() { return &#34;An woman run marathon&#34;; } }     加入@Primary, 帮助@autowired找到对应的实现类    使用@autowired时，也可以加入@Qualifier(&ldquo;xxx&rdquo;)来指定    使用@Resource时, 指定name, name后的名字要小写    使用@Resource时，再加入@Qualifier(&ldquo;xxx&rdquo;)来指定   ]]></description>
</item><item>
    <title>02 Spring测试源码学习环境是否搭建成功</title>
    <link>http://fengqigang.cn/posts/02-spring%E6%B5%8B%E8%AF%95%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%98%AF%E5%90%A6%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F/</link>
    <pubDate>Tue, 24 Aug 2021 23:57:01 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/02-spring%E6%B5%8B%E8%AF%95%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%98%AF%E5%90%A6%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F/</guid>
    <description><![CDATA[新建module  新建 moudle  选择 gradle 项目(spring-study)  查看项目是否导入成功 在整个项目的 settings.gradle 是否引入 spring-study 项目
设置项目依赖 在新建的 moudle 下打开 build.gradle 引入下面的依赖 spring-beans, spring-context, spring-core, spring-expression, spring-instrument
新建测试 bean  cn.fengqigang.bean.Person  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  package cn.]]></description>
</item><item>
    <title>01 Spring源码环境搭建</title>
    <link>http://fengqigang.cn/posts/01-spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
    <pubDate>Tue, 24 Aug 2021 23:54:53 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/01-spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
    <description><![CDATA[克隆spring 5.1.x 源代码 1  git clone -b 5.1.x https://github.com/spring-projects/spring-framework.git   查看导入idea的需要注意的事项，并执行  Precompile spring-oxm with ./gradlew :spring-oxm:compileTestJava  import-into-idea.md
在 spring-framework 文件夹下运行以下命令
1  ./gradlew :spring-oxm:complieTestJavals   等待大约7分钟
 Import into IntelliJ (File -&gt; New -&gt; Project from Existing Sources -&gt; Navigate to directory -&gt; Select build.gradle)
  When prompted exclude the spring-aspects module (or after the import via File-&gt; Project Structure -&gt; Modules)
  code away  ]]></description>
</item><item>
    <title>Aop</title>
    <link>http://fengqigang.cn/posts/aop/</link>
    <pubDate>Mon, 28 Jun 2021 23:14:37 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/aop/</guid>
    <description><![CDATA[AOP编程实战   引入依赖
  注册委托类组件
  提供一个通知组件并注册(MethdoInterceptor 是来自于 org.aopalliance.intercept)
  ASPECT 强化advisor - pointcut advisor 的时间属性   Before
  After
  Around
  AfterReturning
  AfterThrowing
  joinPoint 的参数 ProceedingJoinPoint extends 于 JoinPint
  getSignature() 方法信息
  getName() 方法名
  getArgs() 参数
  getThis() proxy
  getTarget() 委托类对象
  CustomAspect  指定组件为切面组件 @Aspect , 保留@Component  配置切入点 @Pointcut(&ldquo;execution(* cn.]]></description>
</item><item>
    <title>Spring02</title>
    <link>http://fengqigang.cn/posts/spring02/</link>
    <pubDate>Fri, 25 Jun 2021 23:23:09 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/spring02/</guid>
    <description><![CDATA[02_Spring
builder 设计模式  注意
 如果setIq 和 sethair 方法中的 head, 如果没有初始化的话会出现空指针异常
  处理方法:
  HumanBuilder
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class HumanBuilder { Human human = new Human(); public Head setIq(Integer iq) { Head head = human.getHead(); head.setIq(iq); return head; } public Head setHair(String hair) { Head head = human.getHead(); head.setHair(hair); return head; } }   Human]]></description>
</item><item>
    <title>Spring01</title>
    <link>http://fengqigang.cn/posts/spring01/</link>
    <pubDate>Thu, 24 Jun 2021 23:51:14 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/spring01/</guid>
    <description><![CDATA[单例模式 构造方法后没有;
public class 后没有()
线程不安全的立即加载单例模式 高并发下并不安全
1 2 3 4 5 6 7 8 9 10 11  public class TestSigteon { static TestSigteon testSigteon; private TestSigteon(){} public static TestSigteon getSigteonInstance(){ if(testSigteon == null){ testSigteon = new TestSigteon(); } return testSigteon; } }   线程安全的立即加载单例模式 将 synchronized 放在 public 与 static 之间
1 2 3 4 5 6 7 8 9 10 11  public class TestSigteon { static TestSigteon testSigteon; private TestSigteon(){} public synchronized static TestSigteon getSigteonInstance(){ if(testSigteon == null){ testSigteon = new TestSigteon(); } return testSigteon; } }   什么是懒加载和立即加载?]]></description>
</item></channel>
</rss>
