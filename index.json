[{"categories":["王道"],"content":"02_Spring ","date":"2021-06-25","objectID":"/posts/spring02/:0:0","tags":["spring"],"title":"Spring02","uri":"/posts/spring02/"},{"categories":["王道"],"content":"builder 设计模式 注意 如果setIq 和 sethair 方法中的 head, 如果没有初始化的话会出现空指针异常 处理方法: HumanBuilder public class HumanBuilder { Human human = new Human(); public Head setIq(Integer iq) { Head head = human.getHead(); head.setIq(iq); return head; } public Head setHair(String hair) { Head head = human.getHead(); head.setHair(hair); return head; } } Human @Data public class Human { Head head = new Head(); Body body = new Body(); Leg leg = new Leg(); } head @Data public class Head { Integer iq; String hair; } Leg @Data public class Leg { } ","date":"2021-06-25","objectID":"/posts/spring02/:0:1","tags":["spring"],"title":"Spring02","uri":"/posts/spring02/"},{"categories":["王道"],"content":"builder 设计模式进一步思考? 实现不停的 setHead 和 setHair 可以在Humanbuilder中return builer @Data public class HumanBuilder { Human human = new Human(); public HumanBuilder setIq(Integer iq) { Head head = human.getHead(); head.setIq(iq); return this; } public HumanBuilder setHair(String hair) { Head head = human.getHead(); head.setHair(hair); return this; } } ","date":"2021-06-25","objectID":"/posts/spring02/:0:2","tags":["spring"],"title":"Spring02","uri":"/posts/spring02/"},{"categories":["王道"],"content":"Spring 入门案例一 引入依赖 在 resources 中写下application.xml的配置文件 单元测试 获取实例 getBean 引入依赖 (5 + 1) 5.25 RELEASE context \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-context --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context\u003c/artifactId\u003e \u003cversion\u003e5.2.5.RELEASE\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 在resours 中写下application.xml的配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c!-- bean definitions here --\u003e \u003cbean id=\"userService\" class=\"cn.fengqigang.SpringIoc.UserServiceIml\"/\u003e \u003cbean id=\"userService1\" class=\"cn.fengqigang.SpringIoc.UserServiceIml\"/\u003e \u003c/beans\u003e 单元测试 UserService public interface UserService { void sayHello(); void sayHello1(String name); } UserServiceIml public class UserServiceIml implements UserService { @Override public void sayHello() { System.out.println(\"hello somebody\"); } @Override public void sayHello1(String name) { System.out.println(\"hello\" + name); } } junit applicationContext.getBean 的三种方式 id(String) class 当该类型的组件只有一个的时候,才可以通过类型取出 此时 UserService.class 有两个, 会出现报错 String + class 单例与不同的组件是什么关系? public void testSpring03(){ ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application.xml\"); UserService userService1 = applicationContext.getBean(\"userService\", UserService.class); UserService userService2 = applicationContext.getBean(\"userService\", UserService.class); UserService userService3 = applicationContext.getBean(\"userService\", UserService.class); UserService userServicea = applicationContext.getBean(\"userService1\", UserService.class); UserService userServiceb = applicationContext.getBean(\"userService1\", UserService.class); UserService userServicec = applicationContext.getBean(\"userService1\", UserService.class); } 一个组件实现一个单例 ","date":"2021-06-25","objectID":"/posts/spring02/:0:3","tags":["spring"],"title":"Spring02","uri":"/posts/spring02/"},{"categories":["王道"],"content":"入门案例二(注册多个组件并且有关联关系) @Test public void test02() { ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"application.xml\"); UserService userService = applicationContext.getBean(UserService.class); userService.sayHello(); } 不设置时 Bean实例化 构造方法 无参构造 有参构造 工厂 静态工厂 factroy-method 为静态工厂中的方法 实例工厂 factory-bean 为实例工厂的id factory-method 为工厂中的方法 FactroyBean 继承 FactroyBean ","date":"2021-06-25","objectID":"/posts/spring02/:0:4","tags":["spring"],"title":"Spring02","uri":"/posts/spring02/"},{"categories":["王道"],"content":"Bean的作用域 singleton prototype ","date":"2021-06-25","objectID":"/posts/spring02/:0:5","tags":["spring"],"title":"Spring02","uri":"/posts/spring02/"},{"categories":["王道"],"content":"生命周期 BeanPostProcessor 除了BeanPostProcessor组件本身,其他所有的组件都会执行到对应的方法 implements BeanPostProcessor postProcessBeforInitialization postProcessAfterInitialization 自定义的方法 Init-method=“xxxx” ","date":"2021-06-25","objectID":"/posts/spring02/:0:6","tags":["spring"],"title":"Spring02","uri":"/posts/spring02/"},{"categories":["王道"],"content":"单例模式 构造方法后没有; public class 后没有() 线程不安全的立即加载单例模式 高并发下并不安全 public class TestSigteon { static TestSigteon testSigteon; private TestSigteon(){} public static TestSigteon getSigteonInstance(){ if(testSigteon == null){ testSigteon = new TestSigteon(); } return testSigteon; } } 线程安全的立即加载单例模式 将 synchronized 放在 public 与 static 之间 public class TestSigteon { static TestSigteon testSigteon; private TestSigteon(){} public synchronized static TestSigteon getSigteonInstance(){ if(testSigteon == null){ testSigteon = new TestSigteon(); } return testSigteon; } } 什么是懒加载和立即加载? 立即加载: 在调用实例化方法之前获取实例对象(利用类加载方法) 懒加载: 在调用实例化方法之后获取实例对象 线程安全的立即加载单例?(不使用synchronized) public class TestSigteon { private static TestSigteon testSigteon = new TestSigteon(); private TestSigteon() { } public synchronized static TestSigteon getSigteonInstance() { return testSigteon; } } private static TestSignteon testSigteon = new TestSigteon(); 是在调用实例化方法之后才去new TestSigteon()的 -\u003e 等价改写 public class TestSigteon { private static TestSigteon testSigteon; static { testSigteon = new TestSigteon(); } private TestSigteon() { } public synchronized static TestSigteon getSigteonInstance() { return testSigteon; } } 静态内部类的特点 public class Outter { public static void invokeInnerMethod() { System.out.println(\"调用内部类中的静态方法\"); Inner.InnerMethod(); } public static void noInvokeInnerMethod() { System.out.println(\"没有调用内部类中的静态方法\"); } public static class Inner { static { System.out.println(\"这里是静态内部类\"); } public static void InnerMethod() { System.out.println(\"InnerMethod\"); } } } Test public void test02(){ Outter.invokeInnerMethod(); Outter.noInvokeInnerMethod(); Outter.invokeInnerMethod(); Outter.invokeInnerMethod(); } 静态内部类的中 静态代码块只加载一次 线程安全的懒加载单例?(不使用synchronized) public class TestSigteon { private static TestSigteon testSigteon; private TestSigteon() { } public static TestSigteon getInnerInstance() { return Inner.getSigteonInstance(); } static class Inner { static { testSigteon = new TestSigteon(); } static TestSigteon getSigteonInstance() { return testSigteon; } } } ","date":"2021-06-24","objectID":"/posts/spring01/:0:1","tags":["spring"],"title":"Spring01","uri":"/posts/spring01/"},{"categories":["王道"],"content":"工厂模式 简单工厂模式 创建一个简单的工厂用来处理外面传进来的 animal 实现一个 animal 对象, 其它的小动物继承 animal 对象 factory public class AnimalFactory { public Animal getAnimalS(String animal) { if (\"Dog\".equals(animal)) { return new Dog(); } else if (\"Fish\".equals(animal)) { return new Fish(); } return null; } } animal public class Animal {} Dog public class Dog extends Animal{ } Fish public class Fish extends Animal{} 工厂方法 创建一个工厂接口 让其它money工厂实现这个接口 实现money接口 让其它的money实现这个接口 MoneyFactory inteface public interface MoneyFactory { public Money createMoney(); } money inteface public interface Money { } Dollar public class Dollar implements Money{ } DollarFactory public class DollarFactory implements MoneyFactory { @Override public Money createMoney() { return new Dollar(); } } DollarFactory 在写 createMoney 时, 写其实现子类即可 ","date":"2021-06-24","objectID":"/posts/spring01/:0:2","tags":["spring"],"title":"Spring01","uri":"/posts/spring01/"},{"categories":["王道"],"content":"代理模式 什么是静态代理和动态代理? 代理类需要自己写是静态代理 代理类不需要自己写是动态代理 静态代理模式 动态代理模式 jdk 的动态代理 jdk 的动态代理的委托类对象与代理对象都会实现同一个接口 它们都是基于接口 public interface UserService { public void sayHello(); public void sayHello1(String name); } public class UserServiceImpl implements UserService{ @Override public void sayHello() { System.out.println(\"hello\"); } @Override public void sayHello1(String name) { System.out.println(\"bye bye \" + name); } } public class JDKDynamic { public static void main(String[] args) { UserServiceImpl userService = new UserServiceImpl(); UserService userServiceImpl = (UserService) Proxy.newProxyInstance(UserServiceImpl.class.getClassLoader(), UserServiceImpl.class.getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object invoke = method.invoke(userService, args); return invoke; } }); userServiceImpl.sayHello1(\"孙\"); } } 保存生成的字节码文件 ProxyGenerator 设置working directory 放在当前module中 jdk 中的代理对象与委托类对象都是采取implement 同一个接口 cGlib 的动态代理 导入依赖 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecglib\u003c/groupId\u003e \u003cartifactId\u003ecglib\u003c/artifactId\u003e \u003cversion\u003e3.2.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e CglibDynamic public class CglibDynamic { public static void main(String[] args) { UserServiceImpl userService = new UserServiceImpl(); System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"/Users/feng/Desktop/dynamicProxy\"); UserService userServiceImpl = (UserService) Enhancer.create(UserServiceImpl.class, new InvocationHandler() { @Override public Object invoke(Object o, Method method, Object[] objects) throws Throwable { Object invoke = method.invoke(userService, args); System.out.println(\"Bye Bye\"); return invoke; } }); userServiceImpl.sayHello1(\"孙俪\"); } } cGlib 是采取继承的方式实现的 userService public interface UserService { public void sayHello(); public void sayHello1(String name); } userServiceImpl public class UserServiceImpl implements UserService { @Override public void sayHello() { System.out.println(\"hello\"); } @Override public void sayHello1(String name) { System.out.println(\"bye bye \" + name); } } ","date":"2021-06-24","objectID":"/posts/spring01/:0:3","tags":["spring"],"title":"Spring01","uri":"/posts/spring01/"},{"categories":["分享"],"content":"什么是PicGo? github ","date":"2021-06-09","objectID":"/posts/picgo/:0:1","tags":["picgo"],"title":"Picgo","uri":"/posts/picgo/"},{"categories":["分享"],"content":"如何安装PicGo? win exe 安装 choco 安装 choco install picgo scoop 安装 coop bucket add helbing https://github.com/helbing/scoop-bucket \u0026 scoop install picgo Linux arch yay -S picgo-appimage AppImage chomod a+x PicGo-2.3.0-beta.6.AppImage ./PicGo-2.3.0-beta.6.AppImage MacOS brew brew install picgo --cask ","date":"2021-06-09","objectID":"/posts/picgo/:0:2","tags":["picgo"],"title":"Picgo","uri":"/posts/picgo/"},{"categories":["分享"],"content":"PicGo + 阿里云oss?[option] 进入阿里云oss 创建一个bucket 填写信息 使用单独的用户来管理oss 添加权限 配置picgo ","date":"2021-06-09","objectID":"/posts/picgo/:0:3","tags":["picgo"],"title":"Picgo","uri":"/posts/picgo/"},{"categories":["分享"],"content":"PicGo + 自定义域名?[option] ","date":"2021-06-09","objectID":"/posts/picgo/:0:4","tags":["picgo"],"title":"Picgo","uri":"/posts/picgo/"},{"categories":["分享"],"content":"PicGo + typora?[option] typora.io ","date":"2021-06-09","objectID":"/posts/picgo/:0:5","tags":["picgo"],"title":"Picgo","uri":"/posts/picgo/"},{"categories":["分享"],"content":"PicGo + nvim?[option] coc-picgo coc neovim vim-plug install coc-picgo map config ","date":"2021-06-09","objectID":"/posts/picgo/:0:6","tags":["picgo"],"title":"Picgo","uri":"/posts/picgo/"},{"categories":["王道"],"content":"引入css有哪几种方式? 在 div 后写 style 写在 head 标签内， 用 style 包裹 导入外部文件，用link标签(可使用相对路径，也可使用绝对路径) ","date":"2021-05-17","objectID":"/posts/day39/:0:1","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"有哪些方式可以挑选选择器? 标签选择器 类选择器(在一个 html 页面上， 每一个标签的 class 可以有多个) ID选择器(在一个 html 页面上，每一个标签的 id 是唯一的) 层级复合选择器 属性选择器 ","date":"2021-05-17","objectID":"/posts/day39/:0:2","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"选择器的优先级是什么样的? 如何强制升到最高的优先级? 行内 \u003e ID \u003e 伪类|类 属性选择 \u003e 标签 \u003e 统配符 文件中 css 与导入的 css (优先级一样), 需要 满足就近原则 强制升到最高的优先级 当前位置所设置的属性为最高级 ","date":"2021-05-17","objectID":"/posts/day39/:0:3","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"什么是标准流(标准文档流, 文档流)? 在一个 HTML 页面中，页面会根据页面的(行和块)特性，会从上到下，从左到右按顺序排列 每一个 HTML 标签， 要在页面上占据空间 ","date":"2021-05-17","objectID":"/posts/day39/:0:4","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"盒子模型中盒子是怎么构成的? 元素内容 内边距 边框 外边距 ","date":"2021-05-17","objectID":"/posts/day39/:0:5","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"设置内边距的方式有哪些? 单独设置(不常见) 同时设置4边可不同值 同时设置4边(上下 左右) ","date":"2021-05-17","objectID":"/posts/day39/:0:6","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"如果使用 父类的内边距 来设置和用 子类的外边距 的设置都可以达到目的，推荐用什么达到目的? 不要用子类的外边距的设置 用父类的内边距来设置 ","date":"2021-05-17","objectID":"/posts/day39/:0:7","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"如何设置边框? 必须使用的参数 solid ","date":"2021-05-17","objectID":"/posts/day39/:0:8","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"如何设置外边距? ","date":"2021-05-17","objectID":"/posts/day39/:0:9","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"如何设置元素居中? ","date":"2021-05-17","objectID":"/posts/day39/:0:10","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"对html 元素通俗上设置的宽高属性，其实设置的是什么? 仅仅只是 元素内容部分的宽高 ","date":"2021-05-17","objectID":"/posts/day39/:0:11","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"设置的背景色, 其实设置的是什么? 背景色 = 元素内容 + 内边框 只有边框和元素内容有背景色 ","date":"2021-05-17","objectID":"/posts/day39/:0:12","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"块级元素， 行级元素， 行内块元素有什么区别? 元素类型 定义 特征 块级元素 display: block 在不设置宽度的情况下, 宽度是父级元素内容的宽度 在不设置高度的情况下, 高度是本身内容的高度 行级元素 display: inline 宽高是由 本身内容的大小决定 行内元素 display: inline-block 本质上是行级元素, 可以设置宽高，内外边距 ","date":"2021-05-17","objectID":"/posts/day39/:0:13","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"块级元素， 行级元素之间嵌套会出现什么特点? 有什么需要注意的? 块级与块级元素嵌套中， 它的父元素的 高度是不可以继承的，宽度是可以继承的 块级中 嵌套行级元素, 行级元素 高度和宽度 都不会继承 不要在行级元素中嵌套块级元素 块级元素是用来固定的， 行级元素是用来显示小图标的 ","date":"2021-05-17","objectID":"/posts/day39/:0:14","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"外边距合并是什么情况下发生的? 如果在垂直的方向上，两个元素的外边距紧相邻，就会产生一种现象，就会出现边距重叠 可以产生在(兄弟之间， 父子之间) ","date":"2021-05-17","objectID":"/posts/day39/:0:15","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"什么是浮动? 把一个 html 元素, 通过设置浮动属性，使这个 html 标签漂浮起来， 这样这个 html 标签就会被空出来， 那么下面元素为了符合标准文档流，就要占据它前面所有的空白 ","date":"2021-05-17","objectID":"/posts/day39/:0:16","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"什么是撑开与塌陷? 撑开 子元素占父元素的内容区域 塌陷 当子元素设置浮动而父元素的没有设置时，高度会塌陷为0 ","date":"2021-05-17","objectID":"/posts/day39/:0:17","tags":["java"],"title":"Day39","uri":"/posts/day39/"},{"categories":["王道"],"content":"为什么是出现 html? 当时是为了传论文 html 是谁的? html + css + js 都是W3C的 W3C (The World Wide web Consortium) 它是一个组织， 只提供一系列的草案，因此没有相关的文档 ","date":"2021-05-13","objectID":"/posts/day38/:0:1","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"为什么在不同的浏览器中执行相同的前端代码， 有些浏览器会走形, 并且错误的代码也可以输出? 因为为了在浏览器大战中获得胜利，各家的浏览器并没有完全遵循W3C的标准 同时各家的浏览器为了获得更多的市场，会包容错误代码 ","date":"2021-05-13","objectID":"/posts/day38/:0:2","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"前端, 网页, Html, Css, JavaScript, 它们之间是什么样的关系? 前端: 写页面 网页: 人 Html: 骨架 Css: 皮肤和血肉 Js(JavaScript): 思想逻辑 ","date":"2021-05-13","objectID":"/posts/day38/:0:3","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"什么是 Html ? 是一种语言 文本语言: 超文本 是一个以 .html 为后缀的文本 ‘超文本’ 包括文本字体, 图片, 链接， 甚至音乐，程序等元素代码的文本 是一个文本， 也是一个网页，该文本用浏览器打开， 文本里代码会进行解释执行 ","date":"2021-05-13","objectID":"/posts/day38/:0:4","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"html 的标准结构是什么样的? ","date":"2021-05-13","objectID":"/posts/day38/:0:5","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"html 重要的body标签 块级标签 行级标签 行内块标签 ","date":"2021-05-13","objectID":"/posts/day38/:0:6","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"\u003chr\u003e 标签是什么意思? 有什么需要注意的? \u003chr\u003e 是一个单标签 \u003chr\u003e \u003c/hr\u003e 是错误的 不要写成 \u003chr /\u003e \u003chr /\u003e 是 xhtml 的写法 xhtml 是用来增强 html 的样式功能，现在已经过时 ","date":"2021-05-13","objectID":"/posts/day38/:0:7","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"\u003cbr\u003e 标签是用来作什么的? \u003cbr\u003e 是用来换行的 对于一个 html 页面来说， 在代码中连续换行或者空格，在页面显示上仅仅会解析成一个空格 这里代表的是三个空格 ","date":"2021-05-13","objectID":"/posts/day38/:0:8","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"html 中可以使用 自定义的标签吗? html 中可以自定义标签， 但是自定义的标签不会有任何特殊效果 ","date":"2021-05-13","objectID":"/posts/day38/:0:9","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"\u003chn\u003e标签是用来干什么的?有什么需要注意的? \u003ch1\u003e - \u003ch6\u003e 只有6个标签, 它是成对标签 正文会比某些标签要大 在一个 html页面中， h1 标题仅能出现一次， h2-h6 可以出现多次 h1 除了显示以外， 还作为关键字 ","date":"2021-05-13","objectID":"/posts/day38/:0:10","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"div 标签是用来干什么的? 有什么需要注意的? ","date":"2021-05-13","objectID":"/posts/day38/:0:11","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"a 它的属性没法被替代 href = “xxxxx”, ","date":"2021-05-13","objectID":"/posts/day38/:0:12","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"p ","date":"2021-05-13","objectID":"/posts/day38/:0:13","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"img not alllow to load local source 非网络请求 EE: 动态资源 静态资源 ","date":"2021-05-13","objectID":"/posts/day38/:0:14","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"Input ","date":"2021-05-13","objectID":"/posts/day38/:0:15","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"物理像素与虚拟像素？ ","date":"2021-05-13","objectID":"/posts/day38/:0:16","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"页面加载流程(与服务器) ","date":"2021-05-13","objectID":"/posts/day38/:0:17","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"页面加载流程(本地服务器) ","date":"2021-05-13","objectID":"/posts/day38/:0:18","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"页面加载流程(本地服务器, 图片也在本地) ","date":"2021-05-13","objectID":"/posts/day38/:0:19","tags":["java"],"title":"Day38","uri":"/posts/day38/"},{"categories":["王道"],"content":"Shiro 权限验证框架 ","date":"2021-05-12","objectID":"/posts/day37/:0:0","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"什么是符号表(Map) 就是 Key-value数据 ","date":"2021-05-12","objectID":"/posts/day37/:0:1","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"互联网三要素: url 怎么找到某个资源，资源位置在哪里? http 描述资源在网络上的传输方式 html 描述论文 ","date":"2021-05-12","objectID":"/posts/day37/:0:2","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"怎么在互联网上唯一表示一台计算机 ip + 地址 ","date":"2021-05-12","objectID":"/posts/day37/:0:3","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"url 分类三大部分 ","date":"2021-05-12","objectID":"/posts/day37/:0:4","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"什么哈希表? ","date":"2021-05-12","objectID":"/posts/day37/:0:5","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"Hash函数具有的特点 ","date":"2021-05-12","objectID":"/posts/day37/:0:6","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"Hash算法不是加密算法 加密意味着解密 主流的 hash 算法: sha1（谷歌的两个程序员）, md5(王小云), 已经被证明不具有强抗碰撞性(先简单认为不安全) 碰撞性: ","date":"2021-05-12","objectID":"/posts/day37/:0:7","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"主流的 hash 函数 加盐： 盐值 账号: Admin 密码: 123 ","date":"2021-05-12","objectID":"/posts/day37/:0:8","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"理论上的 hash 冲突如何解决? 线性探测法 平方探测法 再散列法 ","date":"2021-05-12","objectID":"/posts/day37/:0:9","tags":["java"],"title":"Day37","uri":"/posts/day37/"},{"categories":["王道"],"content":"set 特点 Set 接口是 Collection 的子接口 描述的是集合这种数据结构 它的一些自实现是有序的(LinkedHashSet, TreeSet) 有些子实现是无序的(HashSet) 有些子实现允许存储null(LinkedHashSet, HashSet), 有些子实现不允许存储 null(TreeSet) 都是不允许重复元素 ","date":"2021-05-11","objectID":"/posts/day36/:0:1","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"set Api 初始化 collection 是 add 方法, map 是 poll 方法 addAll clear containsAll iterator() map 不能使用增强for循环, 可以用interset, set 可以使用增强for循环 ","date":"2021-05-11","objectID":"/posts/day36/:0:2","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"HashSet特点 HashSet 是 Set 接口一个具体子实现 HashSet 的底层持有一个 HashMap 对象, HashMap 的底层是一个数组 + 链表 + 红黑树结构, 所以存储到 HashSet 中的元素， 实际上都存储到 HashSet 所持有 HashMap 中作为 Key 存在 由于它的底层持有的是 HashMap 对象，所以无序 不允许存储重复元素： 存储的元素 hash 值一样，并且两个元素直接相等或者相 equals. 允许存储 nul 元素 它的其它特点遵从于 HashMap, 因为底层持有的是一个 HashMap 对象，负责存储数据 ","date":"2021-05-11","objectID":"/posts/day36/:0:3","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"HashSet 的构造方法 ","date":"2021-05-11","objectID":"/posts/day36/:0:4","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"HashSet API(方法上基本上和Collection没什么差别) ","date":"2021-05-11","objectID":"/posts/day36/:0:5","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"LinkedHashSet 特点 LinkedHashSet 是 HashSet 的一个子类(LinkedHashSet 复用HashSet方法) LinkedHashSet 底层持有一个 LinkedHashMap 对象， 它是在 hashMap结构（数组 + 链表 + 红黑树）上的增强， 多维护了一个双向链表 LinkedHashSet 存储的元素是有序的(通过底层的双向链表保证有序) LinkedHashSet 不允许存储重复的元素 LinkedHashSet 允许存储null 其它特点遵照于 HashSet -\u003e HashMap ","date":"2021-05-11","objectID":"/posts/day36/:0:6","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"LinkedHashSet 构造方法 ","date":"2021-05-11","objectID":"/posts/day36/:0:7","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"TreeSet 的特点 TreeSet 是 Set 接口一个子类，描述的数据结构 是一个红黑树 TreeSet 底层持有一个 TreeMap 对象， 这个TreeMap 对象的底层是红黑树 大小有序 不允许存储重复元素(比较大小的重复) 不允许存储 null, 因为 null 没有办法比较大小 线程不安全 若同时实现comparable + comparator ， 会使用comparator 的比较方法 ","date":"2021-05-11","objectID":"/posts/day36/:0:8","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"TreeSet 构造方法 TreeSet 实现比较器 ","date":"2021-05-11","objectID":"/posts/day36/:0:9","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"Api ceiling descendingIterator descendingset first() floor(E e) headset last lower subSet ","date":"2021-05-11","objectID":"/posts/day36/:0:10","tags":["java"],"title":"Day36","uri":"/posts/day36/"},{"categories":["王道"],"content":"day35_linkedHashMap ","date":"2021-05-11","objectID":"/posts/day35/:0:0","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"LinkedHashMap的特点 LinkedHashMap 是 HashMap 一个子类 LinkedHashMap 基本上完全复用了 HashMap 的底层结构， 参数，方法 LinkedHashMap的特点基本遵从于 HashMap LinkedHashMap 底层在 HashMap 的基础上(数组 + 链表 + 红黑树) 额外维护了一个双向链表: 这个双向链表用来记录存储 ","date":"2021-05-11","objectID":"/posts/day35/:0:1","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"LinkedHashMap 如何额外维护一个双向链表? ","date":"2021-05-11","objectID":"/posts/day35/:0:2","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"构造方法? 默认的构造方法 accessOrder(如果我们给accessOrder 设置为真，那么我们如果访问了这个LinkedHashMap中的某一个Key-value数据，那么这份Key-value数据就会在双向链表中的位置移到最后， 它在红黑树上的位置不变) ","date":"2021-05-11","objectID":"/posts/day35/:0:3","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"API ","date":"2021-05-11","objectID":"/posts/day35/:0:4","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"TreeMap 有什么特点? TreeMap 是 Map 一个子实现 描述数据结构是树/二叉搜索树/红黑树 底层是链表 TreeMap 大小有序(中序遍历是有序的) 不允许重复的 key 不允许null键 线程不安全 Treemap 的重复的定义: 大小比较结果是0, 自然顺序/比较器 如果我们希望在TreeMap中存储数据 ，key-value, 我们可以有两个选择： 让key本身可以比较(继承Comparabe接口实现 compareTo 方法)（但会让代码看一起来不清爽） 不想让 key 本身实现 Comparable 接口实现, 手动用比较器实现 public class DemoTreeMap { public static void main(String[] args) { TreeMap\u003cUser3, Integer\u003e map = new TreeMap\u003c\u003e(); map.put(new User3(\"zs\", 18), 1); map.put(new User3(\"ls\", 18), 1); } } class User3 { private String name; private int age; public User3(String name, int age) { this.name = name; this.age = age; } } 因为TreeMap的底层是一个红黑树, 其结点需要实现比较 比较器实现（new Comparator） public class DemoTreeMap { public static void main(String[] args) { TreeMap\u003cUser3, Integer\u003e map = new TreeMap\u003c\u003e(new Comparator\u003cUser3\u003e() { @Override public int compare(User3 o1, User3 o2) { int com = o1.getName().compareTo(o2.getName()); com = com == 0 ? o1.getAge() - o2.getAge() : com; return com; } }); map.put(new User3(\"zs\", 18), 1); map.put(new User3(\"ls\", 18), 1); System.out.println(map); } } class User3 { private String name; private int age; public User3(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } } TreeMap(Map \u003c? extends K, ? extends V\u003e m) TreeMap(SortedMap\u003ck, ? extends V\u003em) ","date":"2021-05-11","objectID":"/posts/day35/:0:5","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"API Map.Entry\u003cK,V\u003e ceilingEntry(K key) 返回一个大于等于指定key的一份key-value数据 K ceilingKey(K key) 返回大于等于key的指定key的key Comparator\u003c? super K\u003e comparator() 获得这个treeMap()的比较器 复用比较器 containsKey and containsValue descendingKeySet() 键的逆序 descendingMap() 返回逆序视图 entrySet （获得所有key-value数据） firstEntry(): 返回最小的键值对, (大小根据自然顺序或比较器自己定义的) firstKey() floorEntry(K key): 返回一个小于等于给定key的一个键值对 K floorKey(K key) 返回小于等于给定键的最大值 get headMap(k tokey): 不包含等于 headMap(K tokey) 包含等于 higerEntry higherkey Set keySet() 返回键集 collection values() lastEntry() 20.lastKey() lowerEntry(K key) nabigableKeySet() 返回键集 23.pollFirstEntry 24.subMap(左闭右开), 可传布尔值 tailMap ","date":"2021-05-11","objectID":"/posts/day35/:0:6","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"Hashtable 与 HashMap 有什么区别? 产生 Hashtable 是1.0产生的 HashMap 是1.2产生的 线程安全问题: HashMap 线程不安全 HashTable 线程安全 底层结构 HashMap 底层是数组 + 链表 + 红黑树(jdk1.8) Hashtable 底层是数组+ 链表 -\u003e 和jdk1.8之前的 hashmap 是一样的 数组默认初始容量以及扩容机制 HashMap： 默认初始是16， 扩容机制是2倍 HashTable: 默认初始是11， 扩容机制(2倍+1) Hash值, 散列 HashMap: (h=key.hashCode) ^ (h »\u003e 16) hash \u0026 (length - 1) HashTable: int hash = key.hashCode(); int index = (hash \u0026 0x7FFFFFFF) % tab.length; 能不能存储 null HashMap: 可以存储 null 以及 null 值 Hashtable: 不可以存储 null 键 也不可以存储 null 值 ","date":"2021-05-11","objectID":"/posts/day35/:0:7","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"HashMap 与 ConcurrentHashMap 区别? ","date":"2021-05-11","objectID":"/posts/day35/:0:8","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"Propertories ? Propertories 是 Hashtable 的一个子类， 持久化: 代码在运行的过程中(内存), 有可能产生一些数据 ，这个数据有时候我们希望立马存在本地磁盘文件上. 如果在使用 Properities 时候， 不要使用从 Hashtable 那继承来的方法，为啥? 因为持久化的时候要求数据 key-value都必须字符串 ","date":"2021-05-11","objectID":"/posts/day35/:0:9","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"两种文件格式? xml Properties json 数据是当下时代不同端数据交互的一个普遍格式 90% 上一个时代(5年之前), 数据交互格式 xml 格式还是比较多 现在 xml 格式经常用于配置文件 ","date":"2021-05-11","objectID":"/posts/day35/:0:10","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"类的分类? 工具类: utils 类 Bean 类: 与现实的东西相对应 ","date":"2021-05-11","objectID":"/posts/day35/:0:11","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"什么是解耦? 把一些强相关性的东西拆开，变成弱相关的东西. ","date":"2021-05-11","objectID":"/posts/day35/:0:12","tags":["java"],"title":"Day35","uri":"/posts/day35/"},{"categories":["王道"],"content":"套壳 ","date":"2021-05-10","objectID":"/posts/day34/:0:1","tags":["java"],"title":"Day34","uri":"/posts/day34/"},{"categories":["王道"],"content":"Java 集合体系是什么样的? 两个 Collection 集合体系 Map 集合体系 都是 Object 的子类 ","date":"2021-05-10","objectID":"/posts/day34/:0:2","tags":["java"],"title":"Day34","uri":"/posts/day34/"},{"categories":["王道"],"content":"Map 特点 Map 接口是Map 集合体系的顶级接口 和 Collection 接口以及 Collection 下面子实现不同的是, Map 所存储的数据不再是单个数据的，而是 Key-value 的数据(键值对) Map 的子实现有些是有序的，有些是无序的 Map 的子实现不允许存储重复key(重复元素的定义不同) Map 有些子实现可以存储 null, 有些子实现不允许存储 null (指key值) ","date":"2021-05-10","objectID":"/posts/day34/:0:3","tags":["java"],"title":"Day34","uri":"/posts/day34/"},{"categories":["王道"],"content":"Map 的 Api? put public class TestMap { public static void main(String[] args) { HashMap map = new HashMap\u003cString, Integer\u003e(2); // put map.put(\"zs\", 18); map.put(\"ls\", 20); map.put(\"wu\", 20); map.put(\"zl\", 22); System.out.println(map); } } clear public class TestMap { public static void main(String[] args) { HashMap map = new HashMap\u003cString, Integer\u003e(2); // put map.put(\"zs\", 18); map.put(\"ls\", 20); map.put(\"wu\", 20); map.put(\"zl\", 22); System.out.println(map); // clear map.clear(); System.out.println(map); } } containsKey 是否包含指定的key值 public class TestMap { public static void main(String[] args) { HashMap map = new HashMap\u003cString, Integer\u003e(2); // put map.put(\"zs\", 18); map.put(\"ls\", 20); map.put(\"wu\", 20); map.put(\"zl\", 22); System.out.println(map); System.out.println(map.containsKey(\"zs\")); } } containsValue 是否包含指定的value public class TestMap { public static void main(String[] args) { HashMap map = new HashMap\u003cString, Integer\u003e(2); // put map.put(\"zs\", 18); map.put(\"ls\", 20); map.put(\"wu\", 20); map.put(\"zl\", 22); System.out.println(map); System.out.println(map.containsValue(23)); } } equals public class TestMap { public static void main(String[] args) { HashMap map = new HashMap\u003cString, Integer\u003e(2); HashMap map1 = new HashMap\u003cString, Integer\u003e(2); // put map.put(\"zs\", 18); map.put(\"ls\", 20); map1.put(\"zs\", 18); map1.put(\"ls\", 20); System.out.println(map); System.out.println(map1); System.out.println(map.equals(map1)); } } get(object key) public class TestMap { public static void main(String[] args) { HashMap map = new HashMap\u003cString, Integer\u003e(2); // put map.put(\"zs\", 18); map.put(\"ls\", 20); System.out.println(map.get(\"zs\")); } } putAll public class TestMap { public static void main(String[] args) { HashMap map = new HashMap\u003cString, Integer\u003e(2); HashMap map1 = new HashMap\u003cString, Integer\u003e(2); //put map.put(\"zs\", 18); map.put(\"ls\", 20); // putAll map1.putAll(map); System.out.println(map); System.out.println(map1); } } remove(Object key) 根据key键值，删除keyvalue数据 public class TestMap { public static void main(String[] args) { HashMap map = new HashMap\u003cString, Integer\u003e(2); //put map.put(\"zs\", 18); map.put(\"ls\", 20); //remove map.remove(\"zs\"); System.out.println(map); } } Collection values() 返回这个map的值集 set keySet() 返回这个map对象的键集 ** set\u003cMap.Entry\u003cK,V» entrySet ** 返回 这个 map 的键值对 ","date":"2021-05-10","objectID":"/posts/day34/:0:4","tags":["java"],"title":"Day34","uri":"/posts/day34/"},{"categories":["王道"],"content":"HashMap HashMap 是 Map 接口的子实现 (存储的是 key - value 数据) HashMap 表示一个 Hash 表 HashMap 的底层结构， 数组+ 链表+红黑树(jdk1.8 之前就是存粹的数组+链表) 4.HashMap 的效率非常高: 存储/查找 5.数组的默认初始容量 16, 数组的扩容机制 2 倍 HashMap 存储的Key-value 数据 ，经过散列之后 是无序的 HashMap 不允许存储重复元素key：（重复的定义） 允许存储 null 值 (key-value 都允许为null) 线程不安全 HashMap 加载因子默认是0.75, 尽量加载因子在0.5 ~ 1之间 一个 HashMap 底层数组的扩容阈值 = 数组长度 * 加载因子 hash 值的计算 (h = key.hashCode()) ^(h »\u003e 16) 由于我们 HashMap 在做根据 hash 值 取 HashMap 的底层数组，是一个Node类型的数组，这个Node类型包含四个参数，分别是hash值 ，key, value, next 我们最终存储到 HashMap 中的是一个结点类型, 这个结点类型包含四个 HashMap 的重复的定义， 首先 hash 值是否一样， hash 一样的情况下，两个key是否直接相等 如果存储的数据key已经存在(key)重复了，那么会用新的value值覆盖旧value值 如果我们把一份数据 key-value (已经存储到 HashMap中) 中的 Key通过引用修改，也就意味着一份key-value数据， 一旦存储到 hashmap 中就不要通过引用修改 key 了. 当链表长度超过8， 达到9的时候(算上新添加的元素)， 会由链表转化为红黑树 当链表长度超过8，达到9的时候(算上新添加的元素)， 如果同时数组长度小于64的时候，会有限选择扩容，而非转化为红黑树(注意: 如果扩容的时候，原本存在于x位置的元素，可能依旧存储在x, 还有可能存储到旧长度 + x的位置) 如果链表转化为红黑树，红黑树是一个特殊的二叉搜索树，需要比较大小， 在Hashmap中红黑树比较大小的方式是 hash如何计算. 19.删除有可能导致红黑色树转化为链表 扩容也可能导致红黑树转化为, 扩容有可能导致红黑树拆成两部分 扩容有可能导致红黑树拆成两部分，在这两部分中，任意部分，如果元素数量小于等于6的话，会由红黑树转化成链表 HashMap 的存储思想? 什么时候链表会转化成红黑树? 当链表超过8,达到9的时候(算上新添加的上的元素), 会由链表转化为红黑树 ","date":"2021-05-10","objectID":"/posts/day34/:0:5","tags":["java"],"title":"Day34","uri":"/posts/day34/"},{"categories":["王道"],"content":"红黑树变成链表? 存储相同的值 两次存储的\"zs\" 值 一样， 因为他们两个hashCode值 都一样 如果有两个元素hash值 一样，并不能完全保证他们两个一样 两个zs没法存 首先判断: 已经存储到table 数组中里的i位置的元素p, 他key的hash值和新存储 两份key-value数据的key是否相等， 或者相equals 重写 hashCode 删除已经改变的位置 红黑树不是自平衡的二叉树 数据结构， 底层结构, 实现 Key-value 数据常见: key-value 数据非常常见 Key-value 数据具有自我描述性, 完全可以描述对象 json key-value ","date":"2021-05-10","objectID":"/posts/day34/:0:6","tags":["java"],"title":"Day34","uri":"/posts/day34/"},{"categories":["王道"],"content":"Queue接口的特点 Queue 接口是 Collection 接口的一个子接口中 Queue 代表/ 描述的是队列(什么是队列: 一个操作受到限制的线性表, 在添加的时候只能在一端添加，删除是在另一端删除 -\u003e 先进先出，后进后出) 有序 能存储重复元素 不能存储null (poll) 方法， 如果没有元素可以删除,null返回， 如果允许null存储，poll方法就没办法分辨返回的null是没有元素可删除的标记，还是原本存储的null, 因些不让存null ","date":"2021-05-08","objectID":"/posts/day33/:0:1","tags":["java"],"title":"Day33","uri":"/posts/day33/"},{"categories":["王道"],"content":"API ","date":"2021-05-08","objectID":"/posts/day33/:0:2","tags":["java"],"title":"Day33","uri":"/posts/day33/"},{"categories":["王道"],"content":"Deque 接口 Deque 接口是Queue接口的一个子接口 Deque 在Queue接口上进行了扩展: 不仅仅可以作为普通队列，还定义了双端队列，栈 有序 允许重复 不能存储 null(LinkedList) 除外 ","date":"2021-05-08","objectID":"/posts/day33/:0:3","tags":["java"],"title":"Day33","uri":"/posts/day33/"},{"categories":["王道"],"content":"ArrayDeque 特点 ArrayDeque 是 Deque(双端队列)的一个子实现 可以作为 普通队列/ 双端队列/ 栈 底层数组(循环数组) 默认的初始容量16， 扩容机制(扩充2倍) 方便取余运算 如果不大于8， 直接创建一个为8的数组 有序 允许重复 不允许存储null 线程不安全 我们可以在构造方法里指定底层数组长度，但是给定的数组长度并不真的是我们给定的值 ，而是一个大于我们给定值 的最小2的幂值 -\u003e 底层数组的长度永远是2的幂值 取模运算 构造方法 BlockingQueue 是接口 public class DemoBlockingQueue { public static void main(String[] args) { ArrayBlockingQueue\u003cString\u003e queue = new ArrayBlockingQueue\u003cString\u003e(2); queue.offer(\"zs\"); queue.offer(\"ls\"); System.out.println(queue); } } 阻塞队列无法实现扩容 BlockingQueue 方法以四种形式出现， 对于不能立即满足但可能在将来某一时刻可以满足的操作: 这四种形式的处理方式不同: 第一种是抛出异常， 第二种是返回一个特殊值 (null 或 false, 具体取决于操作), 第三种是在操作可以成功前，无限期阻塞当前线程 第四种是在放弃前只在给定的最大时间限制内阻塞 什么是阻塞队列? 首先是一个队列， 添加的时候如果没有位置，添加操作等待，如果在删除的时候，队列中没有数据可以删除，删除操作等待 超时等待? public class DemoBlockingQueue { public static void main(String[] args) throws InterruptedException { ArrayBlockingQueue\u003cString\u003e queue = new ArrayBlockingQueue\u003cString\u003e(2); queue.offer(\"zs\"); queue.offer(\"ls\"); queue.offer(\"wu\", 10, TimeUnit.SECONDS); System.out.println(queue); } } wu并没有加进去，因为此时queue已经满了 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e, time, unit) 移除 remove(e) poll() take() poll(time, unit) 检查 element() peek() 不可用 不可用 public class DemoBlockingQueue { public static void main(String[] args) throws InterruptedException { ArrayBlockingQueue\u003cString\u003e queue = new ArrayBlockingQueue\u003cString\u003e(2); queue.offer(\"zs\"); queue.offer(\"ls\"); // 启动另外的一个线程, 来对这个阻塞队列做删除 MyThead myThead = new MyThead(); myThead.start(); queue.take(); System.out.println(queue); } } class MyThead extends Thread { @Override public void run() { } } public class DemoBlockingQueue { public static void main(String[] args) throws InterruptedException { ArrayBlockingQueue\u003cString\u003e queue = new ArrayBlockingQueue\u003cString\u003e(2); queue.offer(\"zs\"); queue.offer(\"ls\"); // 启动另外的一个线程, 来对这个阻塞队列做删除 MyThead myThead = new MyThead(); myThead.start(); queue.put(\"uu\"); System.out.println(queue); } } class MyThead extends Thread { @Override public void run() { } } 多线程 take + 多线程 超时 + 多线程 在7秒内只要有位置就会被唤醒，然后添加 ","date":"2021-05-08","objectID":"/posts/day33/:0:4","tags":["java"],"title":"Day33","uri":"/posts/day33/"},{"categories":["王道"],"content":"ArrayList的特点? ArrayList 是 List 接口的一个具体实现(线性表) 底层是一个数组 数组的默认长度(10)， 数组的扩容机制(1.5倍) 有序 允许重复元素 允许null 线程不安全 在默认的创建 ArrayList 对象的时候，如果不添加，那么构造方法并没有真正创建一个长度为10的数组，而是构建空数组 但是面试的时候，首先你要说的就是默认长度为10 ","date":"2021-05-08","objectID":"/posts/day32/:0:1","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"ArrayList 实战 public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zs\"); list.add(null); System.out.println(list); } } ","date":"2021-05-08","objectID":"/posts/day32/:0:2","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"构造方法 指定集合 ","date":"2021-05-08","objectID":"/posts/day32/:0:3","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"API add arraycopy方法 addAll(Collection\u003c? extends E\u003e) E get(int index) lastIndexOf set(int index, E element) void trimToSize() 效果就是把多余的数组位置(没存任何内容的) 不要了, void ensureCapacity(int minCapacity) 变成一个大于或等于给定长度的一个数组，如有必要，增加此 ArrayList 实例的容量 list.ensureCapacity(2); clone() clone 浅表层复制 可选操作 可以不实现， 写成空方法即可 抛出异常 get 遍历 iterator遍历 Arraylist源码分析 sublist源代码分析 不可以转换, 不是同一类型 并发修改异常 ","date":"2021-05-08","objectID":"/posts/day32/:0:4","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"Vector 和 ArrayList 的区别? ","date":"2021-05-08","objectID":"/posts/day32/:0:5","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"Vector 的特点? Vector 是 List 的一个具体实现，代表是一个线性表 Vector 底层是一个数组 默认的初始容量 10, 扩容机制 (取决于我们在构造方法有没有给这个 Vector 一个大于0 的增量，如果了一个大于0的增量，扩容扩为旧长度+增量, 如果没有给一个的增量，扩为原来的二倍) 有序 允许重复 允许null 线程安全 ","date":"2021-05-08","objectID":"/posts/day32/:0:6","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"大多集合类都是 jdk1.2 时候就存在了， 但 vector 是 jdk1.0 开始的 ","date":"2021-05-08","objectID":"/posts/day32/:0:7","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"Vector 会在构造方法里就产生一个底层长度为 10 的数组 (ArrayList) 是第一次添加时产生的 ","date":"2021-05-08","objectID":"/posts/day32/:0:8","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"Stack的特点 Stack 是 Vector 的一个子类, （v-l-c） Stack 的底层是个数组(复用父类Vector 的数组) 默认长度:10， 默认扩容: 2倍（默认调用父类的无参的构造方法） 表示一个栈 可以存储null 和重复元素 线程安全 如何我们要在具体的逻辑中使用一个栈的话，优先使用 deque 如果我们使用Stack时候，不要直接使用从vector继承的方法(不是语法不允许)， 我们只是希望stack作为一个栈存在(push , pop , peek) ","date":"2021-05-08","objectID":"/posts/day32/:0:9","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"Stack 实战? ","date":"2021-05-08","objectID":"/posts/day32/:0:10","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"Stack 与 Deque ","date":"2021-05-08","objectID":"/posts/day32/:0:11","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"LinkedList ","date":"2021-05-08","objectID":"/posts/day32/:0:12","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"LinkedList 特点 LinkedList 是 list的接口的一个子实现， 还是 Deque 接口的子实现 底层结构是一个双向链表 有序 允许null 允许重复 线程不安全 LinkedList 不仅仅可以作为一个线性表，还可以作为一个普通队列/ 双端队列/栈使用. ","date":"2021-05-08","objectID":"/posts/day32/:0:13","tags":["java"],"title":"Day32","uri":"/posts/day32/"},{"categories":["王道"],"content":"List的特点 List 的是 Collection 的子接口 List 是 Collection 的一个 线性表 子接口 -\u003e (有序, 有下标操作) 有序 允许重复元素存在 允许 null ","date":"2021-05-07","objectID":"/posts/day31/:0:1","tags":["java"],"title":"Day31","uri":"/posts/day31/"},{"categories":["王道"],"content":"API? add public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zl\"); System.out.println(list); } } addAll public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zl\"); ArrayList\u003cString\u003e list1 = new ArrayList\u003c\u003e(); list1.add(\"zs\"); list1.add(\"ls\"); list1.add(\"wu\"); list1.add(\"zl\"); System.out.println(list.addAll(list1)); System.out.println(list); } } add(index) public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zl\"); ArrayList\u003cString\u003e list1 = new ArrayList\u003c\u003e(); list1.add(\"1\"); list1.add(\"2\"); list1.add(\"3\"); list1.add(\"4\"); System.out.println(list.addAll(1, list1)); System.out.println(list); } } get public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zl\"); System.out.println(list.get(0)); } } indexOf public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zl\"); System.out.println(list.indexOf(\"zs\")); } } lastIndexOf public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zs\"); list.add(\"ls\"); System.out.println(list.lastIndexOf(\"zs\")); } } remove public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zs\"); list.add(\"ls\"); System.out.println(list.remove(0)); System.out.println(list); } } toArray() public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zs\"); list.add(\"ls\"); Object[] objects = list.toArray(); for (int i = 0; i \u003c objects.length; i++) { System.out.println(objects[i]); } } } iterator public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zs\"); list.add(\"ls\"); Iterator\u003cString\u003e iterator = list.iterator(); while(iterator.hasNext()){ System.out.println(iterator.next()); } } } listIterator public class TestLink { public static void main(String[] args) { ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e(); list.add(\"zs\"); list.add(\"ls\"); list.add(\"wu\"); list.add(\"zs\"); list.add(\"ls\"); ListIterator\u003cString\u003e iterator = list.listIterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); } } } ","date":"2021-05-07","objectID":"/posts/day31/:0:2","tags":["java"],"title":"Day31","uri":"/posts/day31/"},{"categories":["王道"],"content":"ListIterator public interface ListIterator extends Iterator 他是个接口， 他是 Iterator 的子接口 ListIterator , 在 Iterator 的基础上，提供了向前遍历的接口 逆序遍历 sublist 是一个视图方法, 只是维护了标记 ","date":"2021-05-07","objectID":"/posts/day31/:0:3","tags":["java"],"title":"Day31","uri":"/posts/day31/"},{"categories":["王道"],"content":"什么是视图方法（sublist）? a view of the portion 虚表(视图): 虚拟表，维护一个标记表(手机)， 指向一个实际存储数据的表 集合类的视图方法，实际上还是原集合类的数据，视图方法返回的对像实际上持有的仅仅是 ","date":"2021-05-07","objectID":"/posts/day31/:0:4","tags":["java"],"title":"Day31","uri":"/posts/day31/"},{"categories":["王道"],"content":"一个接口与接口的关系? 一个接口是另一个接口的增强 ","date":"2021-05-07","objectID":"/posts/day31/:0:5","tags":["java"],"title":"Day31","uri":"/posts/day31/"},{"categories":["王道"],"content":"一个子类与子类的关系? 一个子类是想实现另一个子类 ","date":"2021-05-07","objectID":"/posts/day31/:0:6","tags":["java"],"title":"Day31","uri":"/posts/day31/"},{"categories":["王道"],"content":"集合类的分类? Collection List (线性表子接口) ArrayList: 1 LinkedList: 2 Vector -\u003e Stack Queue (队列子接口) Deque BlockingQueue Set (集合子接口) HashSet: 2 LinkedHashSet: 3 TreeSet:　3 Map (Key-value) HashMap: 1 LinkedHashMap： 3 TreeMap： 3 ","date":"2021-05-06","objectID":"/posts/day30/:0:1","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"如何解释一个集合类（HashMap）的特点, 要解释那些东西? 这个集合类是谁的子类/接口 这个集合类表示是的是一种什么数据结构 这个集合类他的底层结构是什么(数组，链表，数组+链表) 如果底层结构是数组，谈数组的默认初始容量，数组的扩容机制 这个集合类是否有序(位序) 有序: 添加的位置是不是可以预期的 这个集合类是否允许存储重复元素(二叉搜索树不允许有重复元素) 这个集合类是否允许存储null 这个集合类是否线程安全 ","date":"2021-05-06","objectID":"/posts/day30/:0:2","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"为什么需要集合类？ 很多情况下，我们需要对一组对象进行操作 很可能事先并不知道到底有多少对象 为了解决这个问题，java 就提供了集合类供我们使用 ","date":"2021-05-06","objectID":"/posts/day30/:0:3","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"集合类有什么特点? a. 只能存储引用数据类型: (集合类是个数据容器, 用了泛型，泛型只能是引用类型) b. 可以自动地调整自己的大小: (实现了扩容机制) ","date":"2021-05-06","objectID":"/posts/day30/:0:4","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"数组和集合类都是容器，它们有什么不同? a. 数组可以存储基本数据类型，集合不可以 b. 数组的长度是固定的，集合可以自动调整自己的大小 c. 数组的效率高，相对来说集合效率比较低 d. 数组没有API, 集合有丰富的API ","date":"2021-05-06","objectID":"/posts/day30/:0:5","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"什么是逻辑结构和物理结构? 逻辑结构 : 描述数据元素间的逻辑关系 物理结构: 存储结构或者映像 顺序映像: 借助的是存储器中的相对位置来表示数据元素之间的逻辑关系 非顺序映像: 借助元素存储地址的\"指针\"， 来表示数据元素的逻辑关系 ","date":"2021-05-06","objectID":"/posts/day30/:0:6","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"Collection 有什么特点? Collection 是 Collection 集合体系的顶级接口 一些 collection 的子实现是有序的，而另一些 collection 的子实现则是无序的 一些 collection 的子实现是允许存储重复元素的，而另一些 collection 的子实现则是不允许存储重复元素的(==, 地址，compareble 自然排序) 一些 Collection 的子实现是允许存储 null, 而另一些 Collection 的子实现是不允许存储null ","date":"2021-05-06","objectID":"/posts/day30/:0:7","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"Collection 中有哪些API? add public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); System.out.println(collection); } } size public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); System.out.println(collection); System.out.println(collection.size()); } } addAll public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); LinkedList\u003cString\u003e collection1 = new LinkedList\u003c\u003e(); collection1.add(\"ww\"); collection1.addAll(collection); System.out.println(collection); System.out.println(collection1); } } clear public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); System.out.println(collection); collection.clear(); System.out.println(collection); System.out.println(collection.isEmpty()); } } contains public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); System.out.println(collection.contains(\"ls\")); } } containsAll public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); ArrayList\u003cString\u003e collection1 = new ArrayList\u003c\u003e(); collection1.add(\"zs\"); collection1.add(\"ls\"); System.out.println(collection.containsAll(collection1)); } } remove public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection1 = new ArrayList\u003c\u003e(); collection1.add(\"zs\"); collection1.add(\"ls\"); System.out.println(collection1); collection1.remove(\"zs\"); System.out.println(collection1); } } removeAll public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); ArrayList\u003cString\u003e collection1 = new ArrayList\u003c\u003e(); collection1.add(\"zs\"); collection1.add(\"ls\"); collection.removeAll(collection1); System.out.println(collection); } } retainAll public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); ArrayList\u003cString\u003e collection1 = new ArrayList\u003c\u003e(); collection1.add(\"zs\"); collection1.add(\"ls\"); collection.retainAll(collection1); System.out.println(collection); } } toArray 不常用 返回一个数组： 包含所有Collection集合类的元素 public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); Object[] objects = collection.toArray(); for (int i = 0; i \u003c objects.length; i++) { System.out.println(objects[i]); } } } T[] toArray(T[] a) public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); Object[] strs = new Object[10]; strs[0] = 1; strs[1] = 1; strs[2] = 1; strs[3] = 1; strs[4] = 1; strs[5] = 1; strs[6] = 1; strs[7] = 1; strs[8] = 1; strs[9] = 1; System.out.println(\"toArray前:\"); for (int i = 0; i \u003c strs.length; i++) { System.out.println(strs[i]); } System.out.println(\"toArray后:\"); Object[] strings = collection.toArray(strs); for (int i = 0; i \u003c strings.length; i++) { System.out.println(strin","date":"2021-05-06","objectID":"/posts/day30/:0:8","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"Iterator public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); Iterator\u003cString\u003e iterator = collection.iterator(); System.out.println(\"后面是否还有元素可以遍历? \" + iterator.hasNext()); System.out.println(\"输出遍历的结果\" + iterator.next()); System.out.println(\"输出遍历的结果\" + iterator.next()); iterator.remove(); System.out.println(collection); } } 谈理论的时候，我们认为的遍历的位置指向，是在两个元素之间 遍历的起始位置是在第一个元素之前 在遍历之前是不可以删除的，因为remove删除的是刚刚遍历过的元素(删除不能连续进行，刚刚遍历的元素只有一个) 为什么Iterator是个接口?  Iterator\u003cString\u003e iterator = collection.iterator(); 返回的对象， 是 Iterator 的子实现，并且是具体collection 子类的内部类(内部类比较适合访问 collection 子类 的数据) ","date":"2021-05-06","objectID":"/posts/day30/:0:9","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"Foreach 循环 增强 for 循环， 加强的 for 循环 对于 Collection 集合类，虽然它提供了 Iterator 方法用来遍历，性能优于 toArray 的 但是在实际工作中没有人使用iterator 迭代，通常都是使用 Foreach循环 ","date":"2021-05-06","objectID":"/posts/day30/:0:10","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"ConcurrentModificationException 并发修改异常 颗粒度比较细 Iterator 迭代就是依赖于源数据进行的，我们希望在我们迭代的过程中别人不要来修改这个源集合数据，如果非要修改的，让我自己来修改 在多线程的情况下，一个线程在用 iterator 遍历， 另一个在修改，由于原集合类或标记 modCount 这个参数(修改次数) 会增加，会导致在 iterator 迭代的时候如下不相等 在单线程情况下，如果 interator 对象已经产生：意味着如下参数已经同步 public class TestCollection { public static void main(String[] args) { ArrayList\u003cString\u003e collection = new ArrayList\u003c\u003e(); collection.add(\"zs\"); collection.add(\"ls\"); collection.add(\"wu\"); collection.add(\"zl\"); for(String s : collection){ collection.add(\"lb\"); } } } 意味着增强的 for 循环在便利的过程中，也不能调用原集合类的方法修改 对于数组（数组在 java 中是一个非常特殊的存在，）也可以使用 Foreach 循环， 但是它和iterator 迭代没有任何关系，数组的增强的for循环会编译成普通的fori循环 ","date":"2021-05-06","objectID":"/posts/day30/:0:11","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"接口存在有什么意义? 实现多继承 提供 规范 和 约束 ","date":"2021-05-06","objectID":"/posts/day30/:0:12","tags":["java"],"title":"Day30","uri":"/posts/day30/"},{"categories":["王道"],"content":"集合类的分类? Collection List (线性表子接口) ArrayList: 1 LinkedList: 2 Vector -\u003e Stack Queue (队列子接口) Deque BlockingQueue Set (集合子接口) HashSet: 2 LinkedHashSet: 3 TreeSet:　3 Map (Key-value) HashMap: 1 LinkedHashMap： 3 TreeMap： 3 ","date":"2021-05-05","objectID":"/posts/day29/:0:1","tags":["java"],"title":"Day29","uri":"/posts/day29/"},{"categories":["王道"],"content":"如何解释一个集合类（HashMap）的特点, 要解释那些东西? 这个集合类是谁的子类/接口 这个集合类表示是的是一种什么数据结构 这个集合类他的底层结构是什么(数组，链表，数组+链表) 如果底层结构是数组，谈数组的默认初始容量，数组的扩容机制 这个集合类是否有序(位序) 有序: 添加的位置是不是可以预期的 这个集合类是否允许存储重复元素(二叉搜索树不允许有重复元素) 这个集合类是否允许存储null 这个集合类是否线程安全 ","date":"2021-05-05","objectID":"/posts/day29/:0:2","tags":["java"],"title":"Day29","uri":"/posts/day29/"},{"categories":["王道"],"content":"为什么需要集合类？ 很多情况下，我们需要对一组对象进行操作 很可能事先并不知道到底有多少对象 为了解决这个问题，java 就提供了集合类供我们使用 ","date":"2021-05-05","objectID":"/posts/day29/:0:3","tags":["java"],"title":"Day29","uri":"/posts/day29/"},{"categories":["王道"],"content":"集合类有什么特点? a. 只能存储引用数据类型: (集合类是个数据容器, 用了泛型，泛型只能是引用类型) b. 可以自动地调整自己的大小: (实现了扩容机制) ","date":"2021-05-05","objectID":"/posts/day29/:0:4","tags":["java"],"title":"Day29","uri":"/posts/day29/"},{"categories":["王道"],"content":"数组和集合类都是容器，它们有什么不同? a. 数组可以存储基本数据类型，集合不可以 b. 数组的长度是固定的，集合可以自动调整自己的大小 c. 数组的效率高，相对来说集合效率比较低 d. 数组没有API, 集合有丰富的API ","date":"2021-05-05","objectID":"/posts/day29/:0:5","tags":["java"],"title":"Day29","uri":"/posts/day29/"},{"categories":["王道"],"content":"Collection 有什么特点? Collection 是 Collection 集合体系的顶级接口 一些 collection 的子实现是有序的，而另一些 collection 的子实现则是无序的 一些 collection 的子实现是允许存储重复元素的，而另一些 collection 的子实现则是不允许存储重复元素的(==, 地址，compareble 自然排序) 一些 Collection 的子实现是允许存储 null, 而另一些 Collection 的子实现是不允许存储null ","date":"2021-05-05","objectID":"/posts/day29/:0:6","tags":["java"],"title":"Day29","uri":"/posts/day29/"},{"categories":["王道"],"content":"接口存在有什么意义? 实现多继承 提供 规范 和 约束 ","date":"2021-05-05","objectID":"/posts/day29/:0:7","tags":["java"],"title":"Day29","uri":"/posts/day29/"},{"categories":["王道"],"content":"1 10 -5 2 7 100 30 -10 -50 -25 -20 25 转换成二叉搜索树是什么样的? 左子树的所有节点的值均 小于 它的根节点 右子树的所有节点的值均 大于 它的根节点 ","date":"2021-05-04","objectID":"/posts/day28/:0:1","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"The meaning of \u003cT extends Comparable \u003e? This means that the type parameter must support comparison with other instances of its own type , via the Comparable interface. ","date":"2021-05-04","objectID":"/posts/day28/:0:2","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"What is different between ? If you try to pass an array of unknow types of Comparable objects one method will give you an error at compile time that this won’t work, and the other will compile just fine, but you’ll receive an error when you try to run it. Ideally, you’will want to know about type safety issues as soon as possible, so the method that gives you a compile-time error is preferable. ","date":"2021-05-04","objectID":"/posts/day28/:0:3","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"若以链表来实现一个二叉搜索树, 如何定义一个BSTree? public class MyBSTree{ private Node root; // 定义根结点 private int size; // 定义树的结点个数 } 需要节点与节点之间进行比较 public class MyBSTree\u003cT extends Comparable\u003cT\u003e\u003e { private Node root; // 定义根结点 private int size; // 定义树的结点个数 } ","date":"2021-05-04","objectID":"/posts/day28/:0:4","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"若以链表来实现一个二叉搜索树, 如何定义一个BSTree的结点? public class MyBSTree\u003cT extends Comparable\u003cT\u003e\u003e { private Node root; // 定义根结点 private int size; // 定义树的结点个数 class Node { T value; Node left; Node right; public Node(T value, Node left, Node right) { this.value = value; this.left = left; this.right = right; } } } ","date":"2021-05-04","objectID":"/posts/day28/:0:5","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"若以链表来实现一个二叉搜索树, 如何实现加入一个新结点(add)的功能? public boolean add(T t) { // 1. 不能加null结点 if (t == null) throw new IllegalArgumentException(\"null is not allow to add\"); // 2.1 添加的不是null, 当前树为空 if (size == 0) { root = new Node(t, null, null); size++; return true; } else { // 2.2 添加的不是null, 当前的树不为空 // 找到要添加的位置(查找过程) // 从root向下找 Node mid = root; Node midF = null; int com; // 一直向下找, 在null处结束 // 同时记录其父结点 while (mid != null) { // 判断左右 compareTo com = t.compareTo(mid.value); // t \u003e mid, 向右走 if (com \u003e 0) { midF = mid; mid = mid.right; } else if (com \u003c 0) { // t \u003c mid, 向左走 midF = mid; mid = mid.left; } else { // t == mid, 不添加 return false; } } // mid == null, 已经找到了要添加结点的位置 // 通过 com 的大小， 判断要添加的左右位置(与其midF比较) if (t.compareTo(midF.value) \u003e 0) { // 大于0, 在右边 midF.right = new Node(t, null, null); size++; return true; } else { // 小于0, 在左边 midF.left = new Node(t, null, null); size++; return true; } } } ","date":"2021-05-04","objectID":"/posts/day28/:0:6","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"若以链表来实现一个二叉搜索树, 如何实现删除一个结点(remove)的功能?(不用递归) public boolean remove(T t) { // 确定删除的内容不能是null if (t == null) throw new IllegalArgumentException(\"param is not null\"); // 从根结点出发 Node mid = root; int com; // 用midF 来删除 Node midF = null; while (mid != null) { com = t.compareTo(mid.value); // 当前位置 if (com == 0) { // 找到了, 跳出来 break; } else if (com \u003e 0) { // 向右 midF = mid; mid = mid.right; } else { // 向左 midF = mid; mid = mid.left; } } // 跳出 // 1. mid == null if (mid == null) { return false; } // 2. com == 0 // 2.1 单分支 // 2.2 叶子结点 // 2.3 双分支 if (mid.left != null \u0026\u0026 mid.right != null) { // 找到右子树中最小的节点, 一直往左找 Node min = mid.right; Node minF = mid; while (min.left != null) { minF = min; min = min.left; } // 将 最小的节点与 mid 交换 mid.value = min.value; // 将双分支节点变成叶子结点 mid = min; // 切换父结点 midF = minF; } // 只剩下叶子结点与单分支结点 // 找到不是null的分支 // ch 是要保留的分支 Node ch = (mid.left == null ? mid.right : mid.left); // 删除的根结点，并且根节点是单分支的结点 if (midF == null) { root = ch; size--; return true; } // 上移 if (mid == midF.left) { // 左边相同 midF.left = ch; size--; return true; } else { // 右边相同, 或为null midF.right = ch; size--; return true; } } ","date":"2021-05-04","objectID":"/posts/day28/:0:7","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"若以链表来实现一个二叉搜索树, 如何实现查找树中是否包含某一结点? public boolean contains(T t) { // 不能与null比较 if (t == null) throw new IllegalArgumentException(\"param is not equal null\"); // 从 root 开始找 Node mid = root; while (mid != null) { if (t.compareTo(mid.value) \u003e 0) { // 向右 mid = mid.right; } else if (t.compareTo(mid.value) \u003c 0) { // 向左 mid = mid.left; } else { // 相等 // 找到了 0 return true; } } // 没找到 return false; } ","date":"2021-05-04","objectID":"/posts/day28/:0:8","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"如何实现后序遍历? 左 右 根 要有一个stack， 和一个list 根要最后输出 list 采用头插法方式， 弹出头结点后, 应该先插入左边还是右边? 因为 左 右 根 要先弹出右子树的元素, 所以先压入 left 子树， 再压入 right 子树 public List\u003cT\u003e postOrder() { // 保存遍历的结果 ArrayList\u003cT\u003e ts = new ArrayList\u003c\u003e(); Stack\u003cNode\u003e stack = new Stack\u003c\u003e(); // 根节点 stack.push(root); // 判断条件是栈不为空 while (!stack.isEmpty()) { // 弹出栈顶元素 Node pop = stack.pop(); // 先压左子树, 不为null时 if (pop.left != null) { stack.push(pop.left); } // 后压右子树, 不为null时 if (pop.right != null) { stack.push(pop.right); } // 将弹出的元素放入list中(头插法) ts.add(0, pop.value); } return ts; } ","date":"2021-05-04","objectID":"/posts/day28/:0:9","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"如何实现前序遍历? 根 左 右 需要一个stack， 一个list root 先压入栈中， 弹出 因为是 根 左 右, 先输出左，后右 先压入右子树， 后压入左子树 判断条件是栈不为空 public List\u003cT\u003e preOrder() { // 创建一个list保存数据 ArrayList\u003cT\u003e ts = new ArrayList\u003c\u003e(); // 创建一个stack Stack\u003cNode\u003e stack = new Stack\u003c\u003e(); // 压入根节点 stack.push(root); while (!stack.isEmpty()) { // 栈顶元素弹出 Node pop = stack.pop(); // 先压入右子树, 非null if (pop.right != null) { stack.push(pop.right); } // 后压入左子树, 非null if (pop.left != null) { stack.push(pop.left); } // 尾插法 ts.add(pop.value); } return ts; } ","date":"2021-05-04","objectID":"/posts/day28/:0:10","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"如何实现中序遍历? 需要一个stack 和一个 list 左 根 右 因为根是放在中间， 所以先将根标记起来 向左遍历, 全部压入栈中(标记结点也要记录)，直到遇到null 弹出栈顶元素，标记向右移动 public List\u003cT\u003e inOrder() { // 保存要输出的list ArrayList\u003cT\u003e ts = new ArrayList\u003c\u003e(); // 创建一个链表 Stack\u003cNode\u003e stack = new Stack\u003c\u003e(); Node mid = root; while (mid != null || !stack.isEmpty()) { while (mid != null) { // 向左走，压入stack中 stack.push(mid); mid = mid.left; } // mid ==null // 栈顶,出栈 // mid 向右移 Node pop = stack.pop(); ts.add(pop.value); mid = pop.right; } return ts; } ","date":"2021-05-04","objectID":"/posts/day28/:0:11","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"如何实现层级遍历(广度优先搜索)? 队列 public List\u003cT\u003e levOrder() { // 用队列来输出 ArrayDeque\u003cNode\u003e deque = new ArrayDeque\u003c\u003e(); // list ArrayList\u003cT\u003e list = new ArrayList\u003c\u003e(); // root 入队 deque.add(root); while(!deque.isEmpty()){ // 队头元素出队 Node pop = deque.pop(); // 左子树入队, 非null if(pop.left != null){ deque.add(pop.left); } // 右子树入队, 非null if(pop.right != null){ deque.add(pop.right); } // 出队元素入list list.add(pop.value); } return list; } ","date":"2021-05-04","objectID":"/posts/day28/:0:12","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"如何实现深度优先遍历? 需要一个 stack 和 一个 list 将 root 压入栈中, 不断的压入其左边的元素, 直到左边的元素为null 压入其右边的元素, 再压入其左边的元素，直到左右边的元素都为null时弹出，当前的元素 加入到list中 public List\u003cT\u003e depOrder() { // 返回的list ArrayList\u003cT\u003e list = new ArrayList\u003c\u003e(); // 创建一个stack Stack\u003cNode\u003e stack = new Stack\u003c\u003e(); // root 入栈 stack.push(root); while (!stack.isEmpty()) { Node pop = stack.pop(); if (pop.left != null) { stack.push(pop.left); } if (pop.right != null) { stack.push(pop.right); } list.add(pop.value); } return list; } ","date":"2021-05-04","objectID":"/posts/day28/:0:13","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"如何实现中序与后序号建立树? 先获取根节点在中序的位置 根据后序来获取 T value = postOrder.get(postOrder.size() - 1); int index = inOrder.indexOf(value); 左子树 的中序(切割): 0 ~ index - 1 左子树 的后序(切割): 0 ~ index - 1 右子树 的中序(切割): index + 1 ~ size - 1 右子树 的后序(切割): index ~ size - 2 public void buildTreeByInAndPostOrder(List\u003cT\u003e inOrder, List\u003cT\u003e postOrder) { // 调用私有方法建立树 root = buildTreeByInAndPostOrder2(inOrder, postOrder); // 定义树的长度 size = inOrder.size(); } private Node buildTreeByInAndPostOrder2(List\u003cT\u003e inOrder, List\u003cT\u003e postOrder) { // 退出位置 if (inOrder.size() == 0) return null; if (inOrder.size() == 1) return new Node(inOrder.get(0), null, null); // 找到根结点的值(后序中的最后一个) // get (int index) T value = postOrder.get(postOrder.size() - 1); // 获取根结点的位置(在中序中获得) int index = inOrder.indexOf(value); // 划分左子树 List\u003cT\u003e leftInOrder = inOrder.subList(0, index);// 左闭右开 List\u003cT\u003e leftPostOrder = postOrder.subList(0, index); // 划分右子树 List\u003cT\u003e rightInOrder = inOrder.subList(index + 1, inOrder.size()); List\u003cT\u003e rightPostOrder = postOrder.subList(index, inOrder.size() - 1); // 构建根结点 Node node = new Node(value, null, null); // 获得左子树 node.left = buildTreeByInAndPostOrder2(leftInOrder, leftPostOrder); // 获得右子树 node.left = buildTreeByInAndPostOrder2(rightInOrder, rightPostOrder); return node; } ","date":"2021-05-04","objectID":"/posts/day28/:0:14","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"如何实现中序与前序号建立树? 先获取根节点在中序的位置 根据后序来获取 T value = postOrder.get(postOrder.size() - 1); int index = inOrder.indexOf(value); 左子树 的中序(切割): 0 ~ index - 1 左子树 的前序(切割): 1 ~ index - 1 右子树 的中序(切割): index + 1 ~ size - 1 右子树 的前序(切割): index + 1 ~ size - 1 public void buildTreeByInAndPreOrder(List\u003cT\u003e inOrder, List\u003cT\u003e preOrder) { // 调用私有方法建树 root = buildTreeByInAndPreOrder2(inOrder, preOrder); size = inOrder.size(); } private Node buildTreeByInAndPreOrder2(List\u003cT\u003e inOrder, List\u003cT\u003e preOrder) { // 退出位置 if (inOrder.size() == 0) return null; if (inOrder.size() == 1) return new Node(inOrder.get(0), null, null); // 找到根结点的值(先序中的第一个元素) T value = preOrder.get(0); // 获取根结点在 inOrder的位置 int index = inOrder.indexOf(value); // 划分左子树 List\u003cT\u003e leftInOrder = inOrder.subList(0, index); List\u003cT\u003e leftPreOrder = preOrder.subList(1, index + 1); // 划分右子树 List\u003cT\u003e rightInorder = inOrder.subList(index + 1, inOrder.size()); List\u003cT\u003e rightPreorder = preOrder.subList(index + 1, inOrder.size()); // 构建递归根节点 final Node node = new Node(value, null, null); // 获得左子树 node.left = buildTreeByInAndPostOrder2(leftInOrder, leftPreOrder); // 获得右子树 node.right = buildTreeByInAndPostOrder2(rightInorder, rightPreorder); return node; } ","date":"2021-05-04","objectID":"/posts/day28/:0:15","tags":["java"],"title":"Day28","uri":"/posts/day28/"},{"categories":["王道"],"content":"自平衡二叉搜索树与红黑树是什么关系? 自平衡二叉搜索树是 算法和逻辑 红黑树是 实现 ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:1","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"什么是自平衡的二叉搜索树? 叶节点的层级差的绝对值不超过1 ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:2","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"什么是 2-3-4 树? 在二叉查找树上进行了扩展，它允许有多个键(1~3)个 树保持完美平衡 子树比键值多一个 ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:3","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"2-3-4树如何查找? ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:4","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"2-3-4树如何插入? ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:5","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"什么是二节点，三节点, 四节点? 1 个元素是二节点 2 个元素是三节点 3 个元素是四节点 ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:6","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"2-3-4 树, 4结点如何分裂？ ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:7","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"对于 2-3-4 树，多个4结点如何分裂? ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:8","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"分裂结点的办法有哪些? 自底向上分裂 自上向底分裂 (遇到四节点(3个Key)先向上分裂，再向下添加) ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:9","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"2-3-4 树的实现? ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:10","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"将3结点转化成二叉树? ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:11","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"将4结点转化成二叉树? ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:12","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"把2-3-4树转化成红黑树? 把 2-3-4 树的3, 4节点分裂，把下移的结点或上移的结点的中间的边变为红色 ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:13","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"2-3-4树转化成红黑树只能有一种情况吗? ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:14","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"什么是左倾红黑树? 就是在 2-3-4 树的3 节点分裂的时候，左元素下移，右元素上移 ","date":"2021-05-02","objectID":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/:0:15","tags":["java"],"title":"红黑树","uri":"/posts/%E7%BA%A2%E9%BB%91%E6%A0%91/"},{"categories":["王道"],"content":"MyLIstStack ","date":"2021-04-30","objectID":"/posts/day27/:0:1","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"栈列有什么应用? 函数调用栈 反序字符串 括号匹配 编译器利用栈实现表达式求值 浏览器的前进后退功能 利用栈实现 DFS: depth-first-search ","date":"2021-04-30","objectID":"/posts/day27/:0:2","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"实现renumber方法? ","date":"2021-04-30","objectID":"/posts/day27/:0:3","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"实现括号匹配(judgeBracket)方法? ","date":"2021-04-30","objectID":"/posts/day27/:0:4","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"什么是中缀表达式, 前缀表达式, 后缀表达式? 运算符放到 中间: 中缀表达式 之前: 前缀表达式 后面: 后缀表达式 ","date":"2021-04-30","objectID":"/posts/day27/:0:5","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"(2 * ( 9 + 6 / 3 -5 ) + 4) 转成后缀表达式的过程是什么样的? 从左到右 遍历中缀表达式的每个数字和符号 若是数字就输出，即成为后缀表达式的一部分 若是符号，则判断其与栈顶符号的优先级，是右括号或者优先级低于栈顶符号(乘除优先加减) 则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止 ","date":"2021-04-30","objectID":"/posts/day27/:0:6","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"2 - 1 + 3 * 2 -5 转成后缀表达式的结果是什么? 中缀转后缀是 从左往右 扫描 2 1 - 3 2 * + 5 - ","date":"2021-04-30","objectID":"/posts/day27/:0:7","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"(1 + (3 * 4) / 6) -5 转成前缀表达式的过程是什么? 初始化两个栈: 运算符栈 S1, 操作数栈 S2 从右至左扫描中缀表达式 遇到 操作数 时, 将其压入 S2 遇到 运算数 时, 比较其与 S1 栈顶运算符的优先级 如果 S1 为空, 或栈顶运算符为右括号 ), 或其优先及比栈顶运算符的优先级较高或相等，则直接将 此运算符 入栈 否则， 将 S1 栈顶的运算符弹出并压入到 S2 中， 再次进行与 S1 栈顶运算符的优先级比较 然后将其弹出 - + 1 / * 3 4 6 5 ","date":"2021-04-30","objectID":"/posts/day27/:0:8","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"(1 + (3 * 4) / 6 ) - 5 转成前缀表达式后的结果是什么? - + 1 / * 3 4 6 5 ","date":"2021-04-30","objectID":"/posts/day27/:0:9","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"什么是队列? 是一种 “操作受限” 的线性表 体现在一端插入数据在另一端删除数据 ","date":"2021-04-30","objectID":"/posts/day27/:0:10","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"在用链表实现队列时，如何定义一个队列? 队头 队尾 队长度 public class MyLinkedQueue\u003cT\u003e { private Node head; // 队头 private Node end; // 队尾 private int size; class Node { T value; Node next; public Node(T value, Node next) { this.value = value; this.next = next; } } } ","date":"2021-04-30","objectID":"/posts/day27/:0:11","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"如何实现向链表队列中添加结点? 添加结点为 offer 判断链表是否空 为空， 添加至队头, head = end 不为空，添加至end, end后移 public boolean offer(T t) { // 如果原队列为空 if (isEmpty()) { head = new Node(t, null); end = head; size++; return true; } // 如果原出队列不为空 end = new Node(t, null); end = end.next; // end 后移 size++; return true; } ","date":"2021-04-30","objectID":"/posts/day27/:0:12","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"如何实现向链表队列中删除结点? 删除 poll 判断链表是否空 为空抛出异常 只有一个结点 不只有一个结点 public T poll() { // 链表为空 if (isEmpty()) throw new RuntimeException(\"queue is empty\"); // 链表中只有一个元素 if (size == 1) { T oldValue = head.value; head = null; end = null; size--; return oldValue; } else { // 链表中不止一个元素 T oldValue = end.value; head = head.next; size--; return oldValue; } } ","date":"2021-04-30","objectID":"/posts/day27/:0:13","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"如何实现向链表队列中查看队头元素? 查看队头元素 peek public T peek(){ if(isEmpty()) throw new RuntimeException(\"queue is Empty\"); return head.value; } ","date":"2021-04-30","objectID":"/posts/day27/:0:14","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"如何用数组定义一个队列? public class MyArrayQueue { Object objs; final int INIT_CAPACITY = 10; final int MAX_CAPACITY = Integer.MAX_VALUE - 8; public MyArrayQueue() { objs = new Object[INIT_CAPACITY]; } public MyArrayQueue(int initCapacity) { if (initCapacity \u003c= 0 || initCapacity \u003e MAX_CAPACITY) objs = new Object[initCapacity]; } } ","date":"2021-04-30","objectID":"/posts/day27/:0:15","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"用数组定义的队列，如何实现增加结点? offer 判断数组是否满? 已满 获取新的才度 - 判断长度是否溢出 新建一个数组 未满 - 原队列是否为空 public boolean offer(T t) { // 判断数组是否满? if (size == objs.length) { int newLen = getLen(); grow(newLen); } // 如果原队列为空 if (isEmpty()) { objs[head] = t; end = head; size++; return true; } else { end = (end + 1) % objs.length; objs[end] = t; size++; return true; } } private void grow(int newLen) { Object[] newArr = new Object[newLen]; for (int i = 0; i \u003c objs.length; i++) { int index = (head + i) % objs.length; newArr[i] = objs[index]; } objs = newArr; head = 0; end = size - 1; } private int getLen() { int oldLen = objs.length; int newLen = objs.length \u003c\u003c 1; // 判断数据是否溢出 if (newLen \u003e= MAX_CAPACITY || newLen \u003c= 0) { newLen = MAX_CAPACITY; } // 如果新长度和旧长度一样 if (oldLen == newLen) throw new RuntimeException(\"stack can not add\"); return newLen; } ","date":"2021-04-30","objectID":"/posts/day27/:0:16","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"用数组定义的队列，如何实现弹出结点? poll 队列是否为空 - 是否只有一个元素 public T poll() { if (isEmpty()) throw new RuntimeException(\"queue is Empty\"); if (size == 1) { // 原队列只有一个元素 T oldValue = (T) objs[head]; head = 0; end = 0; size--; return oldValue; } else { // 队列中超过一个元素 T oldValue = (T) objs[head]; head = (head + 1) % objs.length; size--; return oldValue; } } ","date":"2021-04-30","objectID":"/posts/day27/:0:17","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"用数组定义的队列，如何实现查看队头元素? peek 队列是否为空 public T peek() { if (isEmpty()) throw new RuntimeException(\"queue is Empty\"); return (T) objs[head]; } ","date":"2021-04-30","objectID":"/posts/day27/:0:18","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"队列有什么应用? 普通的队列的应用场景是很有限的， 一般在工程中用到的是 阻塞队列 阻塞队列: 常用于生产者 - 消费者模型中 当队列满的时候, 入队列就阻塞 当队列空的时候，出队列就阻塞 ","date":"2021-04-30","objectID":"/posts/day27/:0:19","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"什么是ni的深度? 根的深度为多少? 对于任意结点 ni, ni 的深度为从根到 ni 的唯一路径的长 根的深度为0 ","date":"2021-04-30","objectID":"/posts/day27/:0:20","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"什么是ni的高度? 所有的树叶高是多少? ni 的高是从ni 到一片树叶的最长路径的长 所有树叶的高都为0 ","date":"2021-04-30","objectID":"/posts/day27/:0:21","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"为什么一颗树有 n 个结点， 那么它有 n-1 条边? 每一结点都有一个边指向它 每一条边都指向一个结点 ","date":"2021-04-30","objectID":"/posts/day27/:0:22","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"什么是二叉树? 一个树，一个结点最多有两个孩子，孩子有严格的左右之分 ","date":"2021-04-30","objectID":"/posts/day27/:0:23","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"完美二叉树既是完全二叉树又是满二叉树吗? 是 ","date":"2021-04-30","objectID":"/posts/day27/:0:24","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"如果一颗树既是完全二叉树又是满二叉树，那么它是完美二叉树吗? 不是 ","date":"2021-04-30","objectID":"/posts/day27/:0:25","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"二叉树在第 i 层至多有多少个节点? 至多有 2的(i-1) 方个节点 ","date":"2021-04-30","objectID":"/posts/day27/:0:26","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"层次为k的二叉树至多有多少个节点? 1 + 2 + 4 + … + 2的(i - 1)次方 = 2的i次方 - 1 ","date":"2021-04-30","objectID":"/posts/day27/:0:27","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"对于任何一颗二叉树 T, 如果其叶子节点数为 n0, 度为2 的节点数为 n2, 则n0与n2存在什么样的关系? 边数 = 节点数 - 1 边数(从上向下) = n1 + 2n2 边数(从下往上) = n0 + n1 + n2 -1(去掉根) 叶子结点的个数比度为2的结点的个数多1个 n0 = n2 + 1 ","date":"2021-04-30","objectID":"/posts/day27/:0:28","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"具有n个节点的完全二叉树，树的高度为多少? log2n 向下取整 1 + 2 + 4 + … + 2的(i - 1)次方 = 2的i次方 - 1 ","date":"2021-04-30","objectID":"/posts/day27/:0:29","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"以根, 左, 右这三种方式遍历树，有多少种情况? ","date":"2021-04-30","objectID":"/posts/day27/:0:30","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"什么是先序遍历, 中序遍历，后序遍历? 先序遍历: 先遍历根结点， 再遍历左子树, 再遍历右子树 中序遍历: 先遍历左子树， 再遍历根结点, 再遍历右子树 后序遍历: 先遍历左子树， 再遍历右子树, 再遍历根结点 ","date":"2021-04-30","objectID":"/posts/day27/:0:31","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"其先序遍历，中序遍历， 后序遍历的结果是什么? 先序遍历: A B D C E F 中序遍历: B D A E F C 后序遍历: D B F E C A ","date":"2021-04-30","objectID":"/posts/day27/:0:32","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"前序遍历，后序遍历，中序遍历分别能确定什么? 前序: 第一个元素是根 后序: 最后一个元素是根 中序: 如果知道根，根的左边序列是左子树结点， 右边序列是右子树结点 ","date":"2021-04-30","objectID":"/posts/day27/:0:33","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"任意去两个遍历序列, 都可以建树吗? 前序 + 中序, 可以，前序可以确定根节点， 中序可以根据根节点划分左右子树 后序 + 中序, 可以，后序可以确定根节点， 中序可以根据根节点划分左右子树 前序 + 后序, 不可以，都只能确定根节点 ","date":"2021-04-30","objectID":"/posts/day27/:0:34","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"二叉树的先序遍历 ABDECFG, 中序遍历 DBEAFGC, 试求它的后序遍历? ","date":"2021-04-30","objectID":"/posts/day27/:0:35","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"什么是二叉搜索树? 又叫二叉排序树 左子树中所有结点的key比根结点的key小，并且左子树也是二叉搜索树 左子树中所有结点的key比根结点的key大，并且左子树也是二叉搜索树 ","date":"2021-04-30","objectID":"/posts/day27/:0:36","tags":["java"],"title":"Day27","uri":"/posts/day27/"},{"categories":["王道"],"content":"如何定义一个双链表? 定义结点 一般有: pre , value , next 结点 class Node { String value; Node next; Node pre; public Node(Node pre, String value, Node next) { this.value = value; this.next = next; this.pre = pre; } } 链表 class Node { String value; Node next; Node pre; public Node(Node pre, String value, Node next) { this.value = value; this.next = next; this.pre = pre; } } ","date":"2021-04-29","objectID":"/posts/day26/:0:1","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"双链表如何根据内容增加? 链表为空 链表非空 public boolean add(String str) { // 判断链表是否为空 if (size == 0) { head = new Node(null, str, null); end = head; size++; } else { // 链表不为空 end.next = new Node(end, str, null); end = end.next; size++; } return true; } ","date":"2021-04-29","objectID":"/posts/day26/:0:2","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"双链表中如何根据内容删除? 判断链表是否为空, 为空抛出异常 非空 判断是否是第一个位置 判断删除的是否是最后一个位置 public boolean remove(String str) { // 判断链表为空 if (size == 0) throw new RuntimeException(\"Link is empty\"); // 判断要删除的元素是否为null if (str == null) { // 头结点就是null if (null == head.value) { // 只有一个元素 if (size == 1) { // 头结点和尾结点均指向空 head = null; end = null; size--; return true; } else { // 不只有一个元素 head = head.next; size--; return true; } } // null 不是头结点 // 指向 头结点后的元素 Node mid = head.next; while (mid != null \u0026\u0026 mid.value != null) { mid = mid.next; } // 1. mid == null, 没找到 if (mid == null) return false; // 2. mid.value == null 找到了 // 2. 判断删除的元素是否是最后一个元素 // 2.1 删除的元素是最后一个元素(mid 就是要删除的元素) if (mid == end) { end = mid.pre; // end 往前移 end.next = null; // end 后变成null size--; return true; } // 2.2 删除的元素不是最后一个元素(mid 就是要删除的元素) mid.next.pre = mid.next.next; mid.pre.next = mid.next; size--; return true; } else { // 链表不为空 // 1. 删除的是第一个位置 if (head.value.equals(str)) { head = head.next; head.pre = null; size--; return true; } else { // 2. 删除的是不是第一个位置 Node mid = head.next; while (mid != null \u0026\u0026 !mid.value.equals(str)) { mid = mid.next; } // 1. mid == null; if (mid == null) return false; // 2. mid.value.equals(str) // 2.1 删除的不是最后一个元素 // 2.2 删除的是最后一个元素 if (mid == end) { end = mid.pre; end.next = null; size--; return true; } else { mid.next.pre = mid.pre; mid.pre.next = mid.next; size--; return true; } } } } ","date":"2021-04-29","objectID":"/posts/day26/:0:3","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"如何使双链表根据内容查找? public boolean contains(String str) { // 1. 链表是否为空 if (isEmpty()) throw new RuntimeException(\"linked is empty\"); // 2. 链表不为空 // 2.1 判断是null if (str == null) { Node mid = head; while (mid != null \u0026\u0026 mid.value != null) { mid = mid.next; } // 2.1.1 mid == null 没找到 if (mid == null) return false; // 2.1.2 mid.value == null 找到了, mid就是 return true; } else { // 2.2 判断的不是null Node mid = head; while (mid != null \u0026\u0026 !str.equals(mid.value)) { mid = mid.next; } // 2.2.1 mid == null 没找到 if (mid == null) return false; // 2.2.2 mid.value == str ， 找到了, mid 就是 return true; } } ","date":"2021-04-29","objectID":"/posts/day26/:0:4","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"双链表如何实现根据内容替换? public boolean set(String oldValue, String newValue) { // 1. 链表为空 if (size == 0) throw new RuntimeException(\"Link is Empty\"); // 2. oldValue 为null if (oldValue == null) { // mid 为目标结点 Node mid = head; while (mid != null \u0026\u0026 mid.value != null) { mid = mid.next; } // 2.1 mid == null if (mid == null) return false; // 2.2 mid.value == null mid.value = newValue; return true; } else { // 3. oldValue 非null // mid 为目标结点 Node mid = head; while (mid != null \u0026\u0026 mid.value != oldValue) { mid = mid.next; } // 3.1 mid == null if (mid == null) return false; // 3.2 mid.value == null mid.value = newValue; return true; } } ","date":"2021-04-29","objectID":"/posts/day26/:0:5","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"双链表如何根据下标做添加？ 添加的为头位置 链表为空 链表非空 添加的不是头结点 判断添加的位置() 从后往前，还是从前往后 最后一个结点的判断 public boolean add(int index, String str) { // 1. 判断下标是否越界 (头, 尾+1) if (index \u003c 0 || index \u003e size) throw new IllegalArgumentException(\"size \" + size); // 2.1 添加的位置在头部 if (index == 0) { if (isEmpty()) { // 链表为空 head = new Node(null, str, head); size++; return true; } else { // 链表非空 Node node = new Node(null, str, head); head.pre = node; head = node; size++; return true; } } else { // 2.2 添加的位置不在头部 // 2.2.1 添加的位置在尾部 if (index == size) { end = new Node(end, str, null); size++; return true; } // 2.2.2 添加的位置不在尾部 if (index \u003c (size / 2)) { // 2.2.2.1 判断它是在前半部分 Node mid = head; int num = 0; while (num \u003c index) { mid = mid.next; num++; } // num == index; Node node = new Node(mid, str, mid.next); node.pre.next = node; node.next.pre = node; size++; return true; } else { // 2.2.2.1 判断它是在前半部分 Node mid = end; int num = size; while (num \u003e index) { mid = mid.pre; num--; } // num == index; Node node = new Node(mid, str, mid.next); node.pre.next = node; node.next.pre = node; size++; return true; } } } ","date":"2021-04-29","objectID":"/posts/day26/:0:6","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"双链表根据下标做删除? index 判断 链表为空判断 删除的是头结点 size 为 1 非1 删除的不是头结点 查找元素 判断是否为尾结点 不是尾结点 public String remove(int index) { // 判断index是否合法 if (index \u003c 0 || index \u003e= size) throw new IllegalArgumentException(\"size :\" + size); // 判断链表是否为空 if (isEmpty()) throw new RuntimeException(\"linked is empty\"); // 要返回的oldValue String oldValue = \"\"; // 判断删除的元素是否是第1个 if (index == 0) { // 判断其后还有没有元素 if (size == 1) { oldValue = head.value; head = null; end = null; size--; } else { // 其后还有元素 oldValue = head.value; head = head.next; head.pre = null; size--; } } else { // 删除的元素不是第1个元素 // 判断是否为最后一个元素 if (index == size - 1) { // 是最后一个元素 oldValue = end.value; end = end.pre; end.pre = null; size--; } else { // 判断其是前一半还是后一半 if (index \u003c (size / 2)) { int flag = 1; Node mid = head.next; while (flag \u003c index - 1) { mid = mid.next; flag++; } oldValue = mid.next.value; mid.next = mid.next.next; mid.next.pre = mid.pre; size--; } else { int flag = size - 2; Node mid = end; while (flag \u003e index - 1) { mid = mid.pre; flag--; } oldValue = mid.next.value; mid.next = mid.next.next; mid.next.pre = mid.pre; size--; } } } return oldValue; } ###　双链表如何根据下标查找? public String get(int index) { if (index \u003c 0 || index \u003e= size) throw new IllegalArgumentException(\"size = \" + size); Node mid = null; if (index \u003e (size / 2)) { // 靠后 mid = end; int tag = size - 1; while (tag != index) { mid = mid.pre; tag--; } } else { // 靠前 mid = head; int tag = 0; while (tag != index) { mid = mid.next; tag++; } } return mid.value; } ###　双链表如何根据下标修改? public String set(int index, String str) { if (index \u003c 0 || index \u003e= size) throw new IllegalArgumentException(\"size\" + size); Node mid = null; if (index \u003e (size / 2)) { // 靠后 mid = end; int tag = size - 1; while (tag != index) { mid = mid.pre; tag--; } } else { // 靠前 mid = head; int tag = 0; while (tag != index) { mid = mid.next; tag++; } } String oldStr = mid.value; mid.value = str; return oldStr; } ###　数组与链表的时间复杂度? 数组 和 链表 操作的时间复杂度正好相反 添加/ 删除 查找 数组 O(n) O(1) 根据下标 链表 O(1) O(n) 数组使用的是连续的内存空间，可以利用 CPU 的高速缓存磁盘预读数据，链表的内存空间不连续的，不能有效预读数据。 如果数组过大，系统没有足够的连续内存空间，会抛出Out of Memory. 数组的缺点是大小固定，没法动态的调整大小，如果要存储一些对象，如果数组太大，浪费内存空间; 如果数组太小，我们需要重新重新申请一个更大数组，并将数据拷贝过去，耗时. 如果业务对内存的使用非常苛刻，数组更适合，因为结点有指针域，更消耗内存，而且对链表的频繁插入和删除，会导致结点对象的频繁创建和销毁，有可能会导致频繁的GC活动. ","date":"2021-04-29","objectID":"/posts/day26/:0:7","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"什么是泛型? 泛型, 即\" 参数化类型 “，就是将类型由原来的 具体类型\"参数化” , 此时 类型也定义成参数形式 ，然后在 使用/ 调用时传入具体的类型 DemoUser.java public class DemoUser { public static void main(String[] args) { User\u003cString\u003e user1 = new User\u003c\u003e(); user1.age = \"1\"; System.out.println(user1.age); } } User.java public class User \u003cT\u003e{ String name; T age; } ","date":"2021-04-29","objectID":"/posts/day26/:0:8","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型一般用于什么样的情况? 泛型一般常用于 java 的集合类中 ","date":"2021-04-29","objectID":"/posts/day26/:0:9","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"使用泛型有什么好处? 提高了程序的 安全性 将运行期遇到的 问题转移到了编译期 : 编译时问题会提示我们有些错误，可以立刻修改 省去了类型强转的麻烦 ","date":"2021-04-29","objectID":"/posts/day26/:0:10","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型的有哪几种? 泛型类 泛型方法 泛型接口 ","date":"2021-04-29","objectID":"/posts/day26/:0:11","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"什么是泛型类? 把泛型定义在类上 格式: public class 类名 \u003c泛型类型1,…\u003e 参数化类型必须是引用类型 ","date":"2021-04-29","objectID":"/posts/day26/:0:12","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型的一般定义习惯 ","date":"2021-04-29","objectID":"/posts/day26/:0:13","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"如果我们定义一个泛型类/接口/方法， 都可以定义多个泛型，在语法上是完全允许的，但是，一般来说不要把泛型定义过多，（不要超过两个） ","date":"2021-04-29","objectID":"/posts/day26/:0:14","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"如何我们定义一个泛型，但是在使用的时候并没有指定泛型类型，那么这个泛型类型会指定为什么? Object 类型 ","date":"2021-04-29","objectID":"/posts/day26/:0:15","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"java 在什么时候有泛型? ","date":"2021-04-29","objectID":"/posts/day26/:0:16","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型 继承? ","date":"2021-04-29","objectID":"/posts/day26/:0:17","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型接口? ","date":"2021-04-29","objectID":"/posts/day26/:0:18","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型方法？ 定义泛型 ","date":"2021-04-29","objectID":"/posts/day26/:0:19","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"什么是泛型擦除? ","date":"2021-04-29","objectID":"/posts/day26/:0:20","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型可以用int吗? ","date":"2021-04-29","objectID":"/posts/day26/:0:21","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"自动拆箱装箱? ","date":"2021-04-29","objectID":"/posts/day26/:0:22","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"jvm的协变? ","date":"2021-04-29","objectID":"/posts/day26/:0:23","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型不允许协变 ","date":"2021-04-29","objectID":"/posts/day26/:0:24","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"泛型不允许协变，但不想用类似数组的功能? ","date":"2021-04-29","objectID":"/posts/day26/:0:25","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"什么是 Bean 类? 非功能类, 模拟实际中存在的事物 ","date":"2021-04-29","objectID":"/posts/day26/:0:26","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"什么是功能类? ","date":"2021-04-29","objectID":"/posts/day26/:0:27","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"foreach? ","date":"2021-04-29","objectID":"/posts/day26/:0:28","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"可变长参数? ","date":"2021-04-29","objectID":"/posts/day26/:0:29","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"java 集合类? ","date":"2021-04-29","objectID":"/posts/day26/:0:30","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"线性表的分类? 操作受限 ","date":"2021-04-29","objectID":"/posts/day26/:0:31","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"什么是顺序映像？ 什么是非顺序映像? ","date":"2021-04-29","objectID":"/posts/day26/:0:32","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"栈的概念? ","date":"2021-04-29","objectID":"/posts/day26/:0:33","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"如何实现栈(数组)? 添加: push 删除: pop 查看栈顶元素: peek 构造方法 无参 有参 push pop peek ","date":"2021-04-29","objectID":"/posts/day26/:0:34","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"不能是泛型数组 ","date":"2021-04-29","objectID":"/posts/day26/:0:35","tags":["java"],"title":"Day26","uri":"/posts/day26/"},{"categories":["王道"],"content":"如何利用双指针法输出输出中的中间元素(快指针与慢指针)? public class Ex3 { public static void main(String[] args) { Node zs = new Node(\"zs\", null); Node ls = new Node(\"ls\", null); Node wu = new Node(\"wu\", null); Node sq = new Node(\"sq\", null); Node qg = new Node(\"qg\", null); zs.next = ls; ls.next = wu; wu.next = sq; sq.next = qg; System.out.println(getMidNode(zs).toString()); } private static Node getMidNode(Node head) { Node f = head; // 快指针, 一次走2个位置 Node l = head; // 慢指针, 一次走1个位置 // 保证快指针的下一个和下下一个结点 不是 null while (f.next != null \u0026\u0026 f.next.next != null) { f = f.next.next; // 快指针走两步 l = l.next; // 慢指针走一步 } return l; // 返回慢指针的位置，就是链表中间的位置 } } class Node { String Node; Node next; public Node(String node, Node next) { this.Node = node; this.next = next; } @Override public String toString() { return \"Node{\" + \"Node='\" + Node + '\\'' + \", next=\" + next + '}'; } } ","date":"2021-04-28","objectID":"/posts/day25/:0:1","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何利用双指针法确认链表中是否有环? public class Ex3 { public static void main(String[] args) { Node zs = new Node(\"zs\", null); Node ls = new Node(\"ls\", null); Node wu = new Node(\"wu\", null); Node sq = new Node(\"sq\", null); Node qg = new Node(\"qg\", null); zs.next = ls; ls.next = wu; wu.next = sq; sq.next = ls; System.out.println(hasCircle(ls)); } private static boolean hasCircle(Node head) { Node f = head; // 快指针 Node l = head; // 慢指针 while (f.next != null \u0026\u0026 f.next.next != null) { f = f.next.next; // 快指针两步 l = l.next; // 慢指针走一步 // 若有环，快指针一定会在环内追慢指针, 快指针比慢指针要快，所以一定能追上 if (f == l) { return true; } } return false; } } class Node { String Node; Node next; public Node(String node, Node next) { this.Node = node; this.next = next; } @Override public String toString() { return \"Node{\" + \"Node='\" + Node + '\\'' + \", next=\" + next + '}'; } } ","date":"2021-04-28","objectID":"/posts/day25/:0:2","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用双指针法，判断链表中是否有环，若有返回其环的结点? 如何有环， 那么环内是一个快指针追慢指针的问题， 快指针每次追一个位置，也就意味着，不会在追的过程中跳过去 环内有y个元素, 两个指针最坏的情况是, 快指针比慢指针快一个位置, 则快指针每走一次是追一个位置，则它需要走y-1次必然能追上慢指针 在追的时候必然在当前环内追上 public class Ex3 { public static void main(String[] args) { Node zs = new Node(\"zs\", null); Node ls = new Node(\"ls\", null); Node wu = new Node(\"wu\", null); Node sq = new Node(\"sq\", null); Node qg = new Node(\"qg\", null); zs.next = ls; ls.next = wu; wu.next = sq; sq.next = qg; qg.next = ls; System.out.println(getCircle(zs)); } private static Node getCircle(Node head) { Node f = head; // 快指针 Node l = head; // 慢指针 while (f.next != null \u0026\u0026 f.next.next != null) { f = f.next.next; // 快指针两步 l = l.next; // 慢指针走一步 // 若有环，快指针一定会在环内追慢指针, 快指针比慢指针要快，所以一定能追上 if (f == l) { // 意味着有环，到相遇的位置 break; } } // 走到这一步: //1. 没有环: f.next = null || f.next.next == null //2. 有环: f == l if (f.next == null || f.next.next == null) { // 没有环 return null; } // 有环 f = head; // 把其中一个指针移动到链表最开始的地方 while (f != l) { f = f.next; l = l.next; } // 返回哪一个都可以 return l; } } class Node { String Node; Node next; public Node(String node, Node next) { this.Node = node; this.next = next; } @Override public String toString() { return \"Node{\" + \"Node='\" + Node + '\\'' + //\", next=\" + next + '}'; } } ","date":"2021-04-28","objectID":"/posts/day25/:0:3","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何采用头插法反转单链表? public class Ex3 { public static void main(String[] args) { Node zs = new Node(\"zs\", null); Node ls = new Node(\"ls\", null); Node wu = new Node(\"wu\", null); Node sq = new Node(\"sq\", null); Node qg = new Node(\"qg\", null); zs.next = ls; ls.next = wu; wu.next = sq; sq.next = qg; System.out.println(reLinked(zs).toString()); } private static Node reLinked(Node head) { // 先创建一个反转过后的链表 Node reLink = null; Node mid = head; // mid 定义的遍历结点 while (mid != null) { // 保留住之前的链表 Node next = mid.next; mid.next = reLink; // 头插代码 reLink = mid; // 将反转后的头结点前移 mid = next; // mid 指回到之前的链表中去 } return reLink; } } class Node { String Node; Node next; public Node(String node, Node next) { this.Node = node; this.next = next; } @Override public String toString() { return \"Node{\" + \"Node='\" + Node + '\\'' + \", next=\" + next + '}'; } } ","date":"2021-04-28","objectID":"/posts/day25/:0:4","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用单链表实现一个线性表(定义)? public class MyLinked { private Node head; // 这个集合类底层所维护链表的头结点 private int size; // 用来标记这个链表/集合类存储了多少数据 } ","date":"2021-04-28","objectID":"/posts/day25/:0:5","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用单链表实现一个线性表(添加元素)考虑可以加null? MyLinked.java public class MyLinked { private Node head; // 这个集合类底层所维护链表的头结点 private int size = 0; // 用来标记这个链表/集合类存储了多少数据 public MyLinked(Node head) { this.head = head; } public boolean add(String str) { if (size == 0) { // 链表为空, 新添加的元素作为头结点 head = new Node(str, null); size++; return true; } // 链表原本不空 // 添加到尾部: 先找到尾部 Node mid = head; // 用mid标记遍历结点，最终找到尾结点 while (mid.next != null) { mid = mid.next; } mid.next = new Node(str, null); size++; return true; } class Node { String value; Node next; public Node(String value, Node next) { this.value = value; this.next = next; } } } MyLinkedPractice.java public class MyLinkedPractice { public static void main(String[] args) { MyLinked myLinked = new MyLinked(null); myLinked.add(\"zs\"); myLinked.add(\"ls\"); myLinked.add(null); System.out.println(myLinked.toString()); } } ","date":"2021-04-28","objectID":"/posts/day25/:0:6","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用单链表实现一个线性表(删除元素)考虑可以删除null? MyLinked.java public boolean remove(String str) { // 判断链表为空 if (size == 0) throw new RuntimeException(\"Link is empty\"); // 链表不为空, 删除的是 null if (str == null) { // 判断是否是头结点 if (str == head.value) { // 判断头结点是不是我们要删除的元素 head = head.next; size--; return true; } // 删除不是头结点 Node mid = head; while (mid.next != null \u0026\u0026 str != mid.next.value) { mid = mid.next; } // 两种结果 // 1. 没找到， mid.next == null // 2. 找到了 if (mid.next == null) { // 没找到 return false; } // 找到了, 要删除的是mid的next mid.next = mid.next.next; // 删除mid的next size--; return true; } else { // 链表不为空, 删除的不是null // 判断是否是头结点 if (str.equals(head.value)) { // 判断头结点是不是我们要删除的元素 head = head.next; size--; return true; } // 删除不是头结点 Node mid = head; while (mid.next != null \u0026\u0026 str != mid.next.value) { mid = mid.next; } // 两种结果 // 1. 没找到， mid.next == null // 2. 找到了 if (mid.next == null) { // 没找到 return false; } // 找到了, 要删除的是mid的next mid.next = mid.next.next; // 删除mid的next size--; return true; } } MyLInkedPractice.java public class MyLinkedPractice { public static void main(String[] args) { MyLinked myLinked = new MyLinked(null); myLinked.add(\"zs\"); myLinked.add(\"ls\"); myLinked.add(null); myLinked.remove(null); myLinked.remove(\"zs\"); System.out.println(myLinked.toString()); } } ","date":"2021-04-28","objectID":"/posts/day25/:0:7","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用单链表实现一个线性表(包含某元素)考虑可以包含null? MyLinked.java public boolean contains(String str) { if (isEmpty()) throw new RuntimeException(\"linked is empty\"); // 查找是null元素 if (str == null) { // null 在头结点 if (str == head.value) { return true; } // 查找的不是头结点 Node mid = head; // mid的下一个元素不是null // mid的下一个元素 存储的值 while (mid.next != null) { mid = mid.next; // mid 向后遍历 if (mid.value == str) { return true; } } } else { // null 在头结点 if (str.equals(head.value)) { return true; } // 查找的不是头结点 Node mid = head; // mid的下一个元素不是null // mid的下一个元素 存储的值 while (mid.next != null) { mid = mid.next; // mid 向后遍历 if (str.equals(mid.value)) { return true; } } } return false; } 会产生空指针异常， 要将它们分开来 MyLinkedPractice.java public class MyLinkedPractice { public static void main(String[] args) { MyLinked myLinked = new MyLinked(null); myLinked.add(\"zs\"); myLinked.add(\"ls\"); myLinked.add(null); System.out.println(\"zs \" + myLinked.contains(\"zs\")); System.out.println(\"ls \" + myLinked.contains(\"ls\")); System.out.println(\"null \" + myLinked.contains(null)); System.out.println(myLinked.contains(\"\")); System.out.println(myLinked.toString()); } } ","date":"2021-04-28","objectID":"/posts/day25/:0:8","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用单链表实现一个线性表(根据内容查找替换成新的内容)考虑可以改null? MyLinked.java public boolean set(String oldValue, String newValue) { if (isEmpty()) throw new RuntimeException(\"linked is empty\"); // 如果要替换的值是null if (oldValue == null) { // 要替换的值是null Node mid = head; while (mid != null \u0026\u0026 oldValue != mid.value) { mid = mid.next; } // 1. mid == null; 没有找到 // 2. oldValue == mid.value; 找到了mid就是要改变的结点 if (mid == null){ return false; } mid.value = newValue; return true; } else { // 如果要替换的值不是null Node mid = head; while (mid != null \u0026\u0026 !oldValue.equals(mid.value)) { mid = mid.next; } // 1. mid == null; 没有找到 // 2. oldValue == mid.value; 找到了mid就是要改变的结点 if (mid == null){ return false; } mid.value = newValue; return true; } } MyLinkedPractice.java public class MyLinkedPractice { public static void main(String[] args) { MyLinked myLinked = new MyLinked(null); myLinked.add(\"zs\"); myLinked.add(\"ls\"); myLinked.add(null); // System.out.println(\"zs \" + myLinked.contains(\"zs\")); // System.out.println(\"ls \" + myLinked.contains(\"ls\")); // System.out.println(\"null \" + myLinked.contains(null)); // System.out.println(myLinked.contains(\"\")); myLinked.set(\"zs\", \"sq\"); myLinked.set(null, \"xg\"); System.out.println(myLinked.toString()); } } ","date":"2021-04-28","objectID":"/posts/day25/:0:9","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用单链表实现一个线性表(根据下标查找替换成新的内容)? MyLinked public String set(int index, String newValue) { // 判断下标是否合法 if (index \u003c 0 || index \u003e= size) throw new IllegalArgumentException(\"size = \" + size); int tag = 0; Node mid = head; while (tag != index) { mid = mid.next; tag++; } // 返回被替换的值 String value = mid.value; mid.value = newValue; return value; } MyLinkedPractice public class MyLinkedPractice { public static void main(String[] args) { MyLinked myLinked = new MyLinked(null); myLinked.add(\"zs\"); myLinked.add(\"ls\"); myLinked.add(null); // System.out.println(\"zs \" + myLinked.contains(\"zs\")); // System.out.println(\"ls \" + myLinked.contains(\"ls\")); // System.out.println(\"null \" + myLinked.contains(null)); // System.out.println(myLinked.contains(\"\")); myLinked.set(\"zs\", \"sq\"); myLinked.set(null, \"xg\"); myLinked.set(0, \"fengxiaonan\"); System.out.println(myLinked.toString()); } } ","date":"2021-04-28","objectID":"/posts/day25/:0:10","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用单链表实现一个线性表(返回下标中的内容)? MyLinked.java public String get(int index) { // 判断下标是否合法 if (index \u003c 0 || index \u003e= size) throw new IllegalArgumentException(\"size = \" + size); int tag = 0; Node mid = head; while (tag != index) { mid = mid.next; tag++; } // 返回被替换的值 return mid.value; } MyLinkedPractice.java public class MyLinkedPractice { public static void main(String[] args) { MyLinked myLinked = new MyLinked(null); myLinked.add(\"zs\"); myLinked.add(\"ls\"); myLinked.add(null); // System.out.println(\"zs \" + myLinked.contains(\"zs\")); // System.out.println(\"ls \" + myLinked.contains(\"ls\")); // System.out.println(\"null \" + myLinked.contains(null)); // System.out.println(myLinked.contains(\"\")); myLinked.set(\"zs\", \"sq\"); myLinked.set(null, \"xg\"); myLinked.set(0, \"fengxiaonan\"); System.out.println(myLinked.get(0)); System.out.println(myLinked.toString()); } } ###　如何用单链表实现一个线性表(删除某个下标的内容)? MyLinked.java public String remove(int index) { // 判断给的下标是否合法 if (index \u003c 0 || index \u003e= size) throw new IllegalArgumentException(\"size = \" + size); // 删除是头元素 if (index == 0) { String oldValue = head.value; head = head.next; size--; return oldValue; } // 删除的不是头元素 int tag = 1; // 位置标记 Node mid = head; while (tag != index) { mid = mid.next; tag++; } // mid 删除元素前一个 String oldValue = mid.next.value; // 删除 mid.next = mid.next.next; size--; return oldValue; } MyLinkedPractice.java public class MyLinkedPractice { public static void main(String[] args) { MyLinked myLinked = new MyLinked(null); myLinked.add(\"zs\"); myLinked.add(\"ls\"); myLinked.add(null); // System.out.println(\"zs \" + myLinked.contains(\"zs\")); // System.out.println(\"ls \" + myLinked.contains(\"ls\")); // System.out.println(\"null \" + myLinked.contains(null)); // System.out.println(myLinked.contains(\"\")); myLinked.set(\"zs\", \"sq\"); myLinked.set(null, \"xg\"); myLinked.set(0, \"fengxiaonan\"); myLinked.remove(0); System.out.println(myLinked.get(0)); System.out.println(myLinked.toString()); } } ","date":"2021-04-28","objectID":"/posts/day25/:0:11","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"如何用单链表实现一个线性表(根据下标的增加内容)? public boolean add(int index, String str) { // 判断给的下标是否合法 if (index \u003c 0 || index \u003e size) throw new IllegalArgumentException(\"size = \" + size); // 若添加的位置是头结点 if (index == 0) { head = new Node(str, head); size++; return true; } // 添加的不是头位置 int tag = 1; Node mid = head; while (tag != index) { mid = mid.next; tag++; } mid.next = new Node(str, mid.next); size++; return true; } ``````java public class MyLinkedPractice { public static void main(String[] args) { MyLinked myLinked = new MyLinked(null); myLinked.add(\"zs\"); myLinked.add(\"ls\"); myLinked.add(null); // System.out.println(\"zs \" + myLinked.contains(\"zs\")); // System.out.println(\"ls \" + myLinked.contains(\"ls\")); // System.out.println(\"null \" + myLinked.contains(null)); // System.out.println(myLinked.contains(\"\")); myLinked.set(\"zs\", \"sq\"); myLinked.set(null, \"xg\"); myLinked.set(0, \"fengxiaonan\"); myLinked.remove(0); System.out.println(myLinked.get(0)); myLinked.add(0, \"xiaonan\"); System.out.println(myLinked.toString()); } } ","date":"2021-04-28","objectID":"/posts/day25/:0:12","tags":["java"],"title":"Day25","uri":"/posts/day25/"},{"categories":["王道"],"content":"数据结构和 Java 有什么关系? 数据结构本身和JAVA没有任何关系 只不过AVA中有多种集合、数组、等集合性质的多对象存储结构, 有时候我们希望更便捷, 更具有逻辑性的操作这些集合或者数组数据 所以我们根据数据结构的组织方式，构建了一些特殊的JAVA集合类 用于描述了一些JAVA对象的底层数据的组成关系 JAVA的集合类底层组织数据的方式，是参照某些数据结构（逻辑、思想）来进行的 ","date":"2021-04-27","objectID":"/posts/day24/:0:1","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"数据结构的种类和JAVA中的集合类别有哪些？ 数据结构：抽象概念/逻辑概念 集合：一堆数据 线性表：有序的序列（操作受限的线性表：栈：先进后出队列：先进先出） Y= ax + b 树：一对多的数据关系，国家，族谱 图：多对多的关系：理论层级 ","date":"2021-04-27","objectID":"/posts/day24/:0:2","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"为什么需要集合类？ 很多情况下，我们需要对一组对象进行操作。而且很可能事先并不知道到底有多少个对象。为了解决这个问题，Java就提供了集合类供我们使用。 （存储更多类型问题，扩容问题, 内存空间浪费问题,数据查找问题，数据删除问题等等 ","date":"2021-04-27","objectID":"/posts/day24/:0:3","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"数组的主要特点是什么? 数组是连续存储 -\u003e 随机访问的 ","date":"2021-04-27","objectID":"/posts/day24/:0:4","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"为什么数组的索引一般都是从0开始的呢? 第一个层面: 历史遗留问题, 在计算资源缺乏的过去，o标号的写法可以节省编译时间 第二个层面: 方便计算 计算公式 = (下标 - 1) * 单个元素空间 + 基础位置 ","date":"2021-04-27","objectID":"/posts/day24/:0:5","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"为什么数组的效率比链表高? 链表: 链表是非连续存储的 数组: 是连续存储的 ","date":"2021-04-27","objectID":"/posts/day24/:0:6","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"Java 中的一维， 多维数组的内存空间是连续的吗？ 在 java 中只有一维数组的内存空间是连续的，多维数组的内存空间不一定连续. ","date":"2021-04-27","objectID":"/posts/day24/:0:7","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"数组的基本操作(添加, 删除)的(最好情况，最坏情况，平均情况)时间复杂度? 添加(保证元素的顺序) 最好情况: O(1) 最坏情况: 移动n个元素 平均情况: 移动 n/2 个元素 删除(保证元素的顺序) 最好情况： O(1) 最坏情况: 移动 n-1 个元素, O(n) 平均情况：移动 (n-1) / 2 元素， O(n) ","date":"2021-04-27","objectID":"/posts/day24/:0:8","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"数组的查找的(根据索引查找元素，查找数组中特定值相等的元素[大小无序，大小有序])时间复杂度? 根据索引查找元素: O(1) 下标 查找数组中与特定值相等的元素: 大小无序: O(n) 大小有序: O($$log_2^{n}$$) ","date":"2021-04-27","objectID":"/posts/day24/:0:9","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"数组适用于什么样的情况下使用， 不适用于什么样的情况? 查找时使用: 尤其根据下标查找 -\u003e 大小有序的折半查找 不适用于添加与删除, 比较慢 ","date":"2021-04-27","objectID":"/posts/day24/:0:10","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"在 Java 什么是链表? 一个对象持有另一个对象的引用，另一个对象持有之后的一个对象的引用… 构成链表 java 的角度链表的本质： 是 java 对象的相互持有和引用 ","date":"2021-04-27","objectID":"/posts/day24/:0:11","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"链表是如何分类的? 单链表 循环单链表 双向链表 双向循环链表 ","date":"2021-04-27","objectID":"/posts/day24/:0:12","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"什么是单链表? 在链表中的每一个节点，都有一个子结点，(尾结点没有子结点) ","date":"2021-04-27","objectID":"/posts/day24/:0:13","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"什么是循环单链表? 单链表的改进，让单链表的尾结点的下一个结点，指向头结点 ","date":"2021-04-27","objectID":"/posts/day24/:0:14","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"什么是双向链表? 双向链表也是单链表的改进，让结点不仅可以指向之后的元素，也可以指向之前的元素 ","date":"2021-04-27","objectID":"/posts/day24/:0:15","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"什么是双向循环链表? 双向链表的一个改进，头元素的之前指向尾元素，尾元素的之后指向头元素 ","date":"2021-04-27","objectID":"/posts/day24/:0:16","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"如何实现单链表增加(头部， 尾部， 非头尾位置)? 头部 Node node = new Node(str, top); top = node; 尾部 mid.next = new Node(str, null); 非头尾位置 Node node = new Node(str, mid.next); mid.next = nod; ","date":"2021-04-27","objectID":"/posts/day24/:0:17","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"如何实现单链表删除(头部， 尾部， 非头尾位置)? 删除头结点 top = top.next; 删除尾结点 mid.next = null; 删除某个中间元素 mid.next = mid.next.next; ","date":"2021-04-27","objectID":"/posts/day24/:0:18","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"如何实现双链表增加(头部， 尾部， 非头尾位置)? 增加头元素 Node node = new Node(null, str, head); head.pre = node; head = node; 添加尾元素 Node node = new Node(end, str, null); end.next = node; end = node; 添加中间位置 Node node = new Node(mid, str, mid.next); mid.next.pre = node; mid.next = node; ###　如何实现双链表删除(头部， 尾部， 非头尾位置)?删除头结点 head = head.next; head.pre = null; 删除尾结点 end = end.pre; end.next = null; 删除中间结点 mid.next.pre = mid.pre; mid.pre.next = mid.next; ","date":"2021-04-27","objectID":"/posts/day24/:0:19","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"双向链表和单链表的时间复杂度是一样的，那为什么在工程上，我们用的一般是双向连个而不是单链表呢? 在实际工作中，根据下标查找这个操作相对添加和删除比较频繁 双向链表根据下标查找的效率， 是高于单链表的. 以空间换时间 ","date":"2021-04-27","objectID":"/posts/day24/:0:20","tags":["java"],"title":"Day24","uri":"/posts/day24/"},{"categories":["王道"],"content":"类加载的细分? 类加载通过 加载, 连接， 初始化 三步来实现 ","date":"2021-04-26","objectID":"/posts/day23/:0:1","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"类加载中的加载是如何执行的？ 通过类加载器获得二进制字节流 在内存中生成一个代表这个类的 java.lang Class对象，作为方法区这个类的各种数据的访问入口 ","date":"2021-04-26","objectID":"/posts/day23/:0:2","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"类加载中的连接是如何执行的? 验证：确保被加载类的正确性正确性的校验 cafe babe:magic number起校验作用的 准备：负责为类的静态成员分配内存并设置默认初始化值 解析：将类中的符号引用 (跟编译原理相关) 潜替换为直接引用(内存地址) ","date":"2021-04-26","objectID":"/posts/day23/:0:3","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"类加载中的初始化是如何执行的？ 给静态成员变量赋初值，执行静态代码块内容 ","date":"2021-04-26","objectID":"/posts/day23/:0:4","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"类加载时机有哪些? 创建类的实例 (首次创建该类) 对象访问类的静态变量（首次) 调用类的静态方法（首次) 使用反射方式来强制创建某个类或接口对应的 java.lang.Class 对象 加载某个类的子类，会先触发父类的加载 直接使用 java. exe 命令来运行某个主类，也就是执行了某个类的main方法 ","date":"2021-04-26","objectID":"/posts/day23/:0:5","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"类加载中有哪些加载器? Bootstrap ClassLoader 根类加载器负责Java运行时核心类的加载，JDK中JRE的目录下 rt jar Extension ClassLoader 扩展类加载器负责JRE的扩展目录中jar包的加载，在JDK中JRE的目录下ext日录 Sysetm ClassLoader 系统类加载器/应用加载器负责加载自己定义的Java类 ","date":"2021-04-26","objectID":"/posts/day23/:0:6","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"java 在计算机中有哪几种阶段? 源文件阶段 Class 类对象阶段(通过类加载器 ClassLoader 加载) 运行时阶段 ","date":"2021-04-26","objectID":"/posts/day23/:0:7","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"什么是反射? 获取类运行时信息的一种技术，这种技术叫做反射技术 ","date":"2021-04-26","objectID":"/posts/day23/:0:8","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"获取字节码文件有哪些方式? Class.forName(“全限定类名”) 类名.class 对象.getClass（） ","date":"2021-04-26","objectID":"/posts/day23/:0:9","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何用 Class.forName(“全限定类名”) 获取字节码文件？ public class TestDemo { public static void main(String[] args) throws ClassNotFoundException { // 第一种 Class.forName（\"全类名\"） Class personCls = Class.forName(\"idea.Person\"); System.out.println(personCls); } } ","date":"2021-04-26","objectID":"/posts/day23/:0:10","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何用 类名.class 获取字节码文件？ public class TestDemo { public static void main(String[] args) throws ClassNotFoundException { // 第一种 Class.forName（\"全类名\"） Class personCls = Class.forName(\"idea.Person\"); System.out.println(personCls); // 类名.class Class personCls2 = Person.class; System.out.println(personCls2); } } ","date":"2021-04-26","objectID":"/posts/day23/:0:11","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何用 对象.getClass（） 获取字节码文件？ public class TestDemo { public static void main(String[] args) throws ClassNotFoundException { // 第一种 Class.forName（\"全类名\"） Class personCls = Class.forName(\"idea.Person\"); System.out.println(personCls); // 类名.class Class personCls2 = Person.class; System.out.println(personCls2); // 第三种，对象.getClass() Person person = new Person(); Class personCls3 = person.getClass(); System.out.println(personCls3); } } ","date":"2021-04-26","objectID":"/posts/day23/:0:12","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"其结果是什么? 相同 ","date":"2021-04-26","objectID":"/posts/day23/:0:13","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"，会发生什么? 第一种会触发类加载， 第二种不会 ","date":"2021-04-26","objectID":"/posts/day23/:0:14","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"获取所有构造方法? public class TestDemo { public static void main(String[] args) throws ClassNotFoundException { Class personCls = Class.forName(\"idea.Person\"); Constructor[] constructors = personCls.getConstructors(); for (Constructor constructor : constructors) { System.out.println(constructor); } } } ","date":"2021-04-26","objectID":"/posts/day23/:0:15","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何获取所有声明的构造方法? public class TestDemo { public static void main(String[] args) throws ClassNotFoundException { Class personCls = Class.forName(\"idea.Person\"); // 获取所有的构造方法 System.out.println(\"获取所有的构造方法-----\"); Constructor[] declaredConstructors = personCls.getDeclaredConstructors(); for (Constructor constructor : declaredConstructors) { System.out.println(constructor); } } } ","date":"2021-04-26","objectID":"/posts/day23/:0:16","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何获取单个 public 的构造方法? public class TestDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { Class personCls = Class.forName(\"idea.Person\"); // 获取单个public的构造方法 System.out.println(\"获取单个的构造方法-----\"); Constructor constructor = personCls.getConstructor(int.class); System.out.println(constructor); } } ","date":"2021-04-26","objectID":"/posts/day23/:0:17","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何获取单个的构造方法? public class TestDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException { Class personCls = Class.forName(\"idea.Person\"); // 获取单个public的构造方法 System.out.println(\"获取单个的构造方法-----\"); Constructor declaredConstructor = personCls.getDeclaredConstructor(int.class); System.out.println(declaredConstructor); } } ","date":"2021-04-26","objectID":"/posts/day23/:0:18","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"对于这种非public 的构造方法如何进行实例化? 暴力破解 setAccessible(true) 如果为 true, 将忽略 Person.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"利用非 public 构造方法实例化\"); Constructor declaredConstructor = personCls.getDeclaredConstructor(int.class); declaredConstructor.setAccessible(true); Person person = (Person) declaredConstructor.newInstance(10); System.out.println(person); } } Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"利用非 public 构造方法实例化\"); Constructor declaredConstructor = personCls.getDeclaredConstructor(int.class); declaredConstructor.setAccessible(true); Person person = (Person) declaredConstructor.newInstance(10); System.out.println(person); } } ","date":"2021-04-26","objectID":"/posts/day23/:0:19","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何用反射获取所有 public 修饰的成员变量? getFields() Demo2 public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"获取所有 public 的成员 变量--- \"); Field[] fields = personCls.getFields(); for(Field field : fields){ System.out.println(field); } } } Person public class Person { public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } private Person(int age){ this.age = age; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:20","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何用反射获取所有声明成员变量? getDeclaredField Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"获取所有 public 的成员 变量--- \"); Field[] fields = personCls.getDeclaredFields(); for (Field field : fields) { System.out.println(field); } } } Person.java public class Person { int money; public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } private Person(int age) { this.age = age; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:21","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何利用反射 给成员变量 设置值? getDeclaredField getDeclaredFields set Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"给成员变量设置值 与 获取值----\"); Constructor declaredConstructor = personCls.getDeclaredConstructor(); Person o = (Person) declaredConstructor.newInstance(); Field nameField = personCls.getDeclaredField(\"name\"); nameField.set(o, \"王五\"); System.out.println(o.toString()); } } Person.java public class Person { int money; public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } private Person(int age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:22","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何利用反射 获取成员变量 的值? Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"给成员变量设置值 与 获取值----\"); Constructor declaredConstructor = personCls.getDeclaredConstructor(); Person o = (Person) declaredConstructor.newInstance(); Field nameField = personCls.getDeclaredField(\"name\"); nameField.set(o, \"王五\"); System.out.println(o.toString()); String name = (String) nameField.get(o); System.out.println(\"name \" + name); } } Person.java public class Person { int money; public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } private Person(int age) { this.age = age; } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:23","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何利用反射，获取成员所有方法(包括父类的)? Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"获取所有的public的成员方法----\"); Method[] methods = personCls.getMethods(); for (Method method : methods) { System.out.println(method); } } } Person.java public class Person { int money; public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } private Person(int age) { this.age = age; } public void eat (){ System.out.println(\"eat food\"); } private void eat(String s){ System.out.println(\"eat\" + s); } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:24","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何获取获取单个方法? getDeclaredMehtod Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"如何获取单个的方法----\"); Method eatMethod2 = personCls.getDeclaredMethod(\"eat\", String.class); System.out.println(eatMethod2); } } Person.java public class Person { int money; public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } private Person(int age) { this.age = age; } public void eat (){ System.out.println(\"eat food\"); } private void eat(String s){ System.out.println(\"eat\" + s); } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:25","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何使用反射, 并使用成员方法? method.invoke(对象, args) Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException { Class personCls = Class.forName(\"Demo.Person\"); System.out.println(\"如何获取单个的方法----\"); Method eatMethod2 = personCls.getDeclaredMethod(\"eat\", String.class); System.out.println(eatMethod2); // 获取构造方法， 再实例化 Constructor declaredConstructor = personCls.getDeclaredConstructor(); declaredConstructor.setAccessible(true); Object o = declaredConstructor.newInstance(); eatMethod2.invoke(o, \"123\"); } } Person.java public class Person { int money; public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } public Person(int age) { this.age = age; } private void eat (){ System.out.println(\"eat food\"); } public void eat(String s){ System.out.println(\"eat\" + s); } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:26","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何通过反射获取 全类名? getName() Person public class Person { int money; public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } public Person(int age) { this.age = age; } private void eat (){ System.out.println(\"eat food\"); } public void eat(String s){ System.out.println(\"eat\" + s); } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } Demo2 public class Demo2 { public static void main(String[] args) throws ClassNotFoundException { Class personCls = Class.forName(\"Demo.Person\"); String name = personCls.getName(); System.out.println(name); } } ","date":"2021-04-26","objectID":"/posts/day23/:0:27","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何通过反射获取简单的类名? getSimpleName() Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException { Class personCls = Class.forName(\"Demo.Person\"); String name = personCls.getSimpleName(); System.out.println(name); } } Person.java public class Person { int money; public int age; public String name; static { System.out.println(\"init Person\"); } public Person() { } public Person(int age) { this.age = age; } private void eat (){ System.out.println(\"eat food\"); } public void eat(String s){ System.out.println(\"eat\" + s); } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:28","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何利用反射获取成员变量的权限修饰符? getModifiers() Modifier Person.java public class Person { public int money; public int age; public String name; public Person() { } public Person(int age) { this.age = age; } private void eat (){ System.out.println(\"eat food\"); } public void eat(String s){ System.out.println(\"eat\" + s); } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } Demo2 public class Demo2 { public static void main(String[] args) throws ClassNotFoundException { Class personCls = Class.forName(\"Demo.Person\"); Field[] declaredFields = personCls.getDeclaredFields(); System.out.println(declaredFields.length); System.out.println(declaredFields[0].getName()); int modifiers = declaredFields[0].getModifiers(); System.out.println(modifiers); String s = Modifier.toString(modifiers); System.out.println(s); } } ","date":"2021-04-26","objectID":"/posts/day23/:0:29","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何通过反射，获取成员变量的类型? getType() Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException { Class personCls = Class.forName(\"Demo.Person\"); Field[] declaredFields = personCls.getDeclaredFields(); System.out.println(declaredFields.length); System.out.println(declaredFields[0].getType().getName()); } public class Person { public int money; public int age; public String name; public Person() { } public Person(int age) { this.age = age; } private void eat (){ System.out.println(\"eat food\"); } public void eat(String s){ System.out.println(\"eat\" + s); } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:30","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何通过反射，获取成员方法的返回值类型? getReturnType() Demo2.java public class Demo2 { public static void main(String[] args) throws ClassNotFoundException { Class personCls = Class.forName(\"Demo.Person\"); // 获取方法的返回值类型 Method[] declaredMethods = personCls.getDeclaredMethods(); System.out.println(declaredMethods.length); System.out.println(declaredMethods[0]); Class returnType = declaredMethods[0].getReturnType(); // 获取方法的返回值类型 System.out.println(returnType); System.out.println(returnType.getSimpleName()); } } Person.java public class Person { public int money; public int age; public String name; public Person() { } public Person(int age) { this.age = age; } private void eat (){ System.out.println(\"eat food\"); } public void eat(String s){ System.out.println(\"eat\" + s); } @Override public String toString() { return \"Person{\" + \"money=\" + money + \", age=\" + age + \", name='\" + name + '\\'' + '}'; } } ","date":"2021-04-26","objectID":"/posts/day23/:0:31","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"获取成员方法参数? ","date":"2021-04-26","objectID":"/posts/day23/:0:32","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"获取父类? ","date":"2021-04-26","objectID":"/posts/day23/:0:33","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"获取接口? ","date":"2021-04-26","objectID":"/posts/day23/:0:34","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何反编译成员变量? ","date":"2021-04-26","objectID":"/posts/day23/:0:35","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何反编译成员方法? ","date":"2021-04-26","objectID":"/posts/day23/:0:36","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"反射一般有什么应用场景? 用于框架中 Object–relational mapping ","date":"2021-04-26","objectID":"/posts/day23/:0:37","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"通过反射调用默认无参的构造方法? 直接通过 NewInstalnce 可以要通过，默认的方法 ","date":"2021-04-26","objectID":"/posts/day23/:0:38","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"什么是注释? 单行注释: // 多行注释: /* */ 文档注释: /** */ 注释是给程序员看的，不参与编译 ","date":"2021-04-26","objectID":"/posts/day23/:0:39","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"什么是注解？ 与 接口，类 是同一级别的 理解为一个标签 参与编译 语法 权限修饰符 @interface 注解名称 { } ","date":"2021-04-26","objectID":"/posts/day23/:0:40","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"什么是注解体? 权限修饰符 @interface 注解名称 { // 注解体 属性类型 属性名称(); } 注意(属性类型): 基本数据类型 String 类型 Class 类型 枚举类型(Enum) 注解类型 以及以上类型的数组 ","date":"2021-04-26","objectID":"/posts/day23/:0:41","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何使用注解? ","date":"2021-04-26","objectID":"/posts/day23/:0:42","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"使用注解创建学生对象? ","date":"2021-04-26","objectID":"/posts/day23/:0:43","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"什么是注解处理器？ 用注解来判断 isAnnotationPresent() 忽略语法检查 DeclaredField ","date":"2021-04-26","objectID":"/posts/day23/:0:44","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"什么是元注解? 元注解: 描述注解的注解 常用的元注解 @Retention 元注解 RetentionPolicy.RUNTIME RetentionPolicy.CLASS RetentionPolicy.SOURCE ","date":"2021-04-26","objectID":"/posts/day23/:0:45","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"什么是元数据? 修饰数据的数据 ","date":"2021-04-26","objectID":"/posts/day23/:0:46","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"注解的3种保留级别? 和 java 程序一致，注解有3种保留级别: SOURCE: 注解将被编译器丢弃 (class 文件中没有) CLASS: 注解在 class 文件中可用，但会被 JVM 丢弃(内存没有) RUNTIME: JVM在运行时，也会保留注解信息 ","date":"2021-04-26","objectID":"/posts/day23/:0:47","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"连接数据库？ ###　注解与配置文件的比较 ","date":"2021-04-26","objectID":"/posts/day23/:0:48","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"什么是显式的内存管理? 由程序员去管理内存 malloc() free() 可能出现的问题 野指针 内存泄漏 ","date":"2021-04-26","objectID":"/posts/day23/:0:49","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"隐式的内存管理 ","date":"2021-04-26","objectID":"/posts/day23/:0:50","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"谁是垃圾? 引用计数算法 根搜索算法 ","date":"2021-04-26","objectID":"/posts/day23/:0:51","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"如何回收垃圾? 标记清除算法 它会产生垃圾碎片，如果要创建一个数组，但是无法创建一个连续的存储空间 标记复制算法 一次性回收大片的连续空间 不会产生内存碎片 如果说有少量存活对象，复制起来很快，适用于少量对象存活的情况 但是，内存利用率低 如果有大量对象存活，就需要复制大量对象，效率就低了 标记整理算法(Mark Compact) 分带收集算法 死的快的用 标记复制算法 ","date":"2021-04-26","objectID":"/posts/day23/:0:52","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"何时回收垃圾？ idle 休眠 heap space 堆内存 System.gc() ","date":"2021-04-26","objectID":"/posts/day23/:0:53","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"GC 相关概念? ","date":"2021-04-26","objectID":"/posts/day23/:0:54","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["王道"],"content":"内存泄露与内存溢出的关系 ? ","date":"2021-04-26","objectID":"/posts/day23/:0:55","tags":["java"],"title":"Day23","uri":"/posts/day23/"},{"categories":["鸟哥的私房菜"],"content":"写 Shell Script 的规则是什么? 第一行写 #!/bin/bash 来宣告这个文件内的语法使用的是 bash 语法 程序内容的说明: 内容与功能 版本信息 作者与联络方式 创建日期 历史记录 主要环境变量的宣告 PATH 与 LANG 执行成果告知 exit 0 当下达 echo $? 则可得到0的值 ","date":"2021-04-24","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/:0:1","tags":["linux"],"title":"Linux第十二章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"echo -e 会发生什么? e enable interpretation of backslash escapes ","date":"2021-04-24","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/:0:2","tags":["linux"],"title":"Linux第十二章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"以 read 指令的用途，撰写一个 script, 他可以让使用者输入 1. first name 与 2. last name, 最后并且在屏幕上显示 “Your full name is:” 的内容? #!/bin/bash # Program: # User input his first name adn last name. Program shows his full name. # Histroy: # 2015/07/16 feng First relase PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl export PATH read -p \"Please input your first name: \" firstname # 提示使用者输入 read -p \"Please input your last name: \" lastname # 提示使用者输入 echo -e \"\\nYour full name is: ${firstname}${lastname}\" # 结果由屏幕输出 -p prompt print the prompt text before requesting the input from the standard input stream without a character. ","date":"2021-04-24","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/:0:3","tags":["linux"],"title":"Linux第十二章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何创建三个空文件，文件名最开头由使用者输入决定，假设使用者输入 filename 好了, 我想以前天，昨天，今天的日期来创建这些文件? #!/bin/bash # Program: # Program creates three files, which named by user's input and date command. # History: # 2015/07/16 feng First release PATH=/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl export PATH # 1. 让使用者输入文件名称，并取得 fileuser 这个变量 echo -e \"I will use 'touch' command to create 3 files\" read -p \"Please intput your filename: \" fileuser # 2. 利用变量功能，避免使用者随意按 Enter filename=${fileuser:-\"filename\"} # 3. 开始利用 data 指令来取得所需要的文件名 date1=$(date --date='2 days ago' +%Y%m%d) date2=$(date --date='1 days ago' +%Y%m%d) date3=$(date +%Y%m%d) file1=${filename}${date1} file2=${filename}${date2} file3=${filename}${date3} # 4. 将文件名创建 touch \"${file1}\" touch \"${file2}\" touch \"${file3}\" ","date":"2021-04-24","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/:0:4","tags":["linux"],"title":"Linux第十二章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"},{"categories":["王道"],"content":"什么是计算机网络 物理互联 软件支持 目的: 资源共享 + 信息传递 ","date":"2021-04-23","objectID":"/posts/day22/:0:1","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"什么是网络编程? 处于 互联网络 上不同计算机 程序间 的数据交换 ","date":"2021-04-23","objectID":"/posts/day22/:0:2","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"OSI参考模型有几层? 分别是什么? 7 层 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 物联网淑惠试用 ","date":"2021-04-23","objectID":"/posts/day22/:0:3","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"物理层主要关注什么? 关注一条通信信道上传输原始比特(01) 其功能是确保当一方发送了比特1, 另一方收到的是比特1, 而不是0 ","date":"2021-04-23","objectID":"/posts/day22/:0:4","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"物理层的所涉及到的典型问题是什么? 用什么样的电信号表示0和1 一个 bit 持续多少纳秒 传输是否可以在两个方向同时进行 初始连接如何建立，传输结束后之后如何撤销连接 规定一个特殊的电信号将普通的数据信号分开来 ","date":"2021-04-23","objectID":"/posts/day22/:0:5","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"数据链路层主要关注什么? 将一个原始的传输设施转变成一条 没有漏检传输错误 的传输线路 检查数据是否发生差错 ","date":"2021-04-23","objectID":"/posts/day22/:0:6","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"数据链路层的主要功能是什么? 成帧 差错控制(帧校验，确认 + 超时重传) 流量控制 广播式网络的数据链路层, 还有介质访问控制问题 介质访问控制 保证只有一台计算机在发送数据 ","date":"2021-04-23","objectID":"/posts/day22/:0:7","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"网络层需要解决的核心功能是什么? 如何将数据包从源端路由到接收端 ","date":"2021-04-23","objectID":"/posts/day22/:0:8","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"什么是端到端的通信? 应用程序所对应的 进程间 的通信 ","date":"2021-04-23","objectID":"/posts/day22/:0:9","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"什么是端口? 整数值 在一台主机中代表一个唯一的进程标志 ","date":"2021-04-23","objectID":"/posts/day22/:0:10","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"传输层主要考虑的是什么? 向上层提供端到端的通信服务，屏蔽底层的通信细节 ","date":"2021-04-23","objectID":"/posts/day22/:0:11","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"传输层有哪些功能? 提供应用进程之间的逻辑通信 复用和分用 向上层提供不同类型的通信服务 TCP , UDP ","date":"2021-04-23","objectID":"/posts/day22/:0:12","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"什么 TCP 协议? 面向连接的可靠的通信服务（如: 打电话） Transmission Control Protocol ","date":"2021-04-23","objectID":"/posts/day22/:0:13","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"什么 UDP 协议? 无连接的不可靠的通信服务(如: 写信) User Datagram Protocol ","date":"2021-04-23","objectID":"/posts/day22/:0:14","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"若要使用 UDP 协议进行传输，有哪几步? 发送端 建立 udp 的 socket 对象 将要发送的数据封装成数据包 通过 udp 的 socket 对象， 将数据包发送出 释放资源 接收端 建立 udp 的 socket 对象 创建用于接收数据的数据报包，通过 socket 对象的 receive 方法接收数据 通过数据包对象的功能来完成对接受到数据进行解析 可以对资源进行释放 ","date":"2021-04-23","objectID":"/posts/day22/:0:15","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"若要使用 TCP 协议进行传输，有哪几步? 客户端 建立客户端的 Socket 服务， 并明确要连接的服务器 如果对象建立成功，就表明已经建立了数据传输的通道，就可以在该通道通过IO进行数据的读取和写入 根据需要从socket对象中获取输入, 或输出流 向流中读取或写入数据， 释放资源 (接受端)服务端 创建 Serversocket 对象， 在指定端口，监听客户端连接请求 收到客户端连接请求后，建立Socket连接 如果连接建立成功，就表明已经 了数据传输的通道，就可以在该通道通过IO进行数据的读取和写入 从 socket 中根据需要获取输入，或输出流，根据需要向流中写入数据或从流中读数据，释放资源 ","date":"2021-04-23","objectID":"/posts/day22/:0:16","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"如何实现客户端(tcp) socket? public class Socket extends Object implements Closeable This class implements client sockets (also called just “sockets”). A socket is an endpoint for communication between two machines. Constructor Socket(String host, int port) Creates a stream socket and connects it to the specified port number on the named host. Method InputStream getInputStream() Returns an input stream for this socket. OutputStream getOutputStream() Returns an output stream for this socket. public class Client { public static void main(String[] args) throws IOException { // 建立客户端的 Socket 服务， 并明确要连接服务器 // Socket(String host, int port) Socket socket = new Socket(\"127.0.0.1\", 8888); // 如果对象建立成功，就表明已经建立了数据传输的通道 // 就可以在该通道通过IO进行数据的读取和写入 // 想服务端发送数据 OutputStream out = socket.getOutputStream(); out.write(\"Hello tcp\".getBytes()); // 释放资源 socket.close(); } } ","date":"2021-04-23","objectID":"/posts/day22/:0:17","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"如何实现接受端(Tcp) socket? public class ServerSocket extends Object implements Closeable This class implements server sockets. A server socket waits for requests to come in over the network. It performs some operation based on that request, and then possibly returns a result to the requester. Construct ServerSocket(int port) Creates a server socket, bound to the specified port. method Socket accept() Listens for a connection to be made to this socket and accepts it. public class Server { public static void main(String[] args) throws IOException { // 创建 ServerSocket 对象， 在指定端口，监听客户端连接请求 ServerSocket serverSocket = new ServerSocket(8888); // 收到客户端连接请求后，建立socket连接 Socket socket = serverSocket.accept(); // 从 socket 中根据需要获取输入，或输出流 InputStream in = socket.getInputStream(); // 解析数据 byte[] bytes = new byte[1024]; int readCount = in.read(bytes); String s = new String(bytes, 0, readCount); System.out.println(s); socket.close(); serverSocket.close(); } } 先运行服务端 ","date":"2021-04-23","objectID":"/posts/day22/:0:18","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"如何实现TCP, 客户端发送数据，服务端给予反馈? Client public class Client { public static void main(String[] args) throws IOException { // 建立客户端 Socket 服务， 并明确要连接的服务器 Socket socket = new Socket(\"127.0.0.1\", 8888); // 如果对象建立成功，就表明已经建立了数据传输的通道 // 向服务端发送数据 OutputStream out = socket.getOutputStream(); out.write(\"hello tcp\".getBytes()); // 接受来自客户端的反馈 // 获取输入流 InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int readCount = in.read(bytes); String s = new String(bytes, 0, readCount); System.out.println(s); // 释放资源 socket.close(); } } Server public class Server { public static void main(String[] args) throws IOException { // 创建 Serversocket 对象， 在指定端口，监听客户端连接请求 ServerSocket serverSocket = new ServerSocket(8888); // 收到客户端连接请求后， 建立 socket 连接 Socket socket = serverSocket.accept(); // 从 socket 中根据需要获取输入，或输出流 InputStream in = socket.getInputStream(); // 解析数据 byte[] bytes = new byte[1024]; int readCount = in.read(bytes); String s = new String(bytes, 0, readCount); System.out.println(s); // 给客户端一个反馈信息 OutputStream out = socket.getOutputStream(); out.write(\"好你妹\".getBytes()); socket.close(); serverSocket.close(); } } ","date":"2021-04-23","objectID":"/posts/day22/:0:19","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"如何把客户端文件上传到服务器? Client 创建 Socket 对象 读取本地文件 获取输出流 public class Client { public static void main(String[] args) throws IOException { // 创建 Socket 对象 Socket socket = new Socket(\"127.0.0.1\", 11111); // 读取本地文件 FileInputStream in = new FileInputStream(\"a.txt\"); // 获取输出流 OutputStream out = socket.getOutputStream(); byte[] bytes = new byte[1024]; int readCount; while ((readCount = in.read(bytes)) != -1) { out.write(bytes, 0, readCount); } in.close(); socket.close(); } } Server 创建输出流对象， 写入服务器 public class Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(11111); Socket socket = serverSocket.accept(); // 创建输出流对象 FileOutputStream out = new FileOutputStream(\"b.txt\"); InputStream in = socket.getInputStream(); // 写入服务器 int readCount; byte[] bytes = new byte[1024]; while ((readCount = in.read(bytes)) != -1) { out.write(bytes, 0, readCount); } // 关闭流 out.close(); socket.close(); serverSocket.close(); } } ","date":"2021-04-23","objectID":"/posts/day22/:0:20","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"如何实现 DatagramSocket(udp) 发送端? public class DatagramSocket extends Object implements Closeable This class represents a socket for sending and receiving datagram packets. public final class DatagramPacket extends Object This class represents a datagram packet. constructor ： DatagramSocket(int port) Constructs a datagram socket and binds it to the specified port on the local host machine. method void send(DatagramPacket p) Sends a datagram packet from this socket. DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port) Constructs a datagram packet for sending packets of length length with offset ioffsetto the specified port number on the specified host. 发送端 public class Sender { public static void main(String[] args) throws IOException { // 1. 将立 udp 的 socket 对象 DatagramSocket datagramSocket = new DatagramSocket(8888); // 2. 将要发送的数据封装成数据包 String s = \"hello udp\"; byte[] bytes = s.getBytes(); InetAddress targetIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length, targetIP, port); // 3. 将数据包发送出 datagramSocket.send(packet); // 4. 释放资源 datagramSocket.close(); } } ","date":"2021-04-23","objectID":"/posts/day22/:0:21","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"如何实现 DatagramSocket(udp) 接受端? public class DatagramSocket extends Object implements Closeable This class represents a socket for sending and receiving datagram packets. public final class DatagramPacket extends Object This class represents a datagram packet. method DatagramPacket(byte[] buf, int offset, int length) Constructs a DatagramPacket for receiving packets of length length, specifying an offset into the buffer. void receive(DatagramPacket p) Receives a datagram packet from this socket. public class Receiver { public static void main(String[] args) throws IOException { // 1. 建立 udp 的 socket 对象 DatagramSocket datagramSocket = new DatagramSocket(9999); // 2. 创建用于接收数据的数据报包，通过 socket 对象的 receive 方法接收数据 byte[] bytes = new byte[1024]; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length); datagramSocket.receive(packet); // 3. 通过数据包对象的功能来完成对接受到数据进行解析 byte[] data = packet.getData(); int offset = packet.getOffset(); int length = packet.getLength(); String s = new String(data, offset, length); System.out.println(s); // 4. 对资源进行释放 datagramSocket.close(); } } ","date":"2021-04-23","objectID":"/posts/day22/:0:22","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"接受端与发送端的工具类实现? public class NetworkUtils { public static DatagramPacket getSenderPacket(String targetIp, int port, String message) throws UnknownHostException { // 创建用于发送的数据报包 byte[] bytes = message.getBytes(); InetAddress ip = InetAddress.getByName(targetIp); DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length, ip, port); return packet; } // 创建用于接受的数据报包 public static DatagramPacket getReceiverPacket() { byte[] bytes = new byte[1024]; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length); return packet; } // 解析数据 public static String parsePacket(DatagramPacket packet) { byte[] data = packet.getData(); int offset = packet.getOffset(); int length = packet.getLength(); String s = new String(data, offset, length); return s; } } ","date":"2021-04-23","objectID":"/posts/day22/:0:23","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"接受端与发送端都可发送和接受数据? 发送端 发送 和 接收 退出条件 接受端 ","date":"2021-04-23","objectID":"/posts/day22/:0:24","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"会话层主要功能是什么? 记录谁发了消息，记录检查点 ","date":"2021-04-23","objectID":"/posts/day22/:0:25","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"表示层主要功能是什么? 处理两个通信系统中交换信息的表示方式 编码和表示方法 数据是否压缩，数据的加密和解密使用何种加密算法 ","date":"2021-04-23","objectID":"/posts/day22/:0:26","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"应用层主要功能是什么? 包含了用户通常所需要的各种协议 Http协议 ","date":"2021-04-23","objectID":"/posts/day22/:0:27","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"IP地址是怎么组成的? 网络号码 + 主机地址(唯一的) ","date":"2021-04-23","objectID":"/posts/day22/:0:28","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"A类， B类， C类, D类, E类,IP地址是如何分类的? A类: 第一段号码为网络号码， 剩下的三段号码为本地计算机的号码 B类: 前二段号码为网络号码， 剩下的二段号码为本地计算机的号码 C类: 前三段号码为网络号码， 剩下的一段号码为本地计算机的号码 D类: (组播的目的地址) E类: (保留地址) ","date":"2021-04-23","objectID":"/posts/day22/:0:29","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"什么是网络地址，广播地址? 对于A, B, C 不同类型的网络地址，都包含两个特殊的ip地址 网络地址: 表示该类网络本身 xxx.xxx.xxx.0 广播地址: 代表的是当前这个网络中，所有的主机 xxx.xxx.xxx.255 ","date":"2021-04-23","objectID":"/posts/day22/:0:30","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"哪个是回环地址? 127.0.0.1 用于测试本机的网络是否有问题 ","date":"2021-04-23","objectID":"/posts/day22/:0:31","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"两个主机之间通信的原理图是什么样的? ","date":"2021-04-23","objectID":"/posts/day22/:0:32","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"config.properties (key-value)一般用于存储哪些东西? 数据库配置 开发数据库 测试数据库 线上数据库(生产环境) 第三方配置信息 APP Key ","date":"2021-04-23","objectID":"/posts/day22/:0:33","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"如何读取 config.properties? public class Properties extends Hashtable\u003cObject,Object\u003e The Properties class represents a persistent set of properties. The Properties can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string. Constructors Properties() Creates an empty property list with no default values. Method void load(InputStream inStream) Reads a property list (key and element pairs) from the input byte stream. void load(Reader reader) Reads a property list (key and element pairs) from the input character stream in a simple line-oriented format. String getProperty(String key) Searches for the property with the specified key in this property list. ","date":"2021-04-23","objectID":"/posts/day22/:0:34","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"如何读取 config.properties(实现编码一致)? public class Properties extends Hashtable\u003cObject,Object\u003e The Properties class represents a persistent set of properties. The Properties can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string. void load(InputStream inStream) Reads a property list (key and element pairs) from the input byte stream. String getProperty(String key) Searches for the property with the specified key in this property list. public class Demo2 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new InputStreamReader(new FileInputStream(\"config.properties\"), \"GBK\")); String user = properties.getProperty(\"user\"); System.out.println(user); } } ","date":"2021-04-23","objectID":"/posts/day22/:0:35","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"实现自动回复的机器人? Sender Receiver ","date":"2021-04-23","objectID":"/posts/day22/:0:36","tags":["java"],"title":"Day22","uri":"/posts/day22/"},{"categories":["王道"],"content":"同步方法中的锁对象是什么? 同步代码块中 任意java对象 任意方法中 this 静态方法中 字节码文件对象（.clsss） 补充代码 ","date":"2021-04-23","objectID":"/posts/day21/:0:1","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"为什么在同步代码块中可以放一个任意的对象? 因为 java 当中所有对象， 内部都存在一个 标志位，表示加锁和解锁的状态 其实锁对象，就是充当锁的角色 所谓的加锁解锁，其实就是 设置锁对象的标志位，来表示加锁解锁的状态 ","date":"2021-04-23","objectID":"/posts/day21/:0:2","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"当某个线程执行到同步代码块时，遇到加锁或无锁时会怎么处理? 当锁对象处于未加锁状态， jvm 就会设置锁对象的标志位(加锁)， 并在锁对象中记录，是哪个线程加的锁. 加锁成功， 执行同步代码块中的代码。 如果锁对象 已经被加锁, 且加锁线程不是当前线程，系统会让当前线程处于阻塞状态(等着)， 直到加锁线程，执行完了对共享变量的组操作，并释放锁。 ","date":"2021-04-23","objectID":"/posts/day21/:0:3","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"加锁线程何时释放锁? 当加锁线程，执行完了同步代码块中的代码(对共享变量的一组操作)，在退出同步代码块之前, jvm 自动清理锁对象的标志位，将锁对象变成未上锁状态(释放锁) ","date":"2021-04-23","objectID":"/posts/day21/:0:4","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"如何使用 Lock 锁住对象? 定义一把锁 Lock lock = new ReentrantLock(); 美[ˌriˈɛntrənt] public ReentrantLock() Creates an instance of ReentrantLock. THis is equivalent to using ReentrantLock(false). 获取锁 lock.lock(); void lock() Acquires the lock. 释放锁 lock.unlock; void unlock() Releases the lock. ","date":"2021-04-23","objectID":"/posts/day21/:0:5","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"Lock 和 synchronized 的区别? synchronized 会同步阻塞 synchronized 只提供了用来 模拟锁状态的标志位 (加锁和释放锁) 加锁和释放锁的行为，都是由 jvm 隐式完成(和 synchronized 锁对象没有关系) 所以 synchronized 锁对象 不是一把完整的锁 Lock 它代表的是完整的锁 Lock对象， 它如果要实现加锁和释放锁，不需要 synchronized 关键字配合，它自己就可以完成 Lock(接口): lock() 加锁 unlock 释放锁 ","date":"2021-04-23","objectID":"/posts/day21/:0:6","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"什么是同步与异步? 同步与异步描述的是被调用者的 如 A 调用 B: 如果是 同步 ，B 在接到 A 调用后，会立即执行要做的事。 A 的本次调用可以得到结果. 如果是 异步 ，B 在接到 A 调用后，不保证会立即执行要做的事，但是保证会去做， B 在做好了之后会通知 A。 A的本次调用得不到结果， 但是 B 执行完之后会通知 A . ","date":"2021-04-23","objectID":"/posts/day21/:0:7","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"什么是死锁? 2 个或以上的线程争抢资源，造成互相等待的现象 ","date":"2021-04-23","objectID":"/posts/day21/:0:8","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"在 java 中怎样的代码容易产生死锁? 一般出现在 同步代码块嵌套 ","date":"2021-04-23","objectID":"/posts/day21/:0:9","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"解决死锁的方法有哪些? 方式一 更改加锁顺序 方式二: 将该步骤变成原子操作 最外层再加一层操作 ","date":"2021-04-23","objectID":"/posts/day21/:0:10","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"什么是生产者消费者模型? ","date":"2021-04-23","objectID":"/posts/day21/:0:11","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"线程间通信有哪些API? wait() 阻止自己 notify() 通知别人 notifyAll() 通知所有的人 ","date":"2021-04-23","objectID":"/posts/day21/:0:12","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"线程间通信的 wait() api 是干什么的? public final void wait throws InterruptedException 阻塞功能: 当在某线程中，对象上 .wait(), 在哪个线程中调用 wait(), 导致哪个线程处于阻塞状态 当某线程，因为调用执行某对象的 wait(), 而处于阻塞状态，我们说，该线程在该对象上阻塞 唤醒条件 当某线程，因为某对象A的 wait(), 而处于阻塞状态时，如果要唤醒该线程，只能在其他线程中，再同一个对象 (即对象A) 上调用其 notify() 或 notifyAll() 即在线程的阻塞对象上，调用 notify 或 notifyAll 方法，才能唤醒，在该对象上阻塞的线程 运行条件 当前线程必须拥有此对象 监视器 监视器: 指 synchronized 代码块中的锁对象 如果不在同步代码块中调用就会就会出现 IllegalMonitorStateException 执行特征 该线程释放对监视器的所有权 等待(阻塞) ","date":"2021-04-23","objectID":"/posts/day21/:0:13","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"Thread 的 sleep 方法， 执行时会丢失监视器的所属权吗? 不会 ","date":"2021-04-23","objectID":"/posts/day21/:0:14","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"Object 的 wait 方法， 执行时会丢失监视器的所属权吗? 会 ","date":"2021-04-23","objectID":"/posts/day21/:0:15","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"Thread.sleep VS Object.wait()? 所属不同: sleep 定义在Thread类，静态方法 wait 定义在Object类中，非静态方法 唤醒条件不同 sleep 休眠时间到 wait 在其他线程中，在同一个锁对象上，调用了 notify 或 notifyAll 方法 使用条件不同 sleep 没有任何前提条件 wait 必须是当前线程，持有锁对象，锁对象上调用 wait() 休眠时，对锁对象的持有，不同: sleep 处于阻塞状态的时候，在阻塞的时候不会放弃对锁的持有 wait 处于阻塞的时候，会放弃对象持有3 ","date":"2021-04-23","objectID":"/posts/day21/:0:16","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"notify() api 是干什么的? public final void notify() 唤醒在此对象监视器上等待的单个线程 如果所有线程都在此对象上等待 则 会选择唤醒其中一个线程， 选择是任意性的 ","date":"2021-04-23","objectID":"/posts/day21/:0:17","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"产包子实战？ 生产者 消费者 蒸笼 demo ","date":"2021-04-23","objectID":"/posts/day21/:0:18","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"如何产生随机数? Random random = new Random(); // nextInt(int bound) [0, bound] int i = random.nextInt(foods.length); ","date":"2021-04-23","objectID":"/posts/day21/:0:19","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"只执行一次? ","date":"2021-04-23","objectID":"/posts/day21/:0:20","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"同步方法 Box Box ","date":"2021-04-23","objectID":"/posts/day21/:0:21","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"为什么多个生产者，消费者的时候，会出现卡顿？ ","date":"2021-04-23","objectID":"/posts/day21/:0:22","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"什么是 虚假唤醒? 唤醒了不应该被唤醒的线程 ","date":"2021-04-23","objectID":"/posts/day21/:0:23","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"为什么 wait,notify, 为啥不定义在 Thread 当中? 因为锁对象可以是任意java对象 ","date":"2021-04-23","objectID":"/posts/day21/:0:24","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"完整的线程转换图是什么? ","date":"2021-04-23","objectID":"/posts/day21/:0:25","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"为什么会有线程池? ","date":"2021-04-23","objectID":"/posts/day21/:0:26","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"三种线程池? 带缓存的线程池 newFixedThreadPod ","date":"2021-04-23","objectID":"/posts/day21/:0:27","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"如何实现 newFixedThreadPod? ","date":"2021-04-23","objectID":"/posts/day21/:0:28","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"? 有什么区别? shutdownNow 队列中也执行 shutdownNow 队列中的不执行 ","date":"2021-04-23","objectID":"/posts/day21/:0:29","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"如何实现 Callable? ","date":"2021-04-23","objectID":"/posts/day21/:0:30","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"Future 是干什么的? ","date":"2021-04-23","objectID":"/posts/day21/:0:31","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"Runnable VS Callable ","date":"2021-04-23","objectID":"/posts/day21/:0:32","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"FutureTask 如何使用? ","date":"2021-04-23","objectID":"/posts/day21/:0:33","tags":["java"],"title":"Day21","uri":"/posts/day21/"},{"categories":["王道"],"content":"What’s thread and multithreaded? Individual programs will appear to do multiple tasks at the same time. Each task is executed in a thread, which is short for thread of control. Programs that can run more than one thread at once are said to be multithreaded ","date":"2021-04-21","objectID":"/posts/20_thread/:0:1","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"What’s the difference between multiple processes and multiple threads? each process has a complete set of its own variable thread share the same data. Shared variables make communication between threads more efficient and easier to program than interprocess communication. on some operating systems, threads are more “lightweight” than process - it takes less overhead to create and destroy individual threads than it does to launch new processes. ","date":"2021-04-21","objectID":"/posts/20_thread/:0:2","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何实现程序睡眠3秒? TimeUnit.SECONDS.sleep(3)； public class TestSleep { static boolean flag = true; public static void main(String[] args) throws InterruptedException { sayHelloRecycling(); } private static void sayHelloRecycling() throws InterruptedException { while(flag){ System.out.println(\"你好\"); TimeUnit.SECONDS.sleep(3); } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:3","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是进程? 操作系统进行 资源分配与调度 的基本单位. 一个正在运行的程序，软件都可以称为进程 进程之间是互不干扰的 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:4","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是线程? CPU 进行 资源分配与调试 的基本单位，从执行路径的角度来看在，每一条执行路径都是1个线程 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:5","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"进程和线程的关系？ 线程依赖于进程而存在 线程之间是共享进程资源的 一个进程可以有 最少一个线程 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:6","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是串行, 并行，并发? 串行: 一个任务接一个任务 按顺序执行 并行: 在一个 时间点 上，多个任务同时执行 并发: 在一个 时间段 上， 多个任务同时执行 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:7","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是单道批处理? 单道: 在整个操作系统中，同一时间，内存中只有一个程序 只能是上一个程序运行完，下一个程序才能开始运行 批处理: 在程序运行过程中，不会有任何响应，直到程序运行结束 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:8","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是多道批处理? 多道： 在操作系统中，同时内存中，可以有多个应用程序，在运行, 这样一来，一旦某个应用程序， 不需要使用cpu的计算功能.操作系统就会把cpu计算时间，分配给内存中的其他应用程序来计算，这样一来，cpu的资源利用率就大提高了 多道批处理: 当应用程序，占用cpu执行时间，，这个应用才算真正的执行, 在多道批处理系统中，多个应用程序，交替执行，看起来好像多个应用程序在\"同时\"运行. ","date":"2021-04-21","objectID":"/posts/20_thread/:0:9","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么有了进程还要有线程? 进程的上下文切换: 保护现场 （值， 寄存器的状态保存到一个地址） 恢复现场 （恢复寄存器的值， 寄存器的状态） 为了提高切换的效率，引入了 线程(轻量进程) 每一个线程负责一个子任务 线程上下文线程中切换的代价要小 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:10","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Java 程序运行程序的原理是什么？ 运行 Java 命令会创建 jvm 进程 jvm 进程会去创建一个 main 线程 3。 回到 main 线程中 执行 main() 方法 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:11","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何验证 jvm 是单线程还是多线程的? 有GC线程回收 所以 jvm 是多线程的, 至少还有一个垃圾回收线程 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:12","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"How to procedure for running a task in a separate thread ? Place the code for the task into the run method of a class that implements the Runnable interface Since Runnable is a functional interface, could make an instance with lambda expression Runnable r = () -\u003e {task code}; Construct a Thread object from the Runnable: var t = new Thread(r); Start the thread t.start(); ","date":"2021-04-21","objectID":"/posts/20_thread/:0:13","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"When I procedure for running a task in a separate thread, why not call the run to start thread ? Calling the run method directly merely executes the task in the same thread – no new thread is started. ","date":"2021-04-21","objectID":"/posts/20_thread/:0:14","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"How to define a thread by forming a subclass of the Thread class? class MyThread extends Thread{ public void run(){ task code } } This approach is no longer recommended. You should decouple the task that is to be run in parallel from the mechanism of running it. If you have many tasks, it is too expensive to create a separate thread for each of them. Instead, you can use a thread pool. ","date":"2021-04-21","objectID":"/posts/20_thread/:0:15","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么要重写 Thread 类中的 run 方法? 只有 Thread run() 方法中的代码， 都会执行在 子线程 中 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:16","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"同一个 Thread 或 Thread 子类可以被启动多次吗? 不可以， 同一个 Thread 或 Thread 子类 只能启动一次 可以创建多个线程对象，并启动这些线程对象 public class Demo { public static void main(String[] args) { System.out.println(\"main start\"); // 创建子类对象 MyThread myThread = new MyThread(); myThread.start(); myThread.start(); } } class MyThread extends Thread { @Override public void run() { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } for (int i = 0; i \u003c 10; i++) { System.out.println(i); } call(); } public static void call() { System.out.println(\"call\"); } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:17","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"要想让代码在子线程中运行，只能将代码在 run 方法体中吗? 一个方法 ，被哪个线程中的代码调用，被调用的方法，就运行在，调用它的线程中 public class Demo { public static void main(String[] args) { System.out.println(\"main start\"); // 创建子类对象 MyThread myThread = new MyThread(); myThread.start(); } } class MyThread extends Thread { @Override public void run() { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } for (int i = 0; i \u003c 10; i++) { System.out.println(i); } call(); } public static void call() { System.out.println(\"call\"); } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:18","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何获取子线程名称? getName public final String getName() Returns this thread’s name public class Thread1 { public static void main(String[] args) { for (int i = 0; i \u003c 10; i++) { System.out.println(i); } MyThread myThread = new MyThread(); myThread.start(); } } class MyThread extends Thread { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"------\" + i); } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:19","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何获取主线程名称? currentThread public static Thread currentThread() Returens a reference to the currently executing thread object. public class Thread1 { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"王冰冰\"); myThread.start(); Thread thread = Thread.currentThread(); String name = thread.getName(); for (int i = 0; i \u003c 10; i++) { System.out.println(name + \"---------\" + i); } } } class MyThread extends Thread { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"------\" + i); } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:20","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何设置线程名称? setName public final void setName(String name) Changes the name of this thread to be equal to the argument name. public class Thread1 { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"王冰冰\"); myThread.start(); Thread thread = Thread.currentThread(); String name = thread.getName(); for (int i = 0; i \u003c 10; i++) { System.out.println(name + \"---------\" + i); } } } class MyThread extends Thread { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"------\" + i); } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:21","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何设置主线程名称? 方法一(通过 CurrentThread): public class Thread1 { public static void main(String[] args) { MyThread myThread = new MyThread(); myThread.setName(\"王冰冰\"); myThread.start(); Thread thread = Thread.currentThread(); thread.setName(\"长风\"); String name = thread.getName(); for (int i = 0; i \u003c 10; i++) { System.out.println(name + \"---------\" + i); } } } class MyThread extends Thread { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"------\" + i); } } } 方法二(用构造方法): Thread(String name) Allocates a new Thread object public class Thread1 { public static void main(String[] args) { MyThread myThread = new MyThread(\"王冰冰\"); myThread.start(); Thread thread = Thread.currentThread(); thread.setName(\"长风\"); String name = thread.getName(); for (int i = 0; i \u003c 10; i++) { System.out.println(name + \"---------\" + i); } } } class MyThread extends Thread { public MyThread(String name) { super(name); } @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"------\" + i); } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:22","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"线程调度的方式? 协同式线程调度 抢占式线程调度 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:23","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是线程调度? 线程调度是指系统为线程 分配处理器使用权 的过程 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:24","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是协同式线程调度? 它有什么好处? 线程的执行时间， 由线程本身来控制 线程把自己的工作执行完后，主动通知系统切换到另外一个线程上去 好处 实现简单 环处 执行时间不可控 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:25","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是抢占式线程调度? 每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定 好处 执行时间是可控的 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:26","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"java 用的是什么线程调度? 抢占式线程调度 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:27","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"What is the priority of a Thread in Java? You can increase or decrease the priority of the thread with the setPriority method. myThread.setPriority(Number); You can set the priority to any value between MIN_PRIORITY and MAX_PRIORITY - MIN_PRIORITY defined as 1 - NORM_PRIORITY defined as 5 - MAX_PRIORITY defined as 10 Whenever the thread scheduler has a chance to pick a new thread, it prefers threads with higher priority. However, thread priorities are highly system-dependent When the virtual machine relies on the thread implementation of the host platform, the Java thread priorities are mapped to the priority level of the host platform, which may have more or fewer thread priority levels. For example, Windows have seven priority levels. Some of the Java priorities will map to the same operating system level. In the Oracle JVM for Linux, thread priorities are ignored altogether – all threads have the priority levels. Thread priorities may have been useful in early versions of Java that don’t use operating Systems threads. You should not use them nowadays. ","date":"2021-04-21","objectID":"/posts/20_thread/:0:28","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何获取优先级？ getPriority public int getPriority() Ruturns the thead priority of the thread associated with this ThreadInfo public class Demo { public static void main(String[] args) { System.out.println(\"main start\"); // 创建子类对象 MyThread myThread = new MyThread(); int priority = myThread.getPriority(); myThread.setName(\"main线程\"); System.out.println(myThread.getName() + \"默认的priority是:\" + myThread.getPriority); myThread.start(); } } class MyThread extends Thread { @Override public void run() { try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } for (int i = 0; i \u003c 10; i++) { System.out.println(i); } call(); } public static void call() { System.out.println(\"call\"); } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:29","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么设置两个不同的优先级看起来没有用? 操作系统的优先级是 动 + 静 java 当中提高的是静态优先级 它只是一个对操作系统的建议，操作系统不一定采纳 java官方: 线程优先级并非完全没有用，Thread 的优先级，它具有统计意义，总的来说，高优先级的线程占用的cpu执行时间多一点，低优先级线程，占用cpu执行时间，短一些 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:30","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何休眠一个线程? static void sleep(long millis) Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. public class Demo { public static void main(String[] args) { ThreadSleep threadSleep = new ThreadSleep(); threadSleep.setName(\"UZi\"); threadSleep.start(); } } class ThreadSleep extends Thread { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"-----\" + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:31","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何合并线程? public final void join() Waits for this thread to die. An invocation of this method behaves in exactly the same way as the invocation 未使用 join() public class Demo { public static void main(String[] args) { System.out.println(\"main start\"); ThreadJoin threadJoin = new ThreadJoin(); threadJoin.setName(\"子线程\"); threadJoin.start(); System.out.println(\"main end\"); } } class ThreadJoin extends Thread { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"-----\" + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } 加入 join() public class Demo { public static void main(String[] args) throws InterruptedException { System.out.println(\"main start\"); ThreadJoin threadJoin = new ThreadJoin(); threadJoin.setName(\"子线程\"); threadJoin.start(); threadJoin.join(); System.out.println(\"main end\"); } } class ThreadJoin extends Thread { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"-----\" + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } start 要在 join 前 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:32","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"线程中若使用 join 谁等待? 等待谁? 谁等待 哪个线程调用了 join 代码，哪个线程就等待 等待谁 等待子线程， 等待的是调用了 join 这个线程 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:33","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"线程是如何分类的？ 守护线程 用户线程 线程默认是用户线程 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:34","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"GC是什么线程? 守护线程 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:35","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"How to turn a thread into a daemon thread? t.setDaemon(true); When only daemon threads remain, the virtual machine exits. This method must be invoked before the thread is started. 在 start 后执行会报错 设置成守护线程后, main死亡时, 线程也会死亡 未使用时 使用时 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:36","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是礼让线程? yield public static void yield() A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hin public class Demo { public static void main(String[] args) throws InterruptedException { ThreadYield t1 = new ThreadYield(); ThreadYield t2 = new ThreadYield(); t1.setName(\"吴彦祖\"); t2.setName(\"彭于晏\"); t1.start(); t2.start(); } } class ThreadYield extends Thread { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"------\" + i); Thread.yield(); } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:37","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么使用yield后，没有起到抢占式的结果? 吴彦祖虽然放弃了CPU的执行权 但 Java 中采用的是抢占式的调试方式 吴彦祖又抢到了 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:38","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何中断线程对象(interrupt 会发生什么)? interrupt public boolean isInterrupted() Tests whether this thread has been interrupted. The interrupted status of the thread is unaffected by this method. A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false. Returns: true if this thread has been interrupted; false otherwise. public class Demo { public static void main(String[] args) throws InterruptedException { ThreadInterrupt thread = new ThreadInterrupt(); thread.setName(\"送终鸡\"); thread.start(); try { Thread.sleep(3000); } catch (InterruptedException e){ e.printStackTrace(); } thread.interrupt(); } } class ThreadInterrupt extends Thread{ @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"-----\" + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:39","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何中断线程对象(stop 会发生什么)? stop @Deprecated public final void stop() Deprecated. This method is inherently unsafe. 会终止线程执行 public class Demo { public static void main(String[] args){ ThreadStop threadStop = new ThreadStop(); threadStop.setName(\"短风\"); threadStop.start(); try{ Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } threadStop.stop(); } } class ThreadStop extends Thread{ @Override public void run() { System.out.println(\"ThreadStop start\"); for (int i = 0; i \u003c 10; i++) { System.out.println(getName() + \"-----\" + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"ThreadStop end\"); } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:40","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何安全终止线程？(用 flag 标记， 如果为 true, 正常执行， 如果为 false, 终止线程执行, 在终止之前，去做一个日志保存，将终止信息保存到 og.txt 当中, 利用 FileWriter, 2021-4-28 时分秒 : 某个线程终止了) import java.io.FileWriter; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; /** * @className: Demo * @Description * @author: fengxiaonan * @date: 4/20/21 6:38 PM */ public class Demo { public static void main(String[] args) throws InterruptedException { ThreadStop thread = new ThreadStop(); thread.setName(\"子线程\"); thread.start(); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } thread.flag = false; } } class ThreadStop extends Thread { boolean flag = true; @Override public void run() { for (int i = 0; i \u003c 10; i++) { if (flag) { System.out.println(getName() + \"-----\" + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } else { try { FileWriter fileWriter = new FileWriter(\"log.txt\"); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm::ss\"); String date = simpleDateFormat.format(new Date()); fileWriter.write(date + \" \" + getName() + \"被终止了!\"); fileWriter.write(System.lineSeparator()); fileWriter.flush(); fileWriter.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:41","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"How many states of thread in Java? Threads can be in one of six states: new Runnable A runnable therad may or may not be running at any given time.(This is why the state is called “runnable” and not “running”) Blocked Waiting Timed waiting Terminated ","date":"2021-04-21","objectID":"/posts/20_thread/:0:42","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"what is Preemptive scheduling systems and cooperative scheduling? Preemptive scheduling systems Preemptive scheduling systems give each runnable thread a slice of time to perform its task. When that slice of time is exhausted, the operating system preempts the thread and gives another thread an opportunity to work. When selecting the next thread, the operating system takes into account the thread priorities. All modern desktop and server operating systems use preemptive scheduling. Cooperative scheduling systems A thead loses control only when it calls the yield mehtod, or when it is blocked or waiting. small devices such as cell phones may use cooperative scheduling. ","date":"2021-04-21","objectID":"/posts/20_thread/:0:43","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"线程有哪5种状态? 新建: 刚创建的线程，没有执行 start() 方法， 没有资格去挣抢CPU资源 就绪 刚执行了 start 方法， 但是还没有获得CPU的执行权 执行 抢到了 CPU的执行权 阻塞 没有 CPU 的执行权，还缺少必要的条件（sleep 结束） 死亡 run 方法执行完之后 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:44","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"线程5个状态之间是如何转换? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:45","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"用Runnable实现多线程? 实现 Runnable 接口 重写 run 方法 创建 Runnable 子类对象 创建 Thread 对象， 并且把 Runnable 子类对象作为参数传递 start 方法 public class RunnableDemo { public static void main(String[] args) { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); for (int i = 0; i \u003c 10; i++) { System.out.println(Thread.currentThread().getName() + \"--------\" + i); } } } class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i \u003c 10; i++) { System.out.println(Thread.currentThread().getName() + \"-------\" + i); } } } ","date":"2021-04-21","objectID":"/posts/20_thread/:0:46","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么 Runnable 接口子类的 run() 方法代码， 会执行在子线程当中？ ","date":"2021-04-21","objectID":"/posts/20_thread/:0:47","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Runnable 对象代表线程吗? 不代表， thread 才代表 Runnable 子类对象， 并不代表线程，它只代表，要在线程中执行的任务 线程就是一条执行路径，至于在线程这条执行路径上，究竟执行的是什么样的具体代码，与线程没有关系的 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:48","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"继承 Thread 与 实现 Runnable 两种方式的比较? Thread Runnable 实现步骤少 实现方式，存在单重继承的局限性 Runnable 将线程与任务解藕 便于多线程数据的共享 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:49","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么时候会产生数据安全问题? 多线程运行环境 多线程访问共享数据 存在一个非原子操作 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:50","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是原子操作? 一个操作要么一次执行完，一次都不执行 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:51","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何解决数据安全问题? 逻辑上， 解决把 一组操作变成原子的操作 的这件事情 思路1: 只在一个线程上，对共享变量的一组操作的执行过程，能够阻止线程切换 无法实现 java 是采取抢占式线程调度，代码层面(线程中执行的代码), 无法控制线程调度 思路2: 把共享变量，加一把锁，利用锁来实现原子的操作，使用锁，可以给共享加锁，从面保证: a. 只有加锁的线程，能够访问到共享变量 b. 在加锁线程中，没有完成对共享变量的一组操作之前，不会释放锁 c. 只要不释放锁，其他线程，即使被调度执行，也无法访问共享变量 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:52","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是 synchronized 同步? 同步的代码块中的锁对象可以是任意的 java 对象 一定要保证是同一个对象 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:53","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"同步方法中的锁对象是什么? 同步代码块中 任意java对象 任意方法中 this 静态方法中 字节码文件对象（.clsss） 补充代码 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:54","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么在同步代码块中可以放一个任意的对象? 因为 java 当中所有对象， 内部都存在一个 标志位，表示加锁和解锁的状态 其实锁对象，就是充当锁的角色 所谓的加锁解锁，其实就是 设置锁对象的标志位，来表示加锁解锁的状态 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:55","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"当某个线程执行到同步代码块时，遇到加锁或无锁时会怎么处理? 当锁对象处于未加锁状态， jvm 就会设置锁对象的标志位(加锁)， 并在锁对象中记录，是哪个线程加的锁. 加锁成功， 执行同步代码块中的代码。 如果锁对象 已经被加锁, 且加锁线程不是当前线程，系统会让当前线程处于阻塞状态(等着)， 直到加锁线程，执行完了对共享变量的组操作，并释放锁。 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:56","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"加锁线程何时释放锁? 当加锁线程，执行完了同步代码块中的代码(对共享变量的一组操作)，在退出同步代码块之前, jvm 自动清理锁对象的标志位，将锁对象变成未上锁状态(释放锁) ","date":"2021-04-21","objectID":"/posts/20_thread/:0:57","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何使用 Lock 锁住对象? 定义一把锁 Lock lock = new ReentrantLock(); 美[ˌriˈɛntrənt] public ReentrantLock() Creates an instance of ReentrantLock. THis is equivalent to using ReentrantLock(false). 获取锁 lock.lock(); void lock() Acquires the lock. 释放锁 lock.unlock; void unlock() Releases the lock. ","date":"2021-04-21","objectID":"/posts/20_thread/:0:58","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Lock 和 synchronized 的区别? synchronized 会同步阻塞 synchronized 只提供了用来 模拟锁状态的标志位 (加锁和释放锁) 加锁和释放锁的行为，都是由 jvm 隐式完成(和 synchronized 锁对象没有关系) 所以 synchronized 锁对象 不是一把完整的锁 Lock 它代表的是完整的锁 Lock对象， 它如果要实现加锁和释放锁，不需要 synchronized 关键字配合，它自己就可以完成 Lock(接口): lock() 加锁 unlock 释放锁 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:59","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是同步与异步? 同步与异步描述的是被调用者的 如 A 调用 B: 如果是 同步 ，B 在接到 A 调用后，会立即执行要做的事。 A 的本次调用可以得到结果. 如果是 异步 ，B 在接到 A 调用后，不保证会立即执行要做的事，但是保证会去做， B 在做好了之后会通知 A。 A的本次调用得不到结果， 但是 B 执行完之后会通知 A . ","date":"2021-04-21","objectID":"/posts/20_thread/:0:60","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是死锁? 2 个或以上的线程争抢资源，造成互相等待的现象 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:61","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"在 java 中怎样的代码容易产生死锁? 一般出现在 同步代码块嵌套 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:62","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"解决死锁的方法有哪些? 方式一 更改加锁顺序 方式二: 将该步骤变成原子操作 最外层再加一层操作 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:63","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是生产者消费者模型? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:64","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"线程间通信有哪些API? wait() 阻止自己 notify() 通知别人 notifyAll() 通知所有的人 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:65","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"线程间通信的 wait() api 是干什么的? public final void wait throws InterruptedException 阻塞功能: 当在某线程中，对象上 .wait(), 在哪个线程中调用 wait(), 导致哪个线程处于阻塞状态 当某线程，因为调用执行某对象的 wait(), 而处于阻塞状态，我们说，该线程在该对象上阻塞 唤醒条件 当某线程，因为某对象A的 wait(), 而处于阻塞状态时，如果要唤醒该线程，只能在其他线程中，再同一个对象 (即对象A) 上调用其 notify() 或 notifyAll() 即在线程的阻塞对象上，调用 notify 或 notifyAll 方法，才能唤醒，在该对象上阻塞的线程 运行条件 当前线程必须拥有此对象 监视器 监视器: 指 synchronized 代码块中的锁对象 如果不在同步代码块中调用就会就会出现 IllegalMonitorStateException 执行特征 该线程释放对监视器的所有权 等待(阻塞) ","date":"2021-04-21","objectID":"/posts/20_thread/:0:66","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Thread 的 sleep 方法， 执行时会丢失监视器的所属权吗? 不会 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:67","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Object 的 wait 方法， 执行时会丢失监视器的所属权吗? 会 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:68","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Thread.sleep VS Object.wait()? 所属不同: sleep 定义在Thread类，静态方法 wait 定义在Object类中，非静态方法 唤醒条件不同 sleep 休眠时间到 wait 在其他线程中，在同一个锁对象上，调用了 notify 或 notifyAll 方法 使用条件不同 sleep 没有任何前提条件 wait 必须是当前线程，持有锁对象，锁对象上调用 wait() 休眠时，对锁对象的持有，不同: sleep 处于阻塞状态的时候，在阻塞的时候不会放弃对锁的持有 wait 处于阻塞的时候，会放弃对象持有3 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:69","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"notify() api 是干什么的? public final void notify() 唤醒在此对象监视器上等待的单个线程 如果所有线程都在此对象上等待 则 会选择唤醒其中一个线程， 选择是任意性的 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:70","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"产包子实战？ 生产者 消费者 蒸笼 demo ","date":"2021-04-21","objectID":"/posts/20_thread/:0:71","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"只执行一次? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:72","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"同步方法 Box Box ","date":"2021-04-21","objectID":"/posts/20_thread/:0:73","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么多个生产者，消费者的时候，会出现卡顿？ ","date":"2021-04-21","objectID":"/posts/20_thread/:0:74","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是 虚假唤醒? 唤醒了不应该被唤醒的线程 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:75","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么 wait,notify, 为啥不定义在 Thread 当中? 因为锁对象可以是任意java对象 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:76","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"完整的线程转换图是什么? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:77","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"为什么会有线程池? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:78","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"三种线程池? 带缓存的线程池 newFixedThreadPod ","date":"2021-04-21","objectID":"/posts/20_thread/:0:79","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何实现 newFixedThreadPod? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:80","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"? 有什么区别? shutdownNow 队列中也执行 shutdownNow 队列中的不执行 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:81","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"如何实现 Callable? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:82","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Future 是干什么的? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:83","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Runnable VS Callable ","date":"2021-04-21","objectID":"/posts/20_thread/:0:84","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"FutureTask 如何使用? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:85","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"用 Callable 方式，启动2个线程， 1个从1一直加到100， 一个从1一直加到200，最后打印结果 ","date":"2021-04-21","objectID":"/posts/20_thread/:0:86","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Timer 如何使用(schedule(TimerTask task, Data time))? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:87","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Timer 如何使用(schedule(TimerTask task, long delay, long period))? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:88","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"Timer 如何使用(schedule(TimerTask task, Date firstTime, long period))? ","date":"2021-04-21","objectID":"/posts/20_thread/:0:89","tags":["java"],"title":"20_thread","uri":"/posts/20_thread/"},{"categories":["王道"],"content":"什么是计算机网络 物理互联 软件支持 目的: 资源共享 + 信息传递 ","date":"2021-04-20","objectID":"/posts/19_network/:0:1","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"什么是网络编程? 处于 互联网络 上不同计算机 程序间 的数据交换 ","date":"2021-04-20","objectID":"/posts/19_network/:0:2","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"OSI参考模型有几层? 分别是什么? 7 层 物理层 数据链路层 网络层 传输层 会话层 表示层 应用层 物联网淑惠试用 ","date":"2021-04-20","objectID":"/posts/19_network/:0:3","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"物理层主要关注什么? 关注一条通信信道上传输原始比特(01) 其功能是确保当一方发送了比特1, 另一方收到的是比特1, 而不是0 ","date":"2021-04-20","objectID":"/posts/19_network/:0:4","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"物理层的所涉及到的典型问题是什么? 用什么样的电信号表示0和1 一个 bit 持续多少纳秒 传输是否可以在两个方向同时进行 初始连接如何建立，传输结束后之后如何撤销连接 规定一个特殊的电信号将普通的数据信号分开来 ","date":"2021-04-20","objectID":"/posts/19_network/:0:5","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"数据链路层主要关注什么? 将一个原始的传输设施转变成一条 没有漏检传输错误 的传输线路 检查数据是否发生差错 ","date":"2021-04-20","objectID":"/posts/19_network/:0:6","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"数据链路层的主要功能是什么? 成帧 差错控制(帧校验，确认 + 超时重传) 流量控制 广播式网络的数据链路层, 还有介质访问控制问题 介质访问控制 保证只有一台计算机在发送数据 ","date":"2021-04-20","objectID":"/posts/19_network/:0:7","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"网络层需要解决的核心功能是什么? 如何将数据包从源端路由到接收端 ","date":"2021-04-20","objectID":"/posts/19_network/:0:8","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"什么是端到端的通信? 应用程序所对应的 进程间 的通信 ","date":"2021-04-20","objectID":"/posts/19_network/:0:9","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"什么是端口? 整数值 在一台主机中代表一个唯一的进程标志 ","date":"2021-04-20","objectID":"/posts/19_network/:0:10","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"传输层主要考虑的是什么? 向上层提供端到端的通信服务，屏蔽底层的通信细节 ","date":"2021-04-20","objectID":"/posts/19_network/:0:11","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"传输层有哪些功能? 提供应用进程之间的逻辑通信 复用和分用 向上层提供不同类型的通信服务 TCP , UDP ","date":"2021-04-20","objectID":"/posts/19_network/:0:12","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"什么 TCP 协议? 面向连接的可靠的通信服务（如: 打电话） Transmission Control Protocol ","date":"2021-04-20","objectID":"/posts/19_network/:0:13","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"什么 UDP 协议? 无连接的不可靠的通信服务(如: 写信) User Datagram Protocol ","date":"2021-04-20","objectID":"/posts/19_network/:0:14","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"若要使用 UDP 协议进行传输，有哪几步? 发送端 建立 udp 的 socket 对象 将要发送的数据封装成数据包 通过 udp 的 socket 对象， 将数据包发送出 释放资源 接收端 建立 udp 的 socket 对象 创建用于接收数据的数据报包，通过 socket 对象的 receive 方法接收数据 通过数据包对象的功能来完成对接受到数据进行解析 可以对资源进行释放 ","date":"2021-04-20","objectID":"/posts/19_network/:0:15","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"若要使用 TCP 协议进行传输，有哪几步? 客户端 建立客户端的 Socket 服务， 并明确要连接的服务器 如果对象建立成功，就表明已经建立了数据传输的通道，就可以在该通道通过IO进行数据的读取和写入 根据需要从socket对象中获取输入, 或输出流 向流中读取或写入数据， 释放资源 (接受端)服务端 创建 Serversocket 对象， 在指定端口，监听客户端连接请求 收到客户端连接请求后，建立Socket连接 如果连接建立成功，就表明已经 了数据传输的通道，就可以在该通道通过IO进行数据的读取和写入 从 socket 中根据需要获取输入，或输出流，根据需要向流中写入数据或从流中读数据，释放资源 ","date":"2021-04-20","objectID":"/posts/19_network/:0:16","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"如何实现客户端(tcp) socket? public class Socket extends Object implements Closeable This class implements client sockets (also called just “sockets”). A socket is an endpoint for communication between two machines. Constructor Socket(String host, int port) Creates a stream socket and connects it to the specified port number on the named host. Method InputStream getInputStream() Returns an input stream for this socket. OutputStream getOutputStream() Returns an output stream for this socket. public class Client { public static void main(String[] args) throws IOException { // 建立客户端的 Socket 服务， 并明确要连接服务器 // Socket(String host, int port) Socket socket = new Socket(\"127.0.0.1\", 8888); // 如果对象建立成功，就表明已经建立了数据传输的通道 // 就可以在该通道通过IO进行数据的读取和写入 // 想服务端发送数据 OutputStream out = socket.getOutputStream(); out.write(\"Hello tcp\".getBytes()); // 释放资源 socket.close(); } } ","date":"2021-04-20","objectID":"/posts/19_network/:0:17","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"如何实现接受端(Tcp) socket? public class ServerSocket extends Object implements Closeable This class implements server sockets. A server socket waits for requests to come in over the network. It performs some operation based on that request, and then possibly returns a result to the requester. Construct ServerSocket(int port) Creates a server socket, bound to the specified port. method Socket accept() Listens for a connection to be made to this socket and accepts it. public class Server { public static void main(String[] args) throws IOException { // 创建 ServerSocket 对象， 在指定端口，监听客户端连接请求 ServerSocket serverSocket = new ServerSocket(8888); // 收到客户端连接请求后，建立socket连接 Socket socket = serverSocket.accept(); // 从 socket 中根据需要获取输入，或输出流 InputStream in = socket.getInputStream(); // 解析数据 byte[] bytes = new byte[1024]; int readCount = in.read(bytes); String s = new String(bytes, 0, readCount); System.out.println(s); socket.close(); serverSocket.close(); } } 先运行服务端 ","date":"2021-04-20","objectID":"/posts/19_network/:0:18","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"如何实现TCP, 客户端发送数据，服务端给予反馈? Client public class Client { public static void main(String[] args) throws IOException { // 建立客户端 Socket 服务， 并明确要连接的服务器 Socket socket = new Socket(\"127.0.0.1\", 8888); // 如果对象建立成功，就表明已经建立了数据传输的通道 // 向服务端发送数据 OutputStream out = socket.getOutputStream(); out.write(\"hello tcp\".getBytes()); // 接受来自客户端的反馈 // 获取输入流 InputStream in = socket.getInputStream(); byte[] bytes = new byte[1024]; int readCount = in.read(bytes); String s = new String(bytes, 0, readCount); System.out.println(s); // 释放资源 socket.close(); } } Server public class Server { public static void main(String[] args) throws IOException { // 创建 Serversocket 对象， 在指定端口，监听客户端连接请求 ServerSocket serverSocket = new ServerSocket(8888); // 收到客户端连接请求后， 建立 socket 连接 Socket socket = serverSocket.accept(); // 从 socket 中根据需要获取输入，或输出流 InputStream in = socket.getInputStream(); // 解析数据 byte[] bytes = new byte[1024]; int readCount = in.read(bytes); String s = new String(bytes, 0, readCount); System.out.println(s); // 给客户端一个反馈信息 OutputStream out = socket.getOutputStream(); out.write(\"好你妹\".getBytes()); socket.close(); serverSocket.close(); } } ","date":"2021-04-20","objectID":"/posts/19_network/:0:19","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"如何把客户端文件上传到服务器? Client 创建 Socket 对象 读取本地文件 获取输出流 public class Client { public static void main(String[] args) throws IOException { // 创建 Socket 对象 Socket socket = new Socket(\"127.0.0.1\", 11111); // 读取本地文件 FileInputStream in = new FileInputStream(\"a.txt\"); // 获取输出流 OutputStream out = socket.getOutputStream(); byte[] bytes = new byte[1024]; int readCount; while ((readCount = in.read(bytes)) != -1) { out.write(bytes, 0, readCount); } in.close(); socket.close(); } } Server 创建输出流对象， 写入服务器 public class Server { public static void main(String[] args) throws IOException { ServerSocket serverSocket = new ServerSocket(11111); Socket socket = serverSocket.accept(); // 创建输出流对象 FileOutputStream out = new FileOutputStream(\"b.txt\"); InputStream in = socket.getInputStream(); // 写入服务器 int readCount; byte[] bytes = new byte[1024]; while ((readCount = in.read(bytes)) != -1) { out.write(bytes, 0, readCount); } // 关闭流 out.close(); socket.close(); serverSocket.close(); } } ","date":"2021-04-20","objectID":"/posts/19_network/:0:20","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"如何实现 DatagramSocket(udp) 发送端? public class DatagramSocket extends Object implements Closeable This class represents a socket for sending and receiving datagram packets. public final class DatagramPacket extends Object This class represents a datagram packet. constructor ： DatagramSocket(int port) Constructs a datagram socket and binds it to the specified port on the local host machine. method void send(DatagramPacket p) Sends a datagram packet from this socket. DatagramPacket(byte[] buf, int offset, int length, InetAddress address, int port) Constructs a datagram packet for sending packets of length length with offset ioffsetto the specified port number on the specified host. 发送端 public class Sender { public static void main(String[] args) throws IOException { // 1. 将立 udp 的 socket 对象 DatagramSocket datagramSocket = new DatagramSocket(8888); // 2. 将要发送的数据封装成数据包 String s = \"hello udp\"; byte[] bytes = s.getBytes(); InetAddress targetIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length, targetIP, port); // 3. 将数据包发送出 datagramSocket.send(packet); // 4. 释放资源 datagramSocket.close(); } } ","date":"2021-04-20","objectID":"/posts/19_network/:0:21","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"如何实现 DatagramSocket(udp) 接受端? public class DatagramSocket extends Object implements Closeable This class represents a socket for sending and receiving datagram packets. public final class DatagramPacket extends Object This class represents a datagram packet. method DatagramPacket(byte[] buf, int offset, int length) Constructs a DatagramPacket for receiving packets of length length, specifying an offset into the buffer. void receive(DatagramPacket p) Receives a datagram packet from this socket. public class Receiver { public static void main(String[] args) throws IOException { // 1. 建立 udp 的 socket 对象 DatagramSocket datagramSocket = new DatagramSocket(9999); // 2. 创建用于接收数据的数据报包，通过 socket 对象的 receive 方法接收数据 byte[] bytes = new byte[1024]; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length); datagramSocket.receive(packet); // 3. 通过数据包对象的功能来完成对接受到数据进行解析 byte[] data = packet.getData(); int offset = packet.getOffset(); int length = packet.getLength(); String s = new String(data, offset, length); System.out.println(s); // 4. 对资源进行释放 datagramSocket.close(); } } ","date":"2021-04-20","objectID":"/posts/19_network/:0:22","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"接受端与发送端的工具类实现? public class NetworkUtils { public static DatagramPacket getSenderPacket(String targetIp, int port, String message) throws UnknownHostException { // 创建用于发送的数据报包 byte[] bytes = message.getBytes(); InetAddress ip = InetAddress.getByName(targetIp); DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length, ip, port); return packet; } // 创建用于接受的数据报包 public static DatagramPacket getReceiverPacket() { byte[] bytes = new byte[1024]; DatagramPacket packet = new DatagramPacket(bytes, 0, bytes.length); return packet; } // 解析数据 public static String parsePacket(DatagramPacket packet) { byte[] data = packet.getData(); int offset = packet.getOffset(); int length = packet.getLength(); String s = new String(data, offset, length); return s; } } ","date":"2021-04-20","objectID":"/posts/19_network/:0:23","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"接受端与发送端都可发送和接受数据? 发送端 发送 和 接收 退出条件 接受端 ","date":"2021-04-20","objectID":"/posts/19_network/:0:24","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"会话层主要功能是什么? 记录谁发了消息，记录检查点 ","date":"2021-04-20","objectID":"/posts/19_network/:0:25","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"表示层主要功能是什么? 处理两个通信系统中交换信息的表示方式 编码和表示方法 数据是否压缩，数据的加密和解密使用何种加密算法 ","date":"2021-04-20","objectID":"/posts/19_network/:0:26","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"应用层主要功能是什么? 包含了用户通常所需要的各种协议 Http协议 ","date":"2021-04-20","objectID":"/posts/19_network/:0:27","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"IP地址是怎么组成的? 网络号码 + 主机地址(唯一的) ","date":"2021-04-20","objectID":"/posts/19_network/:0:28","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"A类， B类， C类, D类, E类,IP地址是如何分类的? A类: 第一段号码为网络号码， 剩下的三段号码为本地计算机的号码 B类: 前二段号码为网络号码， 剩下的二段号码为本地计算机的号码 C类: 前三段号码为网络号码， 剩下的一段号码为本地计算机的号码 D类: (组播的目的地址) E类: (保留地址) ","date":"2021-04-20","objectID":"/posts/19_network/:0:29","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"什么是网络地址，广播地址? 对于A, B, C 不同类型的网络地址，都包含两个特殊的ip地址 网络地址: 表示该类网络本身 xxx.xxx.xxx.0 广播地址: 代表的是当前这个网络中，所有的主机 xxx.xxx.xxx.255 ","date":"2021-04-20","objectID":"/posts/19_network/:0:30","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"哪个是回环地址? 127.0.0.1 用于测试本机的网络是否有问题 ","date":"2021-04-20","objectID":"/posts/19_network/:0:31","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"两个主机之间通信的原理图是什么样的? ","date":"2021-04-20","objectID":"/posts/19_network/:0:32","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"config.properties (key-value)一般用于存储哪些东西? 数据库配置 开发数据库 测试数据库 线上数据库(生产环境) 第三方配置信息 APP Key ","date":"2021-04-20","objectID":"/posts/19_network/:0:33","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"如何读取 config.properties? public class Properties extends Hashtable\u003cObject,Object\u003e The Properties class represents a persistent set of properties. The Properties can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string. Constructors Properties() Creates an empty property list with no default values. Method void load(InputStream inStream) Reads a property list (key and element pairs) from the input byte stream. void load(Reader reader) Reads a property list (key and element pairs) from the input character stream in a simple line-oriented format. String getProperty(String key) Searches for the property with the specified key in this property list. ","date":"2021-04-20","objectID":"/posts/19_network/:0:34","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"如何读取 config.properties(实现编码一致)? public class Properties extends Hashtable\u003cObject,Object\u003e The Properties class represents a persistent set of properties. The Properties can be saved to a stream or loaded from a stream. Each key and its corresponding value in the property list is a string. void load(InputStream inStream) Reads a property list (key and element pairs) from the input byte stream. String getProperty(String key) Searches for the property with the specified key in this property list. public class Demo2 { public static void main(String[] args) throws IOException { Properties properties = new Properties(); properties.load(new InputStreamReader(new FileInputStream(\"config.properties\"), \"GBK\")); String user = properties.getProperty(\"user\"); System.out.println(user); } } ","date":"2021-04-20","objectID":"/posts/19_network/:0:35","tags":["java"],"title":"19_network","uri":"/posts/19_network/"},{"categories":["王道"],"content":"字节流是怎么分类的? 字节输出流 抽象基类 OutputStream 具体子类 FileOutputStream BufferedOutputStream 字节输入流 抽象基类 InputStream 具体子类 FielInputStream BufferedInputStream ","date":"2021-04-19","objectID":"/posts/18_io/:0:1","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"什么是IO? i: input 输入 o: output 输出 ","date":"2021-04-19","objectID":"/posts/18_io/:0:2","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"为什么会有 IO? 需要长久保存的数据都是以文件的形式存储的，存储在外边设备当中 内存有限，需要把数据读取到内存才行，需要io交互 ","date":"2021-04-19","objectID":"/posts/18_io/:0:3","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"java 流模型是什么样的? ","date":"2021-04-19","objectID":"/posts/18_io/:0:4","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"java 中的流是怎么分类的? 按照流向分(以内存为参照) 输入流 input 输出流 output 按照数据类型分类 字节流: 一连串的 01 二进制数据 按字节传输 1B = 8 bit 0000 0000 字符流: 一连串的字符的字符序列，把它当做一种文化符号 “abc”, “你” ","date":"2021-04-19","objectID":"/posts/18_io/:0:5","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"java IO抽象基类有哪些? 字节输出流 OutputStream 字节输入流 InputStream 字节输出流 Writer 字符输入流 Reader 由这4个基类派生出的子类,其子类名都是以父类名作为后缀 ","date":"2021-04-19","objectID":"/posts/18_io/:0:6","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"OutputStream 的继承关系? ","date":"2021-04-19","objectID":"/posts/18_io/:0:7","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"outputStream 的 write 的实现原理是什么样的? public abstract void write(int b) throws IOException 将指定的字节写入此输出流， write 的常规协定是: 向输出流写入一个字节，要写入的字节是参数b的八个低位，b的24个高位将被忽略 ","date":"2021-04-19","objectID":"/posts/18_io/:0:8","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"FileOutputStream(File file), 如何实现? ","date":"2021-04-19","objectID":"/posts/18_io/:0:9","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"为什么用 IO 一定要关闭资源? 它属于操作系统，与 java 无关，只能显式的释放资源(如 wps资源) 软件占用. ","date":"2021-04-19","objectID":"/posts/18_io/:0:10","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何用 FileOutputStream 用 write 方法? public class Demo { public static void main(String[] args) throws IOException { FileOutputStream out = new FileOutputStream( new File(\"b.txt\")); out.write(97); out.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:11","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何用 FileOutputStream 用 write(byte[] b) byte[] getBytes(String charsetName) Encodes this String into a sequence of bytes using the name charset, storing the result into a new byte array. public class Demo { public static void main(String[] args) throws IOException { FileOutputStream out = new FileOutputStream( new File(\"b.txt\")); String s = \"abc\"; byte[] bytes = s.getBytes(); out.write(bytes); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:12","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何用 write(byte[] b , int off, int len)? public class Demo { public static void main(String[] args) throws IOException { FileOutputStream out = new FileOutputStream( new File(\"b.txt\")); String s = \"abc\"; byte[] bytes = s.getBytes(); out.write(bytes, 0, bytes.length); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:13","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"创建字节输出流对象发生了什么事情? 创建之前 jvm 会去操作系统中找该文件是否存在 如果不存在，帮我们创建 如果存在，会清空重写 创建之后就建立起内存与外设的数据通道 ","date":"2021-04-19","objectID":"/posts/18_io/:0:14","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"FileOutputStream 如何实现数据追加? public FileOutputStream(File file, boolean append) throw FIleNotFoundException public class Demo { public static void main(String[] args) throws IOException { FileOutputStream out = new FileOutputStream( \"b.txt\", true); out.write(\"def\".getBytes()); out.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:15","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"FileOutputStream 如何实现换行? \\n public class Demo { public static void main(String[] args) throws IOException { FileOutputStream outputStream = new FileOutputStream(\"a.txt\", true); outputStream.write(\"\\n\".getBytes()); outputStream.write(\"def\".getBytes()); outputStream.close(); } } System.lineSeparator() public class Demo { public static void main(String[] args) throws IOException { FileOutputStream outputStream = new FileOutputStream(\"a.txt\", true); outputStream.write(System.lineSeparator().getBytes()); outputStream.write(\"def\".getBytes()); outputStream.close(); } } \\r public class Demo { public static void main(String[] args) throws IOException { FileOutputStream outputStream = new FileOutputStream(\"a.txt\", true); outputStream.write(\"\\r\".getBytes()); outputStream.write(\"def\".getBytes()); outputStream.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:16","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"try-catch-with-resource 的语法是什么? 如何实现? try…catch…source 会执行close try(资源, 实现了Autocloseable接口){ // 代码 } catch() { } finally { } ``````java public class Demo { public static void main(String[] args) throws IOException { try (A a = new A()) { a.test(); } catch (Exception e) { e.printStackTrace(); } } } class A implements AutoCloseable { @Override public void close() throws Exception { System.out.println(\"close 方法执行了!!\"); } public void test() { System.out.println(\"test 执行了\"); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:17","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"InputStream 基类是什么样的? ","date":"2021-04-19","objectID":"/posts/18_io/:0:18","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"FileInputStrem 构造方法是什么的? FileInputStream (File file) Creates a FileInputStream by opening a connection to an actual file, the file named by the File object in the file system. FIleInputStream (String name) Creates a FileInputStream by opening a connection to an actual file, the file named by the path name in the file system. public class Demo { public static void main(String[] args) throws IOException { FileInputStream f1 = new FileInputStream(new File(\"a.txt\")); FileInputStream f2 = new FileInputStream(\"a.txt\"); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:19","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"FileInputStream 的 read 方法使用? public class Demo { public static void main(String[] args) throws IOException { FileInputStream in = new FileInputStream(\"a.txt\"); int readData = in.read(); System.out.println(((char) readData)); in.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:20","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"a 中是 abcdef 会输出什么? abcd efcd ","date":"2021-04-19","objectID":"/posts/18_io/:0:21","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"实现文件复制有什么思路? 单字节复制 int 类型 多字节 byte[] b ","date":"2021-04-19","objectID":"/posts/18_io/:0:22","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何实现实现循环读取文件(单char)? public class Demo { public static void main(String[] args) throws IOException { FileInputStream in = new FileInputStream(\"a.txt\"); int readDate; while ((readDate = in.read()) != -1){ System.out.println(((char) readDate)); } } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:23","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何实现实现循环读取文件(用字节数组)? public class Demo { public static void main(String[] args) throws IOException { FileInputStream in = new FileInputStream(\"a.txt\"); int readDate; byte[] bytes = new byte[1024]; while ((readDate = in.read(bytes)) != -1) { System.out.println(new String(bytes, 0, readDate)); } } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:24","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何实现单字节复制文本文件(a.txt -\u003e b.txt) public class Demo { public static void main(String[] args) throws IOException { FileInputStream in = new FileInputStream(\"a.txt\"); FileOutputStream out = new FileOutputStream(\"b.txt\"); int readData; while((readData = in.read())!=-1){ out.write(readData); } out.close(); in.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:25","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何实现统计复制文件的耗时(单字节的方式)? long start = System.currentTimeMillis(); long end = System.currentTimeMillis(); public class Demo { public static void main(String[] args) throws IOException { // 创建字节输入流对象 FileInputStream in = new FileInputStream(\"a.txt\"); // 创建字节输出流对象 FileOutputStream out = new FileOutputStream(\"c.txt\"); long start = System.currentTimeMillis(); int readData; while ((readData = in.read()) != -1) { out.write(readData); } long end = System.currentTimeMillis(); System.out.println(\"耗时:\" + (end - start) + \"ms\"); // close out.close(); in.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:26","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何实现统计复制文件的耗时(字节数组String)? long start = System.currentTimeMillis() long end = System.currentTimeMillis() public class Demo { public static void main(String[] args) throws IOException { // 创建字节输入流对象 FileInputStream in = new FileInputStream(\"a.txt\"); // 创建字节输出流对象 FileOutputStream out = new FileOutputStream(\"c.txt\"); long start = System.currentTimeMillis(); int readCount; byte[] bytes = new byte[1024]; while ((readCount = in.read(bytes)) != -1) { out.write(bytes, 0, readCount); } long end = System.currentTimeMillis(); System.out.println(\"耗时:\" + (end - start) + \"ms\"); // close out.close(); in.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:27","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何复制的时候，什么时候选择字节流，什么时候选择字符流? 不知道用啥的时候就用字节流， 字节流是万能的 对于文本文件， 我们选择用字符流 ","date":"2021-04-19","objectID":"/posts/18_io/:0:28","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"什么是装饰器模式? public class Demo { public static void main(String[] args) throws IOException { MilkTea milkTea = new MilkTea(); milkTea.add(); System.out.println(\"-------\"); DecoratorA decoratorA = new DecoratorA(); decoratorA.setBeverage(milkTea); decoratorA.add(); System.out.println(\"-------\"); DecoratorB decoratorB = new DecoratorB(); decoratorB.setBeverage(decoratorA); decoratorB.add(); System.out.println(\"-------\"); DecoratorC decoratorC = new DecoratorC(); decoratorC.setBeverage(decoratorB); decoratorC.add(); System.out.println(\"-------\"); } } // 饮料 基类 abstract class Beverage { abstract void add(); } // 奶茶类 class MilkTea extends Beverage { @Override void add() { System.out.println(\"老板，来杯奶茶, 加冰\"); } } // 装饰器类 class Decorator extends Beverage { public Beverage beverage; public void setBeverage(Beverage beverage) { this.beverage = beverage; } @Override void add() { beverage.add(); } } class DecoratorA extends Decorator { @Override void add() { super.add(); addZz(); } private void addZz() { System.out.println(\"再加点珍珠\"); } } class DecoratorB extends Decorator { @Override void add() { super.add(); addYg(); } private void addYg() { System.out.println(\"再加点野果\"); } } class DecoratorC extends Decorator { @Override void add() { super.add(); addHd(); } private void addHd() { System.out.println(\"再加点红豆\"); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:29","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何创建一个 bufferOutStream ? Constructor Description BufferedOutputStream (OutputStream out) Creates a new buffered output stream to write data to the specified underlying output stream BufferedOutputStream (OutputStream out, int size) Creates a new buffered output stream to write data to the specified underlying output stream with the specified buffer size. public class Demo { public static void main(String[] args) throws IOException { FileOutputStream out = new FileOutputStream(\"a.txt\"); BufferedOutputStream bo = new BufferedOutputStream(out); new BufferedOutputStream(new FileOutputStream( new File(\"a.txt\"))); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:30","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"当流中有包装流，应该如何关闭流? 我们只需要关闭最外层的流即可 close 方法会执行 flush 方法 ","date":"2021-04-19","objectID":"/posts/18_io/:0:31","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何创建一个 bufferInputStream ? Constructors Description BufferedInputStream (InputStream in) Creates a BufferedInputStream and save its arguemnt, the input stream in, for later use. BufferedInputStream (InputStream in, int size) Creates a BufferInputStream with the specified buffer siez, and saves its arguemt, the input stream in, for later use. public class Demo { public static void main(String[] args) throws IOException { BufferedInputStream br = new BufferedInputStream(new FileInputStream(\"a.txt\")); //读数据 int readData = br.read(); System.out.println(((char) readData)); br.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:32","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何实现对 FilterInput 实现装饰器模式, 对接收到的字母转换成小写? public class Demo { public static void main(String[] args) throws IOException { // 方法一: BufferedInputStream br = new BufferedInputStream(new FileInputStream(\"a.txt\")); LowerCaseInputStream lowerCaseInputStream = new LowerCaseInputStream(br); // 方法二: new LowerCaseInputStream(new BufferedInputStream(new FileInputStream(\"a.txt\"))); // 单字节 int readData = lowerCaseInputStream.read(); System.out.println((char)readData); // 字节数组 byte[] bytes = new byte[1024]; int readCount = lowerCaseInputStream.read(bytes, 0, bytes.length); System.out.println(new String(bytes, 0, readCount)); lowerCaseInputStream.close(); } } class LowerCaseInputStream extends FilterInputStream{ /** * Creates a \u003ccode\u003eFilterInputStream\u003c/code\u003e * by assigning the argument \u003ccode\u003ein\u003c/code\u003e * to the field \u003ccode\u003ethis.in\u003c/code\u003e so as * to remember it for later use. * * @param in the underlying input stream, or \u003ccode\u003enull\u003c/code\u003e if * this instance is to be created without an underlying stream. */ protected LowerCaseInputStream(InputStream in) { super(in); } @Override public int read() throws IOException { int read = super.read(); int read1 = (char) read; int c = Character.toLowerCase(read1); return c; } @Override public int read(byte[] b, int off, int len) throws IOException { int readCount = super.read(b, off, len); for (int i = off; i \u003c off + readCount; i++) { b[i] = ((byte) Character.toLowerCase((char) b[i])); } return readCount; } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:33","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"创建字节数组和单字节IO模式是什么样的? 单字节 public class CountNum { public static void main(String[] args) throws IOException { // 创建输入流对象 FileInputStream in = new FileInputStream(\"a.txt\"); // 读数据 int readData; while ((readData = in.read()) != -1) { System.out.println((char) readData); } in.close(); } } 字节数组 public class CountNum { public static void main(String[] args) throws IOException { // 创建输入流对象 FileInputStream in = new FileInputStream(\"a.txt\"); // 读数据 byte[] bytes = new byte[12]; int readCount; while ((readCount = in.read(bytes)) != -1) { System.out.println(new String(bytes, 0, readCount)); } in.close(); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:34","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"为什么会有字符流? 用字节流读取英文字符与数字 没有问题 能够正常显示 用字节流读取中文字符 可能会有问题 ","date":"2021-04-19","objectID":"/posts/18_io/:0:35","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"一个字符在计算机当中是怎样存储的? 基于某个编码表，有与这对应的整数值(编码值)存储在计算机当中的 ","date":"2021-04-19","objectID":"/posts/18_io/:0:36","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"什么是编码? 基于某个编码表，把字符数据转化成编码值的过程 ","date":"2021-04-19","objectID":"/posts/18_io/:0:37","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"什么是解码? 基于某个编码表，把编码值转化成字符数据的过程 ","date":"2021-04-19","objectID":"/posts/18_io/:0:38","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"什么是 ASCII 表? 美国标准信息交换码 用一个字节的7位可表示，128 ","date":"2021-04-19","objectID":"/posts/18_io/:0:39","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"什么 ISO8859-1 码表? 拉丁码表，欧洲码表 用一个字节的8位表示 0000 0000 - 1111 1111 ","date":"2021-04-19","objectID":"/posts/18_io/:0:40","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"什么是 GB 码表? GB2312 中国的中文编码表 GBK 中国的中文编码表升级， 融合了更多的中文文字符号 GB18030 GBK的取代版本 BIG-5码 通行于台湾，香港地区的一个繁体它编码方案，俗称 “大五码” ","date":"2021-04-19","objectID":"/posts/18_io/:0:41","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"UTF-8 是什么样的? 是用可变长度来表示一个字符 UTF-8, 字定义一种 “区间规则”, 这种规则可以和 ASCII 编码保持最大程序的兼容 1字节 0xxxxxxx 2字节 110xxxxx 10xxxxxx 3字节 1110xxxx 10xxxxxx 10xxxxxxx ","date":"2021-04-19","objectID":"/posts/18_io/:0:42","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何获取 idea 默认的字符集? public class CountNum { public static void main(String[] args) throws IOException { Charset charset = Charset.defaultCharset(); System.out.println(charset); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:43","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"字符流的本质是什么? 字节流 + 编码表 ","date":"2021-04-19","objectID":"/posts/18_io/:0:44","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"如何实现字符的编码与解码? 编码 getBytes(String charsetName) 解码 String(byte[] bytes, String charsetName) public class CountNum { public static void main(String[] args) throws IOException { String s = \"你好\"; // 编码 byte[] utf8Encoding = s.getBytes(); System.out.println(Arrays.toString(utf8Encoding)); // 解码 String s2 = new String(utf8Encoding); System.out.println(s2); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:45","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"OutputStreamWriter 充当的是什么的角色? 如何使用? An OutputStreamWriter is a bridge from character streams to byte streams. public class CountNum { public static void main(String[] args) throws IOException { // 第一种构造方法 FileOutputStream fileOutputStream = new FileOutputStream(\"a.txt\"); OutputStreamWriter out = new OutputStreamWriter(fileOutputStream); // 第二种方法 OutputStreamWriter outputStreamWriter = new OutputStreamWriter(new FileOutputStream(\"a.txt\")); } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:46","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"OutputStreamWriter 如何实现写单个字符与字符数组? public class CountNum { public static void main(String[] args) throws IOException { // 定义字符串 String s = \"我要为你写65页ppt\"; // 创建转换输出流对象 OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(\"a.txt\")); // 写单个字符 writeSingle(s, out); // 写字符数组 writeMulti(s, out); out.write(s); out.flush(); out.close(); } private static void writeMulti(String s, OutputStreamWriter out) throws IOException { char[] chars = s.toCharArray(); out.write(chars); } private static void writeSingle(String s, OutputStreamWriter out) throws IOException { char[] chars = s.toCharArray(); for (int i = 0; i \u003c chars.length; i++) { out.write(chars[i]); } } } ","date":"2021-04-19","objectID":"/posts/18_io/:0:47","tags":["java"],"title":"18_io","uri":"/posts/18_io/"},{"categories":["王道"],"content":"什么是 File 类? File 类位于 java.io 包下， 是 java 进行 IO 操作的核心类， File 也是 I/O 的前置知识点 File 是文件和目录(文件夹)路径名的抽象表达形式 File类只是用文件/夹的路径来抽象的表示文件，那么这个路径下是否真的存在这个文件，它并不关心 File类在创建对象时，不关心文件是否存在，也不会抛出任何异常 ","date":"2021-04-18","objectID":"/posts/17_file/:0:1","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何获取当前 idea 相对路径? System.getProperty(“user.dir”) public class demo { public static void main(String[] args) { System.out.println(System.getProperty(\"user.dir\")); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:2","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"Java 如何转义路径? 可以用 //, \\ ","date":"2021-04-18","objectID":"/posts/17_file/:0:3","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何判断当前目录下 a 是否存在? public boolean exists() 绝对路径 public class demo { public static void main(String[] args) { File f = new File(\"/home/feng/IdeaProjects/day13/a\"); System.out.println(f.exists()); } } 相对路径 public class demo { public static void main(String[] args) { File f = new File(\"a\"); System.out.println(f.exists()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:4","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何判断 /home/feng/IdeaProjects/day13 下的 a 是否存在, 分开写? public class demo { public static void main(String[] args) { File f = new File(\"/home/feng/IdeaProjects/day13\", \"a\"); System.out.println(f.exists()); } } 转义后 public class demo { public static void main(String[] args) { File f = new File(\"//home//feng//IdeaProjects//day13\", \"a\"); System.out.println(f.exists()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:5","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何将子路径用 tempFile, 查找 /home/feng/IdeaProjects/day13 下有没有 a 文件 public class demo { public static void main(String[] args) { File tempFile = new File(\"//home//feng//IdeaProjects//day13\"); File f4 = new File(tempFile, \"a\"); System.out.println(f4.exists()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:6","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何查看 系统有关 的多个路径名的 分隔符 和 单个路径层级的分隔符 ? File.pathSeparator File.separator public class demo { public static void main(String[] args) { System.out.println(File.pathSeparator); System.out.println(File.separator); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:7","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何创建一个文件 1.txt? createNewFIle public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"1.txt\"); System.out.println(f1.createNewFile()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:8","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何创建一个目录 abc? mkdir 不能创建多级目录 public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"abc\"); System.out.println(f1.mkdir()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:9","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何创建 a/b/c 这种三级目录? mkdirs public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"a//b//c\"); System.out.println(f1.mkdirs()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:10","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何删除 1.txt delete public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"1.txt\"); System.out.println(f1.delete()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:11","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何删除一个不是空的目录? 递归删除非空目录 获取这个目录下的所有文件和文件夹的对象 做判断: 如果是文件, 直接删除 如果是目录，看它是不是空目录，如果是空目录，直接删除 如果不是空目录，递归去删除 ","date":"2021-04-18","objectID":"/posts/17_file/:0:12","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何将创建一个1文件并将其改名为2? renameTo public boolean renameTo (File dest) Renames the file denoted by this abstract pathname. public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"1\"); f1.createNewFile(); File f2 = new File(\"2\"); System.out.println(f1.renameTo(f2)); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:13","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何判断 1 是否表示一个文件? isFile() public boolean isFile() Tests whether the file denoted by this abstract pathname is a normal file. public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"1\"); System.out.println(f1.isFile()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:14","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何判断 1 是否表示一个目录? isDirectory public boolean isDirectory() Tests whether the file denoted by the this abstract pathname is a directory public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"2\"); System.out.println(f1.isDirectory()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:15","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何判断 2 是否存在? exists public boolean exists() Tests whether the file or directory denoted by this abstract pathname exists. public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"2\"); System.out.println(f1.exists()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:16","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何获取 2 文件或者目录的文件名? getName public String getName() Returns the name of of the file or directory denoted by this abstract pathname. public class demo { public static void main(String[] args) throws IOException { File f1 = new File(\"2\"); System.out.println(f1.getName()); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:17","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何遍历一个文件夹? public class Demo { public static void main(String[] args) { File f = new File(\".\"); String[] list = f.list(); System.out.println(\"增强for循环\"); for (String s : list) { System.out.println(s); } System.out.println(\"-------------------\"); System.out.println(\"toString\"); System.out.println(Arrays.toString(list)); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:18","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何遍历一个文件夹 (listFiles 数组)? public class Demo { public static void main(String[] args) { File f = new File(\".\"); File[] files = f.listFiles(); for (int i = 0; i \u003c files.length; i++) { System.out.println(files[i].getPath()); } } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:19","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何查看学习资料(对象必须是一个 文件 , 文件的后缀是 .mp4)? 用匿名内部类 public class Demo { public static void main(String[] args) { File f = new File(\".\"); File[] files = f.listFiles(new FileFilter() { @Override public boolean accept(File pathname) { String fileName = pathname.getName(); return pathname.isFile() \u0026\u0026 fileName.endsWith(\".mp4\"); } }); System.out.println(Arrays.toString(files)); } } class MyFileFilter implements FileFilter { @Override public boolean accept(File pathname) { return true; } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:20","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何查看学习资料(对象必须是一个 文件 , 文件的后缀是 .mp4)? 用lambda表达式? public class Demo { public static void main(String[] args) { File f = new File(\".\"); File[] files = f.listFiles((file) -\u003e { String fileName = file.getName(); boolean beyond = fileName.startsWith(\"Beyond\"); boolean filel = file.isFile(); return filel \u0026\u0026 beyond; }); System.out.println(Arrays.toString(files)); } } class MyFileFilter implements FileFilter { @Override public boolean accept(File pathname) { return true; } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:21","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何使用 lambda 表达式实现只看 文件夹中的文件? public class Demo { public static void main(String[] args) { File f = new File(\".\"); File[] file = f.listFiles(File::isFile); System.out.println(Arrays.toString(file)); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:22","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"@Deprecated 是什么意思? 这些方法往往都已经被新的方法替代了，但是这些方法没有被删除 ","date":"2021-04-18","objectID":"/posts/17_file/:0:23","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["王道"],"content":"如何实现递归删除目录? public class Work3 { public static void main(String[] args) { File file = new File(\"E:\\\\1\"); System.out.println(\"是否已经删完?\" + deleteDirectory(file)); } public static boolean deleteDirectory(File target) { File[] files = target.listFiles(); if (files == null || files.length == 0) { // files == null 为文件， files.length 为空目录 return target.delete(); } for (File file : files) { if (file.isDirectory()) { //如果是文件夹，删除里面的文件 deleteDirectory(file); } else { file.delete(); } } return target.delete(); } } ","date":"2021-04-18","objectID":"/posts/17_file/:0:24","tags":["java"],"title":"17_file","uri":"/posts/17_file/"},{"categories":["鸟哥的私房菜"],"content":"正则表达式与万用字符有什么区别? 万用字符 (wildcard) 代表的是 bash 操作接口的一个功能 正则表达式则是一种字串处理的表示方式 ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:1","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使用 demesg 列出核心讯息，再以 grep 找出内含 cpu 那行，并将捉到的关键字显色表示，且加上行号来表示? sudo dmesg | grep -n --color=auto 'cpu' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:2","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使用 demesg 列出核心讯息，再以 grep 找出内含 cpu 那行，并将捉到的关键字显色表示，且加上行号来表示, 同时在关键字所在行的前两行与后三行也一起捉出来显示? sudo dmesg | grep -n --color=auto 'cpu' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:3","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何捉出 regular_express.txt 中有 the 的行, 并提供行号? grep -n 'the' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:4","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何捉出 regular_express 中没有 the 的行，并提供等行号? grep -vn 'the' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:5","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何捉出 regular_express.txt 中有 the 的行(包括大小写), 并提供行号? grep -in 'the' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:6","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何捉出 regular_express.txt 中 test 和 taste 这两个单字? grep -n 't[ae]st' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:7","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何捉出 regular_express.txt 中 含有 oo 的行，但不想 oo 前有g? grep -n '[^g]oo' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:8","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何捉出 regular_express.txt 中 含有 oo 的行，但不想 oo 前有是小写字母? grep -n '[^[:lower:]oo]' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:9","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何捉出 regular_express.txt 中 开头不是英文字母小写的行? grep -n '^[[:upper:]]' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:10","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何捉出 regular_express.txt 中行尾以 . 结束的行? grep -n '\\.$' regular_express.txt \\ 是用来解除特殊意义的 Windows 的断行字符 (^M$) Linux 的断行字符 $ ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:11","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"^ 在字符集合符号([]) 与 ([])外有什么不同? 在[]里, [^] 表示反向选择 在[]外, ^[] 表示定位在行首 ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:12","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 regular_express 中的空白行? ‘^$’ grep -n '^$' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:13","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何显示 /etc/rsyslog.conf 中不要空白行， 不以#开头的行? grep -v '^$' /etc/rsyslog.conf | grep -v '^#' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:14","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"grep -n ‘goo*g’ regular_express.txt 是什么意思? 代表的是 重复0个或多个前面RE字符 goo*g 代表的是 gog, goog, gooog … 等 ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:15","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 中以g开头与g结尾的字串,当中的字符可有可无? grep -n 'g*g' regular_express.txt 这是不可以的 g*g 代表的是g, gg, ggg, gggg g.*g 可以实现 . 表示的是一个任意的字符 . 可以是0或多个重复前面的字符 grep -n 'g.*g' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:16","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 中以g开头与g结尾的字串,中间有2到5个o的字串? grep -n 'go\\{2,5\\}g' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:17","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 中以g开头与g结尾的字串,中间有2个以上o的字串? grep -n 'go\\{2,\\}g' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:18","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 以 # 开始的那一行，并列出行号? grep -n '^#' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:19","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 以 ! 结束的那一行，并列出行号? grep -n '!#' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:20","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 以(eve , eae, eee, e e)这样的行，并列出行号? grep -n 'e.e' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:21","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 含有单引号有行? grep -n \\' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:22","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 有 aay, afy, aly 的行? grep -n 'g[afl]y' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:23","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 有 oog, ood的行, 但不能是 oot 行? grep -n 'oo[^t]' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:24","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何实现捉出在 regular_express.txt 中 go 中, 的o 会出现2-3 的行? grep -n 'go\\{2,3}' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:25","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何以 ls -l 配合 grep 找出 /etc/ 下面文件类型为链接文件属性的文件名? 链接的标头是 lrwxrwxrwx ls -l /etc | grep '^l' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:26","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 的内容列出并且打印出行号，同时，将第2~5行删除? nl /etc/passwd | sed '2,5d' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:27","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 的内容列出并且打印出行号，同时删除第2行? nl /etc/passwd | sed '2d' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:28","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 的内容列出并且打印出行号，同时删除第3行到最后一行? nl /etc/passwd | sed '3,$d' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:29","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 的内容列出并且打印出行号，并在第二行后加上 drink tea 字样? nl /etc/passwd | sed '2a drink tea' a \\ text Append text, which has each embedded newline preceded by a backslash. ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:30","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 的内容列出并且打印出行号，并在第二行前加上 drink tea 字样? nl /etc/passwd | sed '2i drink tea' i \\ text Insert text, which has each embedded newline preceded by a blackslash ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:31","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 的内容列出并且打印出行号，并在第二行后加上 Drink tea or … 换行 drink beer? ? nl /etc/passwd | sed '2a Drink tea or ... \\ \u003e drink beer?' a \\ text Append text, which has each embedded newline preceded by a backslash. ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:32","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 2-5 行的内容取代为 “No 2-5 number”? nl /etc/passwd | sed '2,5c No 2-5 number' c \\ text Replace the selected lines with text, which has each embedded newline preceded by a backslash. ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:33","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 sed 仅列出 5,7 行的内容? nl /etc/passwd | sed -n '5,7p' n N Read/append the next line of input into the pattern space. ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:34","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"输出 /etc/man_db.conf， 抓取有 MAN 的行， 去掉有 # 的行， 空白行? 查找有 MAN 的行 cat /etc/man_db.conf | grep 'MAN' 去掉有 # 的行 cat /etc/man_db.conf | grep 'MAN' | sed 's/#.*$//g' 删除空白行 cat /etc/man_db.conf | grep 'MAN' | sed 's/#.*$//g' | sed '/^$/d' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:35","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 sed 将 regular_express.txt 内第一行结尾若为 . 则换成 ! ? sed -i 's/\\.$/\\!g' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:36","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 sed 直接在 regular_express.txt 最后一行 “# This is a test”? sed -i '$a # This is a test' regular_express.txt ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:37","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 last 登录者的数据取出来, 并取出前5行，列出第1列和第3列的数据，中间以tab格开? last -n 5 | awk '{print $1 \"\\t\" $3}' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:38","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 last 显示出登录者的前5行，抽取取用户名，显示当前处理行数, 该行有多少字段? last -n 5 | awk '{print $1 \"\\t lines \" NR \" \\t columns: \" NF}' NF The number of fields in the current record NR The ordinal number of the current record from the start of input. ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:39","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何从/etc/passwd(以冒号来作为字段的分隔), 文件中第一字段为账号, 第三字段则是 UID, 找出第三栏小于10以下的数据，并且仅列出账号与第三栏? cat /etc/passwd | awk '{FS=\":\"} $3 \u003c 10 {print $1 \" \\t \" $3}' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:40","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":" 为什么仅能在第二行才开始生效? 因为在读入第一行的时候，那些变量 $1, $2, 默认还是以空白键为分隔的，所以虽然定义了 FS=\":\". 仅能在第二行后才开始生效 ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:41","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":" 如何在第一行也可以生效? 预先设置 awk 的变量， 利用 BEGIN 这个关键字 cat /etc/passwd | awk 'BEGIN {FS=':'} $3 \u003c 10 {print $1 \" \\t \" $3}' ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:42","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"这两个代表什么意思? 4d3 左边第4行被删除 (d) 掉了, 基准是右边的第三行 6c5 左边文件的第六行被取代 (c) 成右边文件的第五行 ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:43","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何对比 github/Blog 与 github/Momo 两个目录之间的差异? diff github/Blog github/Momo ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:44","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"diff 与 cmp 有什么区别? diff 主要是以 “行” 为单位比对 cmp 则是以 “字节” 为单位比对 ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:45","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何在字节上对比， passwd.old, passwd.new? cmp passwd.old passwd.new ","date":"2021-04-18","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/:0:46","tags":["linux"],"title":"第十一章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"},{"categories":["王道"],"content":"How to convert a String to an integer? Integer.paraseInt(s); public class StringToInt { public static void main(String[] args) { String num = \"1234\"; int x = Integer.parseInt(num); System.out.println(x); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:1","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"What boxing and unboxing is courtesy of ? Boxing and unboxing is a courtesy of the complier, not the virtual machine source file public class TestBoxing { public static void main(String[] args) { Integer n = 1; Float x = 2.0f; System.out.println(true ? n : x); } } after complie public class TestBoxing { public TestBoxing() { } public static void main(String[] args) { Integer n = 1; Float x = 2.0F; System.out.println((float)n); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:2","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"在进行深拷贝时，如何实现一个空接口？ Cloneable 并不是自己实现的 ","date":"2021-04-16","objectID":"/posts/16_string/:0:3","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何将byte数组转成 String, 并输出它 ","date":"2021-04-16","objectID":"/posts/16_string/:0:4","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"在 JDK 源码当中， 涉及区间的方法，一般都是怎么规定区间的? 左闭右开 这种做法是为了适配数组从0开始的下标 ","date":"2021-04-16","objectID":"/posts/16_string/:0:5","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"会输出什么? 会直接输出整个 String ","date":"2021-04-16","objectID":"/posts/16_string/:0:6","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"String 对象中的不可变性，JVM 内存图是什么样的? ","date":"2021-04-16","objectID":"/posts/16_string/:0:7","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"静态常量池 是干什么的? 在用字面值常量给 String 对象赋值时，在编译时期就加入了 常量池 当常量池中已存在某位字符串对象时，当需要使用时，就不需要在堆上重新创建对象了，而是直接去指向这个常量池中的字符串对象 ","date":"2021-04-16","objectID":"/posts/16_string/:0:8","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"它们的值是什么? s.equals(s2) 是根据值来判断的 ","date":"2021-04-16","objectID":"/posts/16_string/:0:9","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"它们会输出什么? s3 == (s1 + s2) 肯定不能编译确定取值，必须运行期确定，那么它的对象就一定不在常量池，而在堆上 ","date":"2021-04-16","objectID":"/posts/16_string/:0:10","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"判断一个字符串是否为空可以采取什么样的方法? equals public class supertest { public static void main(String[] args) { String s = \"abc\"; System.out.println(\"\".equals(s)); } } 如果s是null, 会导致报错 ","date":"2021-04-16","objectID":"/posts/16_string/:0:11","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何比较这两个字符串，并忽略大小写? a.equalsIgnoreCase(b) public class supertest { public static void main(String[] args) { String s = \"abc\"; String s1 = \"ABC\"; System.out.println(s.equalsIgnoreCase(s1)); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:12","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何判断这个字符串否包含a? public class supertest { public static void main(String[] args) { String s = \"abc\"; System.out.println(s.contains(\"a\")); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:13","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何判断其是否以a开头? a.startsWith(“a”) public class supertest { public static void main(String[] args) { String s = \"abc\"; System.out.println(s.startsWith(\"a\")); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:14","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何判断其是否以c结尾? a.endsWith(“c”) public class supertest { public static void main(String[] args) { String s = \"abc\"; System.out.println(s.endsWith(\"c\")); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:15","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何输出其子字符串 world ? public class supertest { public static void main(String[] args) { String s = \"hello world\"; System.out.println(s.substring(6, s.length())); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:16","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"其会输出什么? 它会输出一个 Arrays, 里面的元素是 abc, 对应的编码值 ","date":"2021-04-16","objectID":"/posts/16_string/:0:17","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"其会输出什么? 它会输出一个 Arrays, 里面的元素是 a, b, c ","date":"2021-04-16","objectID":"/posts/16_string/:0:18","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"其会输出什么? 它会输出一个 字符串 ","date":"2021-04-16","objectID":"/posts/16_string/:0:19","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"其会输出什么? toLowerCase(), toUpperCase() ","date":"2021-04-16","objectID":"/posts/16_string/:0:20","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何将字符串s3全部以字符形式加入c2? getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) public class supertest { public static void main(String[] args) { char[] c2 = new char[20]; System.out.println(Arrays.toString(c2)); String s3 = \"我真是一个小天才儿童手表!\"; s3.getChars(0, s3.length(), c2, 0); System.out.println(Arrays.toString(c2)); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:21","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何将 hellq 中的 q 转换成 o String replace(char old, char new) ","date":"2021-04-16","objectID":"/posts/16_string/:0:22","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何删除字符串左右的空格? a.trim() public class supertest { public static void main(String[] args) { String a = \" hello \"; String a1 = a.trim(); System.out.println(a1); } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:23","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"Comparable 接口是干什么的? String 类是一个实现了 Comparable 接口的类 所有实现 Comparable 接口的类， 都可以通过 Arrays.sort(数组) 或者 Collections, sort 集合进行排序 这种排序称之为 自然排序 compareTo 方法被称为它的 自然比较方法 ","date":"2021-04-16","objectID":"/posts/16_string/:0:24","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"如何实现按照年龄大小进行排序? public class supertest { public static void main(String[] args) { Student[] studs = new Student[3]; Student s1 = new Student(11, 2, \"123\"); Student s2 = new Student(132, 7, \"1223\"); Student s3 = new Student(21, 1, \"12333\"); Student s4 = new Student(51, 4, \"1231231\"); Student s5 = new Student(61, 2, \"125343\"); Student[] stud = {s1, s2, s3, s4, s5}; System.out.println(Arrays.toString(stud)); Arrays.sort(stud); System.out.println(Arrays.toString(stud)); } } class Student implements Comparable { int age; int id; String name; public Student() { } public Student(int age, int id, String name) { this.age = age; this.id = id; this.name = name; } } 从小到大， 左减去右 public class supertest { public static void main(String[] args) { Student[] studs = new Student[3]; Student s1 = new Student(11, 2, \"123\"); Student s2 = new Student(132, 7, \"1223\"); Student s3 = new Student(21, 1, \"12333\"); Student s4 = new Student(51, 4, \"1231231\"); Student s5 = new Student(61, 2, \"125343\"); Student[] stud = {s1, s2, s3, s4, s5}; System.out.println(Arrays.toString(stud)); Arrays.sort(stud); System.out.println(Arrays.toString(stud)); } } class Student implements Comparable { int age; int id; String name; public Student() { } public Student(int age, int id, String name) { this.age = age; this.id = id; this.name = name; } @Override public int compareTo(Object o) { Student targetStu = (Student) o; return this.age - targetStu.age; } @Override public String toString() { return \"age=\" + age; } } ","date":"2021-04-16","objectID":"/posts/16_string/:0:25","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"除了 compareTo 方法，类中还有 equals 方法判断两个对象是否相等, 建议这两个方法同 true 同 false , 应该如何做到? 只需要做到 age 相等即可 必须保证 equals() 方法重写和 compareTo() 方法重写保持一致的方式 ","date":"2021-04-16","objectID":"/posts/16_string/:0:26","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"常用的自然排序的方法是什么? Comparable 接口实现自然排序麻烦且不方便 使用带 Comparator 比较器的 sort 方法， ( Arrays 和 Collections) 中都有该方法 ","date":"2021-04-16","objectID":"/posts/16_string/:0:27","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"在 Comparator 接口中有两个抽象方法 compare 和 equals, 为什么它还是抽象方法? 接口的实现类一定还继承了 Object 所以抽象方法 equals 不需要实现， 它只需要实现一个抽象方法 compare , 它仍然是功能接口 ","date":"2021-04-16","objectID":"/posts/16_string/:0:28","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"在 Comparator 接口中有两个抽象方法 compare 和 equals, 为什么还要多写一个 equals? 这里把 equals 方法作为一个抽象方法是提示你重写它，如果不重写可能会有些矛盾 ","date":"2021-04-16","objectID":"/posts/16_string/:0:29","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"自然排序在开发中有什么作用? 用 SQL 操作数据库， 然后进行排序 (SQL排序) , 这种做法是常用的，但SQL有时候会有效率问题 一旦 SQL 的排序出现了效率问题，而一时没有太好的办法解决 可以先把数据读到集合当中，然后对集合进行自然排序，然后把数据返还给前端，所以自然排序有时候可以用来解决 SQL 排序的效率问题 ","date":"2021-04-16","objectID":"/posts/16_string/:0:30","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"What’s the difference between code point and code unit? A code point is the atomic unit of information. Text is a sequence of code points. Each code point is a number which given meaning by the Unicode standard. A code unit is the unit of storage of a part of the encoded code point. In UTF-8 this means 8-bits, in UTF-16 this means 16-bits. ","date":"2021-04-16","objectID":"/posts/16_string/:0:31","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"What’s the difference between StringBuilder and StringBuffer? StringBuffer: It is slightly less efficient, but it allows multiple threads to add or remove character. StringBuilder If all string editing happens in a single thread (which is usually the case), you should use it. ","date":"2021-04-16","objectID":"/posts/16_string/:0:32","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"Why it return NullPointerException? 如果 java 程序要与 windows 下的 cmd 或者 Linux 下的 Terminal 交互， 就可以使用这个 java Console 类代劳. Java 要与 Console 进行交互式， 不总是能得到可用的 java Console 类的， 一个 JVM 是否有可用的 Console , 依赖于底层平台和 JVM 如何调用。 如果 JVM 是交互式命令行 (比如Window的cmd) 中启动的，并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的 Console 实例 但当使用 Eclipse 等IDE运行以上代码时 Console 中将会为 null ","date":"2021-04-16","objectID":"/posts/16_string/:0:33","tags":["java"],"title":"16_string","uri":"/posts/16_string/"},{"categories":["王道"],"content":"What’s the different between Date class and LocalDate class? Date class: which represents a point in time LocalDate class: which expresses days in the familiar calendar notation public class InputTest { public static void main(String[] args) { System.out.println(LocalDate.now().plusDays(1)); System.out.println(LocalDate.of(1999, 12, 31)); System.out.println(new Date().toString()); } } ","date":"2021-04-15","objectID":"/posts/15_date/:0:1","tags":["java"],"title":"15_date","uri":"/posts/15_date/"},{"categories":["王道"],"content":"如何实现 Data 的匹配模式? SimpleDateFormat is a concrete class for formatting and parsing dates in a locale-sensitive manner. It allows for formatting (date -\u003e text), parsing (text -\u003e date), and normalization. parse Parse a date/time string according to the given parse position public class Demo { public static void main(String[] args) throws IOException, ParseException { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss\"); //1. 格式化 Date d = new Date(3742762088000L); String timeStr = sdf.format(d); System.out.println(timeStr); //2.解析 String time = \"2077/07/07 07:07:07\"; Date parse = sdf.parse(time); System.out.println(parse.getTime()); } } ","date":"2021-04-15","objectID":"/posts/15_date/:0:2","tags":["java"],"title":"15_date","uri":"/posts/15_date/"},{"categories":["王道"],"content":"如何计算现在到1970年多少年了? 并返回当时的时间? public void setTime(long date) Set an existing Date object using the given milliseconds time value. public class Demo { public static void main(String[] args) { Date d = new Date(); long time = d.getTime(); System.out.println(time / (1000L * 3600 * 24 * 365)); d.setTime(0); System.out.println(d); } } ","date":"2021-04-15","objectID":"/posts/15_date/:0:3","tags":["java"],"title":"15_date","uri":"/posts/15_date/"},{"categories":["王道"],"content":"什么是异常? 异常 程序运行时期出现了问题，出现了不正常的情况，称之为 异常 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:1","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"什么是编译出错? 编译出错 在程序的编译时期不能通过编译器的语法检查，所以报错 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:2","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"什么是异常类? java 当中一切皆对象， 当程序产生异常， JVM 会把这个异常信息封装成一个对象(类) 类中封装着问题的名称, 产生的原因， 描述等多个属性信息存在 以及对这些信息进行操作的一系列方法 这些类通过继承层次构成了 java 的异常体系 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:3","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"异常中有什么需要注意的? 异常的类和对象中只是存了异常的信息 包括异常的原因，异常的种类等等 何时抛出异常，怎么处理异常，不是由异常对象决定的 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:4","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"java 中对异常体系是如何划分的? Throwable (祖先类) Error Exception RuntimeException 非RuntimeException Throwable 是 java 一切错误和异常的父类，是继承层次中的祖先类 Error 是严重问题， 无法被解决 - Error 描述了 java 运行时虚拟机内部错误和资源耗尽错误 对于 Error , 程序自己是无能为力的，仅靠程序本身是无法恢复和预防 于是程序只能尽量安全的保存数据，然后终止程序，并通知用户去解决 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:5","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"Exception 有什么分类? RuntimeException 运行时异常 非RuntimeException 编译时异常 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:6","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如果错误产生在 main 方法中， java 是怎么处理的? 当我们的代码执行到错误行数之前，代码是正常执行的 当我们的代码执行到错误行数时，JVM 会终止程序的执行，抛出一个该异常信息封装成的对象 将该对象中异常信息，打印到控制台上，告诉程序员发生了什么问题 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:7","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如果错误产生在 main 方法中的另一个方法中，java 是怎么处理的? 当程序执行到该方法的错误行数时， JVM 会终止程序的执行 向上给方法的调用者抛出一个该异常信息封装的对象 一直向上抛出，直到抛给 main 方法， main 方法最终抛给 JVM 发生异常之前的语句正常执行，但是之后的语句都不执行了 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:8","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"什么是单分支的 try…catch, 其语法是什么? try { 可能出现异常的，正常的代码逻辑 } catch (要捕捉的异常对象){ 在catch分支中处理具体类型的代码异常 } ","date":"2021-04-14","objectID":"/posts/14_exception/:0:9","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"在 try…catch 中 的 catch 如何写? public class Sort { public static void main(String[] args) { try { System.out.println(\"1111\"); System.out.println(10/0); System.out.println(\"2222\"); } catch (ArithmeticException ae){ System.out.println(\"发生了算数除0异常\"); } System.out.println(\"3333\"); } } catch 中必须是一个抛出异常类的对象声明 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:10","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"try..catch 中代码是如何执行的? 如果 try 当中没有异常 那么 try 中的代码会正常执行完毕， catch 也叫异常处理器，如果没有异常，那么它不会工作，既然没有异常，整个 try…catch 后的代码正常执行 如果 try 当中有异常 恰好能够被 catch 捕获， try 当中发生异常之前的代码， 正常执行 异常那行代码会抛出异常，被 catch 捕获， 然后执行 catch 中的代码 因为异常被捕获和处理了， 不会再抛给 jvm 了，程序不会终止执行 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:11","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"在 try … catch 当中可能产生几个异常? 最多产生一个异常，也可能不产生异常， 因为一旦产生异常 try 代码后的不执行了 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:12","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如果在 try … catch 异常没有被捕获会发生什么? try 当中异常之前的代码仍然会正常执行，后面的不执行 但是这个异常没有被捕获，仍然抛给了 jvm ,终止程序打印异常信息，这个时候相当于没有 try…catch 异常处理 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:13","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如何采取单分支 try…catch 同时处理多个异常，而不依赖于父类? 语法: catch(要捕捉的异常类型1 | 要捕捉的异常类型2 | 要捕捉的异常对象对象名… ) try 当中最多有一个异常，对象名只有一个 | 不是逻辑运算符中的或， 更不能用短路的， 它表示的是可以同时匹配 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:14","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"printStackTrace() 方法是做什么的? public class Sort { public static void main(String[] args) { try { System.out.println(10/0); } catch (ArithmeticException e) { e.printStackTrace(); } } } 打印出异常 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:15","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如何实现多分支异常? public class Sort { public static void main(String[] args) { int[] arr = new int[3]; try { System.out.println(10 / 0); System.out.println(arr[4]); arr = null; System.out.println(arr.length); } catch (ArithmeticException e) { System.out.println(\"发生了除0异常\"); e.printStackTrace(); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"发生了数组越界异常\"); e.printStackTrace(); } catch (NullPointerException e) { System.out.println(\"发生了空指针异常\"); e.printStackTrace(); } } } ","date":"2021-04-14","objectID":"/posts/14_exception/:0:16","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如何实现 接盘侠 ? 用其父类来接盘 public class Sort { public static void main(String[] args) { int[] arr = new int[3]; try { System.out.println(10 / 0); System.out.println(arr[4]); arr = null; System.out.println(arr.length); } catch (ArithmeticException e) { System.out.println(\"发生了除0异常\"); e.printStackTrace(); } catch (ArrayIndexOutOfBoundsException e) { System.out.println(\"发生了数组越界异常\"); e.printStackTrace(); } catch (NullPointerException e) { System.out.println(\"发生了空指针异常\"); e.printStackTrace(); } catch (Exception e){ System.out.println(\"我是接盘侠父类 Exception\"); e.printStackTrace(); } } } ","date":"2021-04-14","objectID":"/posts/14_exception/:0:17","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"若要实现处理除0异常，但是空指针和下标越界异常一起处理, 该如何做? ","date":"2021-04-14","objectID":"/posts/14_exception/:0:18","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"thorws 方法有什么用? 在方法声明时使用，声明该方法可能抛出的异常类型 语法: 方法名(形参列表) throws 异常列表{ } thorws 加了一个s, 表示一个复数，它可以抛出的异常列表可以是多个异常 这个异常列表只表示可能性，表示可能会抛出这些异常，并不是真的一定抛出 所以 throws 关键字后面写异常的类名即可，不需要是一个对象 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:19","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"父子类方法重写 throws 异常列表的关系的总体原则是什么? 子类重写的方法不能抛出更多的异常 多态， 编译看左边， 父类方法没有异常不需要处理 结果运行起来子类的方法有抛出异常需要处理 这显然是矛盾了 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:20","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"方法抛出更多的运行时异常，叫不叫抛出更多的异常? 为什么? 不叫 意味着子类比父类抛出更多的运行时异常是没有问题的 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:21","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"throw 关键字是干什么的? throw 是一个单数， 所以它表示确定的抛出一个异常 throw + 异常对象 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:22","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如何获取一个异常对象? 通过查看一个异常的构造方法 自定义的编译时异常: 继承Exception 自定义的运行时异常: 继承RuntimeException ","date":"2021-04-14","objectID":"/posts/14_exception/:0:23","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"throw + 运行时异常一般是怎么用的? 表示在方法中抛出运行时异常对象 这里抛出异常后，方法要在这里终止执行了，后面的代码都不会执行了，这种效果很类似于 return throw + 运行时异常对象， 用来替代 return 作为方法的返回值 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:24","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如何一个方法不知道该返回什么返回值时，应该如何处理? 用 throw + 运行时异常 来 替代 return 作为方法的返回值 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:25","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如何 catch， 判断是否实现空接口? public class demo { public static void main(String[] args) { A a = new A(); try { checkCloneable(a); } catch (CloneNotSupportedException e) { e.printStackTrace(); System.out.println(\"请实现空接口!\"); } System.out.println(\"111\"); } private static void checkCloneable(A a) throws CloneNotSupportedException { if (a instanceof Cloneable) { System.out.println(\"实现了Cloneable接口，允许进行克隆操作, 程序正常执行\"); } else { throw new CloneNotSupportedException(\"没有实现Cloneable接口\"); } } } interface Cloneable { } class A { } ","date":"2021-04-14","objectID":"/posts/14_exception/:0:26","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"在设置年龄时大于150抛出异常\"你活不了这么大\", 小于0抛出异常\"你还没出生吗? public class demo { public static void main(String[] args) { Student s = new Student(); s.setAge(151); } } class Student { public int age; public Student() { } public void setAge(int age) { if (age \u003e 150) { throw new IllegalArgumentException(\"你活不能这么大\"); } else if (age \u003c 0) { throw new IllegalArgumentException(\"你还没出生吗？\"); } else { this.age = age; } } } ","date":"2021-04-14","objectID":"/posts/14_exception/:0:27","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"编译期异常和运行期异常有什么区别? 编译期异常 必须要显式处理，否则编译不通过 运行期异常 可以不处理，也不以处理 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:28","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"throws 和 throw 有什么区别? throws 用在方法声明后面，跟的是异常类名 可以跟多个异常类名，用逗号隔开 表示抛出异常，由该方法的调用者来处理 throws 表示出现异常的一种可能性，并不一定发生这些异常 throw 用在方法体内，跟的是异常对象名 只能抛出一个异常对象 表示抛出异常，可以由方法体内的语句处理 表示抛出了异常，执行 throw 则一定抛出了某种异常 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:29","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"finally 关键字有什么用? 它一般跟着 try…catch 一起使用, 放在整个 try…catch 的后面 作用 try 中产生异常，并且正常捕获，finally 代码块正常执行，之后的代码也正常执行 try 中没有产生异常，catch 异常处理器不执行了，finally 代码块仍然正常执行，其后的代码也正常执行 try 中产生异常，但是没有正常捕获，jvm 会终止方法的执行， try…catch 之后的代码不执行了，但是 finally 仍然执行了 无论try中什么情况，finally代码块都要执行 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:30","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"当 try 当中有 return 时会出现什么情况? 如果这个 return 在产生异常的代码后面，其实是没啥用，如果在前面，不能这么写 如果 catch 中有 return, 并且 catch 正常执行，那么仍然会执行 finally 后再回去 catch 中 return finally 当中如果有 return , finally 还会执行 如果 finally 和 catch 中都有 return, 咋办? ","date":"2021-04-14","objectID":"/posts/14_exception/:0:31","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"如何不执行 finally 语句? System.exit(0) 关掉虚拟机 public class demo { public static void main(String[] args) { try { int[] arr = null; throw new ArithmeticException(); } catch (ArithmeticException e) { e.printStackTrace(); } finally { System.out.println(\"finally代码块执行了\"); System.exit(0); return; } } } ","date":"2021-04-14","objectID":"/posts/14_exception/:0:32","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"Can I use finalize method for cleanup? Do not use the finalize method for cleanup. That method was intended to be called before the garbage collector sweeps away an object. However, you simply cannot know when this method will be called, and it is now deprecated. ","date":"2021-04-14","objectID":"/posts/14_exception/:0:33","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"final, finalize, finally 有什么区别? final 修饰符， 修饰 class , 方法， 变量 类: 不可继承类 方法: 不可重写方法 变量: 变量的值无法修改, 但是不会改变变量在内存中的位置 数据类型: 引用中的地址不变，但是引用的对象仍然可以修改 finalize 没用，类似析构函数 finally 和 try…catch 或者 try 一起使用，是一定会执行的代码块, 比起 fialize 释放资源，更安全更高效 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:34","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"自定义异常有哪几种? 编译时异常: 定义一个类， 继承 Exception, 就是一个编译时异常 运行时异常: 定义一个类，继承 RuntimeException, 就是一个运行时异常 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:35","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"怎么写自定义异常类的构造方法? 直接去调用父类构造器就可以 super 参数 public class Demo { public static void main(String[] args) { try{ testThrowRuntimeException(); } catch (ARuntimeException e){ e.printStackTrace(); System.out.println(\"模拟处理\"); } try{ testThrowException(); } catch (AException e){ e.printStackTrace(); System.out.println(\"模拟处理\"); } } public static void testThrowRuntimeException() {throw new ARuntimeException(\"自定义的运行时异常\");} public static void testThrowException() throws AException { throw new AException(\"自定义的编译时异常\"); } } class ARuntimeException extends RuntimeException { public ARuntimeException() { super(); } public ARuntimeException(String message){ super(); } } class AException extends Exception { public AException(){ super(); } public AException(String message){ super(message); } } ","date":"2021-04-14","objectID":"/posts/14_exception/:0:36","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"自定义异常有什么用? 如果直接使用 jdk 已有的异常， 比如 IllegalArgumentException 这个异常，看起来是可以实现效果的 但是如果 try 当中的代码， 本身也会产生这个异常 IllegalArgumentException ， 那么就不能区分对待，不能分别处理了 所以自定义异常可以区分自己写的代码的错误，不使用源码中已有的异常，避免混淆 ","date":"2021-04-14","objectID":"/posts/14_exception/:0:37","tags":["java"],"title":"14_exception","uri":"/posts/14_exception/"},{"categories":["王道"],"content":"什么是 API ? Application Programming Interface(API) 应用程序编程接口，在Java 当中指的是一些先定义好的类和方法 作用 开发者可以在不关注具体实现细节的前提下，使用和这些已经预先定义好的类和方法实现自己的需求 ","date":"2021-04-13","objectID":"/posts/13_object/:0:1","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"Object 类有什么特点? Object 类所有类继承层次的祖先类, 所有类(包括数组)都 直接或间接的继承 自该类，都实现了该类的方法 在自定义类时，并不需要特别标注 extends Object 如果一个类没有明确的的指出它的父类，Object 类就默认被认为是这个类的父类，extends Object 则被省略了 ","date":"2021-04-13","objectID":"/posts/13_object/:0:2","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"为什么所有类都有一个默认无参? 当一个类没有定义构造方法的时候，就会自动添加默认构造方法 一旦有默认构造方法，在创建子类对象的时候，就会执行子类对象的隐匿初始化 隐式初始化，默认调用父类的无参构造 最终，一定能保证，调用到 Object 类的无参构造方法，先初始化 Object 这个父类 ","date":"2021-04-13","objectID":"/posts/13_object/:0:3","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"为什么不能访问 clone 方法 clone 方法是 protect 修饰的， 只能在自己的子类中访问 ","date":"2021-04-13","objectID":"/posts/13_object/:0:4","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"方法声明中 public final Class\u003c?\u003e getClass() 分别代表什么意思? public 访问权限，调用时不必考虑权限问题 final 该方法可以被继承但是不能被重写 Class 返回值类型， Class 是大写的 class , 它表示一个类，说明该方法的返回值是 Class 对象 表示泛型 getClass 是方法名 () 表示方法不需要参数 ","date":"2021-04-13","objectID":"/posts/13_object/:0:5","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"Class 对象是什么对象? Class类是什么类? Class 对象 是该类的运行时对象 ","date":"2021-04-13","objectID":"/posts/13_object/:0:6","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"Class 对象 与 该类的对象有区别吗? 有 ","date":"2021-04-13","objectID":"/posts/13_object/:0:7","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"如何判断这两个类是否是相同的 Class对象? 不同的类，运行不同的Class对象 ","date":"2021-04-13","objectID":"/posts/13_object/:0:8","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"它们是相等的吗?为什么? 同一个类运行时的 class 对象是唯一的 ","date":"2021-04-13","objectID":"/posts/13_object/:0:9","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"运行时对象 和 类的对象 有什么区别? 运行时对象 也叫类对象，整个程序运行期间独一份，不可能有两个 类对象 想创建几个就有几个 ","date":"2021-04-13","objectID":"/posts/13_object/:0:10","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"getName() 与 getSimpleName() 如何使用? getSimpleName Return the simple (unqualified) name of this element. getName Get the name of the category of which this attribute value is an instance 这两个方法都是 Class 方法 需要用 getClass() 先获取 Class 然后用 Class 获取 getName, getSimpleName public class Demo { public static void main(String[] args) { Student s = new Student(); Class clClazz = s.getClass(); System.out.println(clClazz.getName()); System.out.println(clClazz.getSimpleName()); } } class Student { } ","date":"2021-04-13","objectID":"/posts/13_object/:0:11","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"public String toString() 是什么意思? 访问权限不用考虑 返回值是一个字符串 不需要任何参数 It is recommended that all subclasses override this method ","date":"2021-04-13","objectID":"/posts/13_object/:0:12","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"是什么意思? return getClass().getName() + “@” + Integer.toHexString(hashCode()); getClass().getName() 一个类的全限定类名 + “@” Interger.toHexString(hashCode()) 返回对象的十六进制的地址值 ","date":"2021-04-13","objectID":"/posts/13_object/:0:13","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"会输出什么? return getClass().getName() + “@” + Integer.toHexString(hashCode()); 一个类的全限定类名 + @ + 对象的十六进制的地址值 ","date":"2021-04-13","objectID":"/posts/13_object/:0:14","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"如何改写 toString() , 在哪里? 在对应的类中必写 toString() ","date":"2021-04-13","objectID":"/posts/13_object/:0:15","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"public boolean equal(Object obj) 是什么意思? 首先不用关心访问权限 返回值的类型是 boolean , 要么是 true , 要么是 false 意味着所有的类的对象都可以传入 ","date":"2021-04-13","objectID":"/posts/13_object/:0:16","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"What are the Java Language Specification requires that the equals method have properites? reflexive For any non-null reference x, x.equals(x) should return true. symmetric For any references x and y, x.equals(y) should return true if and only if y.equals(x) return true. transitive For any references x, y and z , if x.equals(y) return true and y.equals(z) return true, then x.equals(z) should return true. consistent If the objects to which x and y refer haven’t changed, then repeated calls to x.equals(y) return the same value. non-null For any non-null reference x, x.equals(null) should return false. ","date":"2021-04-13","objectID":"/posts/13_object/:0:17","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"How to write the perfect equals method? Name the explicit parameter otherObject Test whether this happens to be identical to otherObject if (this == otherObject) return true; Test whether otherObject is null and return false if it is. if (otherObject == null) return false; Compare the classes of this and otherObject subclasses if (getClass() != otherObject.getClass()) return false; all subclasses if (!(otherObject instanceof ClassName)) return false; Cast otherObject to a variable of class type ClassName other = (ClassName) otherObject Compare the fields, as required by notion of equality return field1 == other.field1; ","date":"2021-04-13","objectID":"/posts/13_object/:0:18","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"如何判断对称性? y.equal(x) 返回 true 时， x.equal(y) 也应返回 true 使用成员变量的取值来判断对象相等，这一条就会自动满足，因为成员变量的取值就是一个值，数学意义上肯定满足对称性 ","date":"2021-04-13","objectID":"/posts/13_object/:0:19","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"如何在重写 equals 中满足 自反性 ? 判断它是否是同一个对象 x.equals(obj) public boolean equals(Object obj){ if (this == obj){ return true; } } ","date":"2021-04-13","objectID":"/posts/13_object/:0:20","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"什么是 BigDecimal 类? Immutable, arbitrary-precision signed decimal numbers ","date":"2021-04-13","objectID":"/posts/13_object/:0:21","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"如何用 BigDecimal 实现 1 - 0.9 ? public BigDecimal substract (BigDecimal subtrahend) Returns a BigDecimal whose value is (this - subtrahend), and whose scale is max(this.scale(), subtrahend.scale()) public class Demo { public static void main(String[] args) { System.out.println(1 - 0.9); BigDecimal b1 = new BigDecimal(\"1\"); BigDecimal b2 = new BigDecimal(\"0.9\"); BigDecimal b3 = b1.subtract(b2); System.out.println(b3); } } ","date":"2021-04-13","objectID":"/posts/13_object/:0:22","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"若在 equals 方法中允许子类对象来比较是否相等, 该如何实现排他性? 就不能用 getClass() 方法了，需要使用 instanceof 做类型判断 因为 instanceof 允许传入子类对象，而不仅仅是它自身的对象 ","date":"2021-04-13","objectID":"/posts/13_object/:0:23","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"public int hashCode() 是什么意思? 返回该对象的哈希码值，方法返回的 int 结果就是哈希码值 ","date":"2021-04-13","objectID":"/posts/13_object/:0:24","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"What is a native method? If a method is a native method, not implementd in the Java programming language. Native methods can bypass the access control mechanisms of the Java language. ","date":"2021-04-13","objectID":"/posts/13_object/:0:25","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"public native int hashCode() 中的 native 是什么意思? native 方法: 特指那些 java 代码中去调用 C/C++ 实现的方法，本地方法虽然不是抽象方法，但是, 不是java实现的方法 ","date":"2021-04-13","objectID":"/posts/13_object/:0:26","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"如何用 hashCode 判断两个 Teacher 对象是否相等? public class Demo { public static void main(String[] args) { Teacher t1 = new Teacher(19, \"张三\", 1000); Teacher t2 = new Teacher(19, \"张三\", 1000); System.out.println(t1.hashCode() == t2.hashCode()); } } class Teacher { int age; String name; int salary; public Teacher() { } public Teacher(int age, String name, int salary) { this.age = age; this.name = name; this.salary = salary; } } ","date":"2021-04-13","objectID":"/posts/13_object/:0:27","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"equals 方法 与 hashCode 方法有什么应用? 集合当中会优先调用 equals 方法用来比较两对象是否相等，如何相等，它就不会输入集合 但是如何 equals 方法认为对象相等， 但是 hashCode() 方法返回值却不同，就会导致一个认为不应该存，一个认为应该存的情况发生， 这显然是不合理的 equals 方法如果重写， 就必须重写 hashCode 方法 ","date":"2021-04-13","objectID":"/posts/13_object/:0:28","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"protected void finalize() throws Throwable {} 是什么意思? protected 不同包下必须在子类中创建子类自身对象才能够访问 void 方法没有返回值 throws Throwable 抛出异常 ","date":"2021-04-13","objectID":"/posts/13_object/:0:29","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"protected void finalize() throws Throwable {} 中的 { } 方法体是空的，这个方法有什么意义? 这种空的方法，然后又是 protected 权限， 是为了保证子类自由的重写该方法，并且保证该方法不会被子类外的其他类滥用 ","date":"2021-04-13","objectID":"/posts/13_object/:0:30","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"空接口有什么用? 一个类实现了某个接口，并不仅仅是简单的继承成员，更重要的它数据类型发生了变化，它成为了接口的实现子类 可以用 instanceof 关键字进行判断该引用指向的对象是否是接口的实现类对象 public class Demo { public static void main(String[] args) { A a = new A(); if (a instanceof IEmptyInterface) { System.out.println(\"A实现了空接口，程序正常执行\"); } else { System.out.println(\"报错，抛出异常\"); } } } class A implements IEmptyInterface { } interface IEmptyInterface { } ","date":"2021-04-13","objectID":"/posts/13_object/:0:31","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"Can I have to write that public class Employee extends Object? NO The ultimate superclass Object is taken for granted if no superclass is explicitly mentioned. ","date":"2021-04-13","objectID":"/posts/13_object/:0:32","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"Where is the hash code come from? A hash code is an integer that is derived from an object. The hashCode method is defined in the Object class. Therefore, every object has a default hash code. That hash code is derived from `the object’s memory address. ","date":"2021-04-13","objectID":"/posts/13_object/:0:33","tags":["java"],"title":"13_object","uri":"/posts/13_object/"},{"categories":["王道"],"content":"new 类名().new 类名() 与 new 类名.new 这两种方式有什么区别? new 类名().new 类名() 创建成员内部类 new 外围类类名.new 静态内部类类名() 创建静态内部类 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:1","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"局部内部类有什么优缺点? 优点 绝对的封装性，并且可以少创建一个 class, 相对来说简单一点 缺点 局部内部类作用域仅限于方法，如果别的类， 别的方法也想用这个类 做不到 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:2","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"可以进行吗?为什么? 可以，任何时候都有父类，哪怕是实现了一个接口 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:3","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":", 为什么 a++ 无法执行? 生命周期的问题 方法的局部变量的生命周期和方法同生共死, 方法出栈就销毁 但是 局部内部类的方法会创建对象 于是出现方法出栈后，局部变量销毁了，但是对象仍然需要使用该局部变量的情况 为了解决这种生命周期的冲突，jvm 会在创建局部内部类对象时，把方法的局部变量作为对象的成员变量加了进去 这个成员变量和局部变量值同步的问题 如果在局部内部类当中， 把这个局部变量给修改了，那就必须同步这个修改，否则程序就有问题 但是这样显然太复杂了，java 的开发都觉得不想做了，于是直接把这个局部变量声明为 final 做为一个常量，直接不修改，就不需要考虑同步问题 Java8 之前，如果想用局部内部类访问方法的局部变量， 该局部变量必须声明为 final Java8 之后， 这个限制被解除了，改为在底层直接加上 final, 不需要程序再加了 这就是 语法糖 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:4","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"匿名内部类 和 lambda 的局部变量有什么特殊的地方? 匿名内部类 和 lambda 本质的是 局部内部类 它们的局部变量仍然是 final 修饰的 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:5","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"内部类实现多继承的思路是什么? ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:6","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"内部类有什么优缺点? 优点 无条件地访问外围类的所有元素 成员内部类, 静态内部类, 局部内部类, 匿名内部类 都可以无条件访问 隐藏类 可以用 private, protected 修饰类 private 修饰成员内部类, 提供 public 的创建对象方法 实现多继承 可以创建多个成员内部类继承外部多个类 然后创建内部类对象，实际上就是外围类继承了多个类的成员 通过匿名内部类来优化简单的接口实现 缺点 语法复杂 内部类就应该给外围类用，不需要给外部类用，给它用是有风险的 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:7","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何调用输出\"我在学习局部内部类\"? ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:8","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"什么是匿名类(Anonymous Class)? 如果一个类没有名字，那么这个类就是匿名类 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:9","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何定义一个匿名内部类? new 接口名/类名(普通类, 抽象类) () { }; ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:10","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何实现? (朴素做法) Outer 是一个 class, 类名点调用方法，代表这个方法是静态成员方法 链式调用后面又调用了一个 show 方法，这意味着 Outter.method() 方法的返回值是对象 show 方法是接口 Inter 的抽象方法，所以 method 方法的返回值就是接口的实现类对象 public class Demo { public static void main(String[] args) { Outer.method().show(); } interface Inter { void show(); } class Outer { public static InterImpl method() { return new InterImpl(); } } class InterImpl implements Inter { @Override public void show() { System.out.println(\"hello world!\"); } } ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:11","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何实现? (高端做法) Outer 是一个 class, 类名点调用方法，代表这个方法是静态成员方法 链式调用后面又调用了一个 show 方法，这意味着 Outter.method() 方法的返回值是对象 直接返回这个接口对象，重写 show() 方法 public class Demo { public static void main(String[] args) { Outer.method().show(); } } interface Inter { void show(); } class Outer { public static Inter method() { return new Inter() { @Override public void show() { System.out.println(\"hello, world!\"); } }; } } ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:12","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何实现将匿名内部类作为 test() 方法的参数，重写 eat() 方法? public class Demo { public static void main(String[] args) { test(new AbstractPerson() { @Override void eat() { System.out.println(\"我是人，我要吃饭\"); } }); } public static void test(AbstractPerson as) { as.eat(); } } abstract class AbstractPerson { int age; String name; void eat() { } ; } ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:13","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何通过创建出父类成员变量赋值过的匿名内部类对象? public class Demo { public static void main(String[] args) { new AbstractPerson(18, \"zhangsan\") { @Override void eat() { System.out.println(this.age + \"\\t\" + this.name); } }.eat(); } public static void test(AbstractPerson as) { as.eat(); } } abstract class AbstractPerson { int age; String name; public AbstractPerson() { } public AbstractPerson(int age, String name) { this.age = age; this.name = name; } void eat() { } } public class Demo { public static void main(String[] args) { test(new AbstractPerson(18, \"zhangsan\") { @Override void eat() { System.out.println(this.age + \"\\t\" + this.name); } }); } public static void test(AbstractPerson as) { as.eat(); } } abstract class AbstractPerson { int age; String name; public AbstractPerson(){} public AbstractPerson(int age, String name){ this.age = age; this.name = name; } void eat() { }; } ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:14","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"匿名内部类 new 类名() 这个括号有什么用? 这个括号可以传参数，给父类成员赋值 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:15","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"什么是 lambda 表达式? lambda 是 JDK8 的一个新特性 lambda 就是匿名内部类更进一步，语法上更简洁了，代码更优雅了 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:16","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"lambda 有什么需要注意的地方? 它是用来取代 接口的匿名内部类, 不能取代普通类和抽象类的匿名内部类 对接口有严格的要求: 有且仅有一个抽象方法需要子类实现, 这种接口被称这为 功能接口 (function interface) ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:17","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何判断一个接口是否是功能接口? 用注解去检测 @FunctionalInterface 有且仅有一个抽象方法需要子类实现, 称之为 功能接口 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:18","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"lambda 表达式与 功能接口 有什么关系? lambda 表达式是在方法内部创建功能接口的 实现类对象 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:19","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"What the Syntax of Lambda Expressions? If a lambda expression has no parameters, you still supply empty parentheses. If the parameter types of a lambda expression can be inferred, you can omit them. If a method has a single parameter with inferred type, you can even omit the parentheses. ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:20","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"lamba 语法是什么? () -\u003e {} () 是形参列表，无需传入实际参数, 功能接口中那个唯一的抽象方法的形参列表 -\u003e 是 lambda 运算符, 可以读作 goes to {} 中放的是抽象方法重写的方法体 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:21","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"为什么要求功能接口中有且仅有一个抽象方法? 因为 lambda 方法中型参表只有一个 方法体也只有一个， 没办法重写两个方法，只能重写一个 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:22","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何采取直接告诉该对象的类型，直接用接口引用指向它? public class Demo { public static void main(String[] args) { IA ia = () -\u003e { System.out.println(\"hello world!\"); }; ia.test(); } } @FunctionalInterface interface IA { void test(); } ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:23","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何采取直接告诉该对象的类型，不接收它，并调用 test 方法? public class Demo { public static void main(String[] args) { ((IA) () -\u003e { System.out.println(\"hello world!\"); }).test(); } } @FunctionalInterface interface IA { void test(); } ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:24","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"可以这样写吗? 可以, 在 lambda 表达式重写方法体中 只有一条语句 ，可以省略大括号 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:25","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"可以这样写吗? 为什么? 如果这个抽象方法是有返回值的，并且它的返回值语句只有一行，那么 return 就不需要了 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:26","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"可以这样写吗? 为什么? 可以，把方法的实现，指向一个已经存在的方法中是可以的 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:27","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何判断 已存在的方法 和 功能接口中的抽象方法 是一样的? 只用看 返回值类型 和 形参列表 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:28","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"可以这样写吗?为什么? 在调用其他方法时，可以用 方法归属者::方法名 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:29","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"如何判断一个方法的归属者? 成员方法 属于对象， 所以需要先创建对象， 再指向 静态成员方法，属于类，直接类名放上去 ","date":"2021-04-12","objectID":"/posts/12_lambda/:0:30","tags":["java"],"title":"12_lambda","uri":"/posts/12_lambda/"},{"categories":["王道"],"content":"什么是内部类? 嵌套定义在 一个类的内部 的类 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:1","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"内部类有什么用? 封装 私有化 CPU 这个类后，就不能在 Computer 外部访问这个类了 内部类互相访问 两个独立的类之间受访问权限限制，而当一个类进入另一个类内部成为内部类就不再受访问权限限制了，可以互相访问私有成员 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:2","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"内部类如何分类? (成员位置， 局部位置) 定义在成员位置 成员内部类 普通成员内部类 静态内部类 定义在局部内部类 匿名局部内部类 lambda ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:3","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"什么是成员内部类?其定义是什么? 成员内部类 最普通的内部类， 它定义在另一个类的成员位置，可以看成该类的一个成员 语法 [访问权限修饰符] class EnclosedClazz{ [访问权限修饰符] class InnerClazz{ } } ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:4","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"普通的类有几种访问权限修饰符? 两种，没有 protected , private class 是用来被实例化的，所以只有 默认 和 public 访问权限修饰符 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:5","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"成员内部类的访问权限修饰符有哪些? 成员内部类相当于外围类的成员了，有4种访问权限 public , protected , 默认， private 其中 private 最为常见 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:6","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"什么是类加载? 类加载时机有哪些? 类加载: 是一种懒加载，用到的时候才加载，不得不加载才加载 时机 new 对象 执行 main 方法 访问类的静态成员 子类类加载触发父类类加载, 并且在子类之前 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:7","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"成员内部类的类加载情况有哪些? 创建内部类对象 成员内部类想创建对象，必须依赖于外围类，在外围类对象的基础上，才能创建成员内部类对象 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:8","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"成员内部类中可以有普通成员变量，静态成员变量，全局变量吗? 可以有普通成员变量 不能有静态成员变量 可以有全局常量, 但是那些会触发类加载的全局常量不能有 普通成员变量与静态成员变量 全局常量 内部类只有依赖于外围类来触发类加载, 其他都不行 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:9","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"成员内部类中成员方法特点是什么样的? 可以 有普通成员方法 没有静态成员方法 静态成员方法会触发类加载 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:10","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"成员内部类中有没有构造器和代码块? 构造器 必须有，需要创建对象，需要给成员变量赋值 代码块 静态代码块 没有 构造代码块有 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:11","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"成员内部类与外围类相互依赖而存在吗? 不是 成员内部类对象 依赖于 外围类对象而存在 外围类对象 并不依赖于 成员内部类对象 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:12","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"外部的类可以继承内部类吗? 可以 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:13","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"成员内部类有什么特点? 成员内部类和外围类是亲兄弟，自己人，它们之间的访问 不受访问权限限制， 即便私有的，它们也可以互相访问 成员内部类的对象 依赖于外围类对象 而存在 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:14","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"成员内部类的成员方法中，有没有外围类对象? 有， 有外围类对象才能有内部类对象，内部类对象存在了，外围类对象必然存在 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:15","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"外围类的成员方法中，有没有成员内部类对象? 没有， 外围类对象和内部类对象没有依赖关系，如果想有，需要手动创建 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:16","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"若成员内部类中和外围类成员有同名，怎么办? 普通成员变量同名 什么都不加，就近原则，优先选择内部类自身的成员 可以用 this , 表示内部类自身的成员 内部类的成员方法中必然有外围类对象，也有一个引用指向它，作类一个隐藏的传参，用 外围类的类名.this 表示 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:17","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"如果成员内部类中静态成员变量同名怎么办? 成员内部类中 没有静态成员变量 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:18","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"如果成员内部类中全局常量同名怎么办? 用类名去区分 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:19","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"什么是静态内部类? 在一个成员内部类基础上，加一个 static 修饰即可 静态内部类也是处在 外围类 成员位置的内部类, 不同的是它需要使用 static 修饰 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:20","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"如何定义一个静态内部类? [访问权限修饰符] class EnclosedClazz { [访问权限修饰符] static class InnerClazz { } } ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:21","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"静态内部类的外围(普通)类的访问权限修饰符有哪些? public 和 缺省的 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:22","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"内部类的访问权限修饰符有哪些? 4种 public, private, 缺省的, protected ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:23","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"静态内部类是外围类的静态成员吗? 不是 其实两个类没有太大关系 静态内部类和外围类没有依赖关系，实际上它完全可以脱离外围类，独立的自己做一个类 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:24","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"静态内部类可以独立做类，它的成员和普通类有什么区别? 它的成员和普通类没有区别 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:25","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"静态内部类可以继承 普通类 吗和 静态类 吗? 不可以继承 普通类 可以继承 静态类 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:26","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"静态内部类什么时候类加载? 静态内部类类加载需不需要依赖外围类?如何证明? 静态内部类和外围类没有依赖关系，实际上它完全可以脱离外围类，独立的自己做一个类 静态内部类的加载不需要依赖外围类 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:27","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"静态内部类的成员方法中，有没有外围类对象? 静态内部类与外围类互相不影响 静态内部类中 没有 外围类对象 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:28","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"外围类对象的成员方法中，有没有静态内部类? 静态内部类与外围类互相不影响 外围类对象中 没有 静态内部类 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:29","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"静态内部类访问外围类有什么特点? 需要创建对象, 除了不受访问权限限制， 其它的和普通类访问一样 public class Demo { //外部类 public static void main(String[] args) { EnclosedClazz.Inner inner = new EnclosedClazz.Inner(); inner.test(); } } class EnclosedClazz { //外围类 int a = 10; private int b = 20; static int c = 30; static final int D = 40; static class Inner { int a = 100; private int b = 200; static int c = 300; static final int D = 400; public void test() { EnclosedClazz ec = new EnclosedClazz(); System.out.println(ec.a); System.out.println(ec.b); System.out.println(EnclosedClazz.c); System.out.println(EnclosedClazz.D); System.out.println(this.a); } } } ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:30","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"外围类访问静态内部类成员有什么特点? 需要创建对象, 除了不受访问权限限制， 其它的和普通类访问一样 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:31","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"外部类访问静态内部类成员有什么特点? 直接创建静态内部类对象， 受访问权限限制 创建对象以后,访问成员，也受访问权限限制 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:32","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"静态内部类访问外部类成员有什么特点? 直接创建外部类对象，受访问权限限制 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:33","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"其答案是什么? ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:34","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"什么是局部内部类? 定义在 一个方法或者一个作用域 里面的类 将局部内部类看成是 局部变量 即可 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:35","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"局部内部类有没有访问权限修饰符? 没有， 方法的作用域已经限制 了这个局部内部类，无需访问权限再限制 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:36","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"局部内部类有没有 static 修饰符? 没有, 局部变量不需要 static 修饰 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:37","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"局部内部类的类加载时机有哪些? 调用外面的方法 在方法中创建这个局部内部类的对象 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:38","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"在方法体中创建局部内部类的对象应该写在哪里? 1处还是2处? 2处, 在方法中，局部内部类的声明 下面创建对象 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:39","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"局部内部类的成员特点是什么样的? 和成员内部类一样，没有静态成员，有全局常量 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:40","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"局部内部类定义在哪里? 局部位置 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:41","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"什么时候用局部内部类? 当在局部位置，碰到了一个麻烦的问题，需要使用类来解决 但是又 不希望这个类被外界知道 ，这种情况需要使用局部内部类 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:42","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"可以在外部类中创建局部内部类对象吗? 不可以 ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:43","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"调用这方法的思路是什么?(土办法调用)? 新建一个 class, 这个 class 中有 method 方法 class 是一个接口的实现, 接口中有 method, class 改写 method 接口 class 是 接口 的子类 public class Demo { public static void main(String[] args) { test(new IAImpl()); } public static void test(IA a) { a.method(); } } interface IA { void method(); } class IAImpl implements IA { @Override public void method() { System.out.println(\"土办法调用test()方法\"); } } ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:44","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"调用这方法的思路是什么(如何采用内部类的方式实现)? 如果一个方法需要传入接口或抽象类，应该 传它们的子类对象 如果一个方法需要返回接口或抽象类，应该 返回它们的子类对象 public class Demo { public static void main(String[] args) { test(test2()); } public static void test(IA a) { a.method(); } public static IA test2() { class IAImpl implements IA { @Override public void method() { System.out.println(\"高端的调用test()方法 \"); } } return new IAImpl(); } } interface IA { void method(); } ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:45","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"如何输出这三个 num ? Outer需要创建对象， 所以需要Outer().new public class Demo { public static void main(String[] args) { Outer.Inner inner = new Outer().new Inner(); inner.show(); } } class Outer { public int num = 10; class Inner { public int num = 20; public void show() { int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); } } } ","date":"2021-04-10","objectID":"/posts/11_innerclass/:0:46","tags":["java"],"title":"11_InnerClass","uri":"/posts/11_innerclass/"},{"categories":["王道"],"content":"[toc] ","date":"2021-04-09","objectID":"/posts/10_interface/:0:0","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"子类对象初始化成员变量赋值的顺序是什么样的? 默认初始化, 默认值 去找创建子类对象会调用的构造方法，看第一行有没有 this(), super(), 如果有就去执行，如果没有，默认有 super() 仍然去执行 肯定要跳到 父类构造器 ，然后从 上到下 执行父类中的 显示赋值 和 构造代码块 ，最后执行父类的构造器 如果子类构造器中有 this, 回到子类 this 构造器. 如果没有 this, 直接就回去，从上到下执行子类中的显示赋值和构造代码块，然后执行 this 构造器，然后跳到最开始的构造器 直接执行该构造器，而不会显式赋值和构造代码块 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:1","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"如何定义一个接口? 语法: 与 class 定义一样，接口是和 class 同等级别的数据类型 [访问权限修饰符] interface 接口名{} All methods of an interface are automatically public Howerver , when implementing the interface, you must declare the method as public, Otherwise the compiler assumes that the method has package access - the default for a class. ","date":"2021-04-09","objectID":"/posts/10_interface/:0:2","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口的命名规范是什么样的? 采取 大驼峰式 的 有些程序员，喜欢在接口名的第一个单词之前加一个\"I\" 用来区分这是一个接口 interface ISpecialSkills{ public void walkUpright(){ } } ","date":"2021-04-09","objectID":"/posts/10_interface/:0:3","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"如何在接口中定义方法是怎么规定的? 接口中的抽象方法不能有方法体 但是可能定义方法 This particular interface has single method. Some interfaces have multiple methods. ","date":"2021-04-09","objectID":"/posts/10_interface/:0:4","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"可以在接口中定义中加public abstract 定义方法体吗? 不可以，默认已经加上了 在接口中的抽象方法，默认都是 public abstract 修饰的，这两个关键字无需再加，默认就有 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:5","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口中有继承的概念吗? 类与接口之间不用继承的概念，用 实现 的概念 (implements) ","date":"2021-04-09","objectID":"/posts/10_interface/:0:6","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口可以多实现吗? 继承有单继承限制，但是接口不受该限制，接口可以多实现 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:7","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"is-a 与 like-a 有什么区别? is-a 关系的是 两个类之间的关系 ，如果两个类没有任何实际联系，用继承是不合适的 like-a 关系的 实现强调功能的扩展， 它不必考虑两个类(接口)之间的实际关系 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:8","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"空接口，有什么作用? 一个类实现了一个接口，不管这个接口有没有东西，它都变成了 这个接口的子类 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:9","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"类与接口有区别吗? 类 定义的是一个 数据集合，基于这个数据集的一组 操作(行为) 类所描述的这一组行为，它们是有关系的(间接) ， 都可以访问同一个数据集合 接口 表示数据类型，侧重于描述一组具有 特殊功能的行为 这些行为可以完全 没有任何关系, 接口中的方法，它们的关系比较的松散 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:10","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口可以实例化吗? 不可以 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:11","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口和继承同时存在时，应该如何定义? 将接口放在继承类后面 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:12","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"为什么接口不可以实例化? 在接口的声明中， 默认有 abstract, 接口也是一个抽象的概念，它不能创建实例 这个关键字是可以省略的 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:13","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口的访问权限是什么? 普遍来说它的访问权限都是 public 的，是鼓励去实现接口的，但是 public 不是默认的，它的访问权限是可以修改的 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:14","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口的成员特征是什么样的? 接口中没有 普通成员变量 和 静态成员变量, 接口的成员变量默认 public static final 修饰的全局常量 普通成员变量 静态成员变量 public static final ","date":"2021-04-09","objectID":"/posts/10_interface/:0:15","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口中声明全局常量的正确格式是什么样的? Although you cannot put instance fields in an interface, you can supply constants in them. Just as methods in an interface are automaically public, fields are always public static final ","date":"2021-04-09","objectID":"/posts/10_interface/:0:16","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"Can I declare a interface variable? yeah Comparable x; x = new Employee(..); provided Employee implements Comparable ","date":"2021-04-09","objectID":"/posts/10_interface/:0:17","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口中可以放静态代码块吗? 不可以 虽然接口中的成员变量都是全局常量，但是接口中 不允许静态代码块 ，所以接口中全局常量 必须显式赋值 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:18","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口中有普通方法实现吗? 没有，接口中没有普通的方法实现，都是抽象方法， 并且默认是 public abstract 修饰的 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:19","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"写接口实现类的格式, 其包名最好怎么取? 需要实现接口的包下, 新建一个包 impl 实现类, 类的命名为 接口名 + Impl ","date":"2021-04-09","objectID":"/posts/10_interface/:0:20","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口中有没有构造方法? 接口中没有构造方法，没有需求，既不能创建对象，以没有成员给子类赋值 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:21","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口的子类的特点是什么? 接口的子类如果是一个 普通类 ，必须 实现全部抽象方法 接口的子类如果是一个 抽象类, 可以 选择实现一部分，也可以 全部都不实现 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:22","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口的子类可以是一个接口吗? 可以 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:23","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"什么样的关系是继承? 什么样的关系是实现? 类与类之间叫 继承 接口与接口之间叫 继承 类与接口之间叫 实现 继承 是不能跨越种族的，同种数据类型之间相互继承，类是单继承的，接口是多继承的 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:24","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口与接口成员默认是 public 还是 private 修饰的? 默认都是 public 修饰的, 鼓励继承，鼓励重写 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:25","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"接口与类之间是什么样的关系? 并列的数据类型 ","date":"2021-04-09","objectID":"/posts/10_interface/:0:26","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"The compareTo method of the Comparable interface returns an integer. And, it doesn’t work for floating-point numbers, What should I do to solve this problem? Why? The difference salary - other.salary can round to 0 if the salaries are close toether but no identical. The call Double.compare(x, y) simply return -1 if x \u003c y or 1 if x \u003e y @Override public int compareTo(Employee other) { return Double.compare(salary, other.salary); } ","date":"2021-04-09","objectID":"/posts/10_interface/:0:27","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"A class must do a avail itself of the sorting service - it must implement a compareTo method. But Why can’t the Employee class simply provide a compareTo method without implementing the Comparable interface? The reason for interfaces is that the Java programming languae is strongly typed. When making a method call, the compiler needs to be able to check that the method actually exist. Somewhre in the sort method will be statements like this: if (a[i].compareTo(a[j] \u003e 0)) { // rearrange a[i] and a[j] ... } The compiler must know tha a[i] actually has compareTo method If a is an array of Comparable objects, then the existence of the method is assured because every class that implements the Comparable interface must supply the method. ","date":"2021-04-09","objectID":"/posts/10_interface/:0:28","tags":["java"],"title":"10_interface","uri":"/posts/10_interface/"},{"categories":["王道"],"content":"其jvm内存结构图是什么样的? ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:1","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"对于编译而言，怎么才能保证编译不报错? 两个引用之间是父子关系 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:2","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"什么是 instanceof 关键字?如何使用? 引用 instanceof 类名，表示该引用指向的对象，是否是后面类的对象(或子类对象) 如果是就返回 true, 否则就返回 false ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:3","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"怎么才能保证运行时不报错? 该父类引用指向的子类对象，就是这个要强制的子类的对象 否则会报 ClassCastException 类型转换异常的错误 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:4","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"What will happen x instance of C, if x is null? It simply returns false. That makes sense: null refers to no object, so it certainly doesn’t refer to an object of type c ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:5","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"如何声明一个抽象类? 语法 [访问权限修饰符] abstract class 类名{} ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:6","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"Does abstract classes can be instantied? No If a class is declared as abstract, no objects of that class can be created. But you can still create object variables of an abstract class, but such a variable must refer to an object of a nonabstract subclass. Here p is a variable of the abstract type Person that refers to an instance of the nonabstract subclass Student. Person p = new Student(\"Vince Vu\", \"Economics\"); ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:7","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类一般如何命名? 用 AbstractXxx 来命名抽象类 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:8","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类的成员变量与普通类的成员变量有区别吗? 没有区别 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:9","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类可以允许定义成员方法吗? 可以 假设现有抽象类的子类中有一些方法的实现是可以被共用的，就可以抽取到抽象类中去共享它，去复用成员，复用代码 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:10","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"可以继承复用静态方法吗? 静态方法 是不能被重写的，子类中同名的静态方法是独立的 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:11","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类中可以允许没有抽象方法吗? 允许 如果一个抽象类中没有抽象方法， 是没有太大的意义的 普遍来说，抽象类中就应该有抽象方法 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:12","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"有些程序员喜欢直接将一个类加上 abstract 声明，将该类变为抽象类，目的是让这个类无法创建对象，这种方式好吗? 为什么? 不好 因为抽象类是一个设计处于 顶层祖先类的抽象概念 ，设计抽象类的目的不仅仅是创建对象 想让一个类无法创建对象，最好还是私有化构造方法 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:13","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象方法可以用 final , static, private 修饰吗? 都不可以 private 私有的方法可以继承但是没有权限， 就无法重写，抽象方法没有方法体，如果不重写没有任何意义，所以抽象方法显然不能是 private static 静态方法没有办法重写，所以也不能在抽象方法中 final final 方法不能被重写， 所以也不能用在抽象方法中 总结: 抽象方法被声明出来，就量要被重写的，所以不应该限制它的重写，而应该去鼓励它重写，所以普遍来说抽象方法的访问权限都是 public ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:14","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类中有没有构造方法? 抽象类中是 有构造器 的 抽象类自己不能用构造器，这个构造器 给子类对象初始化用的 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:15","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"Java 中所有类都有构造方法吗? 类 = 普通类 + 抽象类 它们都有构造方法 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:16","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类的子类有要求吗?(只能是抽象类或具体类) 抽旬类的子类可以是抽象类，也可以是具体类 具体类 只有当子类重写了，所有的继承自抽象类的方法，该子类才能被定义为具体类 抽象类 若抽象方法没有重写，则定义为抽象类 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:17","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类可以继承吗? 可以 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:18","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类可以继承一个具体类吗? 可以 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:19","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"抽象类中可以继承一个抽象类吗? 可以 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:20","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"abstract 只能用来修饰什么? 只能用来修饰 class 和 方法 ","date":"2021-04-08","objectID":"/posts/09_abstract/:0:21","tags":["java"],"title":"09_abstract","uri":"/posts/09_abstract/"},{"categories":["王道"],"content":"[toc] ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:0","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"若想限制创建 Student 类个数, 其思路是什么? 如果允许外部直接创建对象，显然 无法控制创建对象的个数 需要计数器指示外部创建对象的个数 解决方法: 私有化构造方法 提供一个方法来创建对象, 访问权限是 public 这个方法必须是 静态方法 控制创建对象的计数器，应该是 静态成员变量 ，被所有对象共享 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:1","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"在 set, get方法怎样赋值比较好( 如width )? 用 this 好 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:2","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"如何不希望外界创建数组 =null 的对象，应该如何做? 私有化无参构造 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:3","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"在增删改时，如果结果成功或失败了，可以选择在方法中输出成功或失败的消息吗? 不可以， 输出成功或失败 不应该 是在 增删改 方法里该做的事情 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:4","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"为了防止 studs 出现空指针异常， 可以习惯性怎么做? 判null 和 判空 if (studs == null || studs.length == 0){ return new Student[0] } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:5","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"在 jvm 中，如何区分 this 和 super 关键字? ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:6","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"构造代码块时，父类的构造器执行了吗? 构造代码块会在创建对象的时候，随着构造器执行 父类的构造器也执行了，并且它 在子类的构造器之前执行 所以说，创建子类对象的时候，隐含了父类构造器的执行 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:7","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"子类对象的初始化方式称为什么?具体是什么样的? 隐式初始化 在子类的每个构造器当中， 如果第一行没有 this(), 它都隐含了一个 super() 去调用父类的无参构造 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:8","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"创建子类对象会调用父类吗? 若第一行没有 this() , 会从隐含 的 super() 去调父类的无参构造 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:9","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"this() 与 super() 调用构造器都需要在第一行，它们可以共存吗? 不行 因为, 第一行隐含了 super() 如果允许不在第一行， 会导致重复给父类成员赋值，显然是错误的 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:10","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"super 和 this 有什么区别? 有什么用途? 区别: this 表示自己的对象，它不受访问权限控制 super 是在子类中表示父类的对象, 受访问权限控制 用途: this 可以区分同名的成员变量和局部变量形参 super 和 this 一起使用可以用来区分父子类中同名的成员(包括方法和变量), 区分的 前提仍然是访问权限 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:11","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"如何使用 this 和 super 调用父类和子类的值? public class supertest { public static void main(String[] args) { Student st = new Student(); System.out.println(\"获取父类a的值\"); st.getSuper(); System.out.println(\"获取this类a的值\"); st.getA(); } } class Person { int a = 10; } class Student extends Person { int a = 20; public void getSuper() { System.out.println(super.a); } public void getA() { System.out.println(this.a); } } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:12","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"父子类中可以出现同名的变量吗? 可以 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:13","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"输出的是20, 这个a是被覆盖掉了，还是因为某些原因没有覆盖但是访问不到, 如何证明? public class supertest { public static void main(String[] args) { Student st = new Student(); System.out.println(\"获取父类a的值\"); st.getSuper(); System.out.println(\"获取this类a的值\"); st.getA(); } } class Person { int a = 10; } class Student extends Person { int a = 20; public void getSuper() { System.out.println(super.a); } public void getA() { System.out.println(this.a); } } a 不是被覆盖掉了, 仍然可以去访问它 使用对象名点成员变量的方式访问变量时，编译器 存在一个 检索机制 它首先会去从引用所在的那个类中去找这个成员变量 如果这个引用找不到，就去父类中找，找完所有的父类，直到 Object， 都找不到，它会编译报错 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:14","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"当引用数据类型与它的具体类型不一样时，会根据什么来决定它的最终取值? 根据引用的类型来取值 public class supertest { public static void main(String[] args) { Father f = new Son(); System.out.println(f.a); } } class Father { int a = 10; int b = 100; public int getFatherA() { return a; } } class Son extends Father { int a = 20; public int getSonA() { return a; } } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:15","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"成员变量隐藏的原理是什么样的? 当使用对象名点成员变量的方式访问变量时，编译器存在一个检索机制，会首先从引用所有的那个类中去找这个成员变量 如果这个引用找不到，就去父类中找，找完所有的父类，直到 Object, 都找到，它会编译报错 因为这种检索机制父子类中同名的成员变量就找到不父类中去了，父类的成员被隐藏了 对象名点访问成员变量，在编译时期就能够确定它访问的是哪个类的成员变量，就是那个 引用的类 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:16","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"静态成员变量可以被子类继承吗? 可以 public class supertest { public static void main(String[] args) { System.out.println(B.a); } } class A{ static int a = 10; } class B extends A { } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:17","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"父子类中同名的静态成员变量， 它们之间有什么关系? 覆盖了还是隐藏又或者是其他的了? 静态的成员 不属于对象， 而我们讨论继承的时候，一般都是说对象的继承，对象和静态成员没有关系 所以静态成员不要用继承去讨论，不同类的静态成员完全是独立的，它们 不存在隐藏或者覆盖 这种关系 public class supertest { public static void main(String[] args) { System.out.println(B.a); } } class A{ static int a = 10; } class B extends A { } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:18","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"若继承中有静态成员的需求，可以采用什么样的方法去访问父类的静态成员? 采用子类的类名访问静态成员 public class supertest { public static void main(String[] args) { System.out.println(B.a); B.a = 888; System.out.println(B.a); System.out.println(A.a); } } class A { static int a = 10; } class B extends A { static int a = 100; } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:19","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"父子类能否出现同名的方法? 可以 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:20","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"创建子类对象，并用子类的引用指向对象，调用方法, 它的访问结果是什么? 方法被覆盖了 用对象名点方法名编译器同样有类似的 检索机制: 先从引用的类型中去找，找不到, 从父类中找，直到完全找不到, 再报错 原因: 对象名点方法名编译器同样有类似的检索机制: 先从引用的类型中去找，找不到, 从父类中找，直到完全找不到报错 这种检索机制导致引用类型中有的成员方法 才能被调用 编译器在检索时，只能知道变量的类型，在编译时期，如果想要通过编译，所访问的成员，必须是这个类型中有的 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:21","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"在方法的覆盖原理中，方法的最终执行结果，是由什么所决定的? 方法的最终执行结果，不是在编译时期决定的，而是程序运行起来以后，根据引用所指向的实际类型决定的 如果有同名的方法，因为方法被覆盖掉了，所以显示出子类的一个特征 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:22","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"@Override 注解是什么样的? 如何使用? 两个父子类之间发生方法的重写后，可以用一个注解指示被覆盖的方法 @Override 注解 这个注解可以检查 两方法之间是否发生了方法重写，如果不是方法重写, 会报错 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:23","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"若要进行方法重写，需要注意什么? 不必要完全一模一样，但是肯定是有限制的 注意 重写的方法 访问权限 必须 大于等于 原方法，要比父类的方法的访问权限更 松 父类的私有方法 没有权限访问，不能够发生方法重写 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:24","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"如果方法覆盖了，可以访问被覆盖的方法吗? super 关键字可以用来区分子类同名 public class supertest { public static void main(String[] args) { Cat c = new Cat(); c.test(); c.invokeSonTest(); c.invokeSonTest2(); c.invokeFatherTest2(); } } class Animal { public void test() { System.out.println(\"Animal\"); } } class Cat extends Animal { @Override public void test() { System.out.println(\"Cat\"); } public void invokeSonTest() {test();} public void invokeSonTest2() {this.test();} public void invokeFatherTest2() {super.test();} } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:25","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"静态方法可以继承和重写吗? 子类 可以继承 父类的静态成员方法 如果同名了，不是方法的重写，它们是独立的两个方法, 只不过凑巧同名了 静态方法 不能重写 public class supertest { public static void main(String[] args) { A.test(); B.test(); } } class A { static void test() { System.out.println(\"A\"); } } class B extends A { static void test() { System.out.println(\"B\"); } } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:26","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"什么是 final 关键字? final 修饰类表示最终的类，表示一个不能被继承的类 final 修饰类时，放在访问权限修饰符和class之间，表示该类无法被继承 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:27","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"什么时候用 final 来修饰类? 不需要复用成员 功能已经特别强大， 足够满足需求 需要绝对保证安全，以致于不让它被继承 常见的final类 String System Math ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:28","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"If I want to prevent someone from forming a subclass of my classes, what can I do? Classes that cannot be extended are called final classes. All methods in a final class are automatically final, not the fields Use the final modifier in the definition of the class to indicate this. ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:29","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"If I make a specific method in a class final, what will happen? no subclass can override that method. ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:30","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"用 final 来修饰的类可以继承和重写吗? final 应该放在访问权限修饰符的后面，返回值的前面 final 修饰的方法无法被重写，但是可以被继承 public class supertest { public static void main(String[] args) { } } class A { public final void test() { } } class B extends A { @Override public void test() { } } ‘test()’ cannot override ‘test()’ in ‘com.feng.A’; overridden method is final ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:31","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"final 修饰的变量， 最终表示的是什么? 表示最终的变量，表示一个常量 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:32","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"常量的分类是什么样的? 字面值常量 “hello world!” 10 true null 自定义常量 用 final 修饰的变量就是自定义的常量 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:33","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"final 修饰一个成员变量会怎样? 它只是让这个变量的取值无法改变，但是在内存中的位置不变 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:34","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"final 修饰一个基本数据类型的变量会怎样? 表示这个基本类型的变量取值无法改变 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:35","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"final 修饰一个引用数据类型的变量会怎样? 表示引用是一个常量时，表示地址不变了，也就是指向的对象不变了，对象的属性(状态)仍然可以改变 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:36","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"在方法中有哪些地方有局部变量? 方法体中 形参列表 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:37","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"用 final 修饰方法体中的局部变量会怎样? 表示定义了一个局部的常量，意味着，方法的后面就不能修改它的取值了 如果只声明了一个局部常量，那么可以赋值一次，后面就无法再赋值了 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:38","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"用 final 修饰形参列表，会怎么样? 表示的是传入的参数已经成为一个常量了，无法修改 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:39","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"final修饰成员变量哪些要求? 显示赋值 构造代码块 构造器 以上三种方法，选择一种即可，介是也仅仅只能用一种，因为赋值一次，之后不能修改了 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:40","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"加上无参的构造方法，会不会报错? 会，因为无参构造不能保证每个对象都能给常量赋值 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:41","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"用 final 修饰 静态成员变量是什么? final修饰静态成员变量是全局常量 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:42","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"final 修饰的变量，其命名规范是什么? 字母全部大写，每个单词之间用下划线(\"_\") 如 MY_AGE = 18 MY_NAME = 长风 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:43","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"final 在哪些时候可以修饰静态成员变量? 静态成员变量的赋值方式： 类加载时期： 显式赋值 静态代码块 创建对象时期: (创建对象时，早已经触发类加载了) 构造代码块 构造器 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:44","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"是用 final static 还是 static final 好? 建议用 static final ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:45","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"访问 final 修饰的成员变量会触发类加载吗? 如果该全局常量是 基本数据类型， 不会触发类加载 如果该全局常量是 引用数据类型, 不一定会触发 String 如果用 字面值常量 直接赋值的，不会触发类加载 String 如果是 用构造器 创建的对象，会触发类加载 如果是除了 String 之外的 自定义类，会触发类加载 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:46","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"如何用 final 修饰引用数据数据?会出现什么情况? public class FinalTest { public static void main(String[] args) { final C c = new C(); c.a = 10; } } class C { int a = 10; } 表示该引用已经成为一个常量了，它里面的地址不能再改变了 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:47","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"final 修饰匿名对象可以吗? 不可以，不合法 public class FinalTest { public static void main(String[] args) { final new C(); } } class C { int a = 10; } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:48","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"什么是多态? 同一个事物，在不同的情况下，表现出不同的行为 在 java 面向对象当中， 多态指的是: 同一个事物: 同一个引用 不同的情况: 引用指向不同(实际对象) 不同行为: 不同的方法结果 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:49","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"多态发生的条件是什么? 需要继承，父子类 需要方法的重写 需要父类引用指向(不同的)子类对象 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:50","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"如何实现其多态访问? 父类引用指向(不同的)子类对象 public class Demo { public static void main(String[] args) { Phone p; p = new ApplePhone(); p.call(); p = new SamsungPhone(); p.call(); System.out.println(p.price); } } class Phone { double price; public void call() { System.out.println(\"手机都能打电话\"); } } class ApplePhone extends Phone { @Override public void call() { System.out.println(\"hi siri\"); } } class SamsungPhone extends Phone { @Override public void call() { System.out.println(\"炸了\"); } } ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:51","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"什么情况下不能使用多态? 不能继承， final 修饰的类 不能被重写的方法 final , private, static , 构造方法 写代码，如何不按照类引用指向(不同的)子类对象，也没有多态 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:52","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"成员变量中有没有多态现象? 多态指的是: 有父类引用指向子类对象，多态是指方法的重写，与成员变量无关 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:53","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"多态时(无论多不多态都是一样的), 成员变量的访问特征是什么样的? 编译时，看左边，左边是什么类型就意味着可以访问这个类型中有的成员变量 运行时, 看左边 ，编译时期就已经确定它取谁的值了，取左边引用类中成员的值 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:54","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"方法中有没有多态现象? 有， 但是有条件，必须是重写了继承父类的方法 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:55","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"多态中的方法访问特征(检索机制和访问机制)是什么样的? 编译时 看左边， 意味着引用类型中没有的方法，不能被调用 运行时 看右边， 意味着方法的结果表现出引用所指向的实际类型 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:56","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"多态的优缺点是什么? 优点: 要实现多态，必须要继承，提高了程序的可维护性性 发生多态后，同一个引用调用方法产生不同的行为, 提高了程序的简洁性和扩展性 缺点 父类的引用指向子类对象，就无法访问子类独有的行为，必须要做强制类型转换7 ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:57","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"What are the this and super keyword meanings? this to denote a refernce to the implicit parameter to call another constructor of the same class super to invoke a superclass method invoke a superclass constructor ","date":"2021-04-07","objectID":"/posts/08_polymorphic/:0:58","tags":["java"],"title":"08_polymorphic","uri":"/posts/08_polymorphic/"},{"categories":["王道"],"content":"什么是默认导包, 隐式导包? java.lang 包下的所有类，是 java 的核心类，它会自动隐式导入，不需要再写导包语句 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:1","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"If I really need both Date classes in java.util and java.sql, what can I do? use the full package name with every class name: public class PackageTest { public static void main(String[] args) { var deadline = new java.util.Date(); var today = new java.sql.Date((long)123); } } ","date":"2021-04-06","objectID":"/posts/07_extends/:0:2","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"什么是面向过程与面向对象? 面向过程 procedureal oriented programming 面向对象 oop 面向过程的编程思想 即程序是\"动词\"的集合，即程序功能是由一系列有序的动作来完成 面向对象的编程思想 即程序是由一系列的对象+对象之间交互(消息)组成 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:3","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"面向过程有什么优缺点? 优点: 代码执行效率高 缺点: 面向过程程序是一条线下来的，对程序员要求很高，需要程序员详细了解每个功能的细节，这就意味着，不利于合作开发，不利于处理复杂的大型项目 应用场景: 需要高效率的场景，比如说操作系统内核OS, 嵌入式开发，算法 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:4","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"面向对象程序有什么优缺点? 优点: 程序是按照功能模块划分的，对程序员的要求相对较小，不同的程序员负责不同的模块，各个模块之间不需要相互了解, 这样有利于程序员之间合作开发 缺点: 思路没有那么清晰，代码会很冗余 最重要的，面向对象程序会花费很多资源来创建对象和管理对象，效率相对较低 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:5","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"若类名中涉及到 class, 该怎么办? 不要直接写 class , 写成 clazz ","date":"2021-04-06","objectID":"/posts/07_extends/:0:6","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"What are the different among four access control modifiers? Accessible in the class only(private). Accessible by the world(public). Accessible in the package and all subclasses(protected). Accessible in the package -\u003e the(unfortunate) default. No modifiers are needed. ","date":"2021-04-06","objectID":"/posts/07_extends/:0:7","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"What does the keyword public means? Any method in any class can call the method. ","date":"2021-04-06","objectID":"/posts/07_extends/:0:8","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"What does the keyword private means? The only methods that can access these instance fields are the methods of the this class itself. ","date":"2021-04-06","objectID":"/posts/07_extends/:0:9","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"What the access modify should I assign to variable in class? Variables must explicitly be marked private, or they will default to having package access. If set default to having package access ","date":"2021-04-06","objectID":"/posts/07_extends/:0:10","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"If I want to restrict a method to subclasses only or, less commonly, to allow subclass methods to access a superclass field. What can I do? Declare a class feature as protected\u003e ","date":"2021-04-06","objectID":"/posts/07_extends/:0:11","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"public 访问权限修饰符是什么样的? public 公共的，随便用，大家都能用 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:12","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"默认的，缺省的 访问权限修饰符是什么样的? 只能在同包下使用, 不同包下不能使用 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:13","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"如果类中没有访问权限，里面的成员是 public 可以访问吗? 因为类中没有访问权限，所以里面的成员无法访问 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:14","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"如何嵌套定义一个类，它是什么? 有什么特点? 内部类 内部类相当于类的成员了，那它立刻就有了四种访问权限 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:15","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"使用了访问权限，就一定不可以获取类中的私有成员了吗? 不是，使用反射可以获取一个类中的私有成员 访问权限最重要的的用途是告诉使用者，什么地方出触碰，什么地方不要触碰 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:16","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"如何告诉用户这是工具类，是不需要创建对象的? 采取私有化构造方法 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:17","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"不使用权限控制符，会有什么问题? 没有任何访问权限控制，默认权限，外界可以随便使用 成员变量的访问和赋值都是用对象名, 不够细分，如果想对访问或赋值单独操作，没有实现， 比如改变访问结果或者赋值进行修正 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:18","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"使用正确使用访问权限控制符? 私有化成员变量 提供赋值和访问的方法 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:19","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"使用 get, set 方法有什么好处? 私有化成员变量, 隐藏实现细节 get，set 方法给私有成员变量，提供了一种访问方式 get, set 方法将成员变量的读、写分离了 成员变量的访问从之前的不可控，变为了可控 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:20","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"封装成员变量后，如何给成员变量赋值? 无参构造方法创建对象 有参构造方法 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:21","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"什么是继承? 如何使用继承? 继承: 当需要复用一个类的成员时，引入继承，来实现对成员的复用 语法: [访问权限修饰符] class 类名 extends 被继承的类 {} ","date":"2021-04-06","objectID":"/posts/07_extends/:0:22","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"继承的基本思想是什么? 什么是父类? 什么是子类? 继承的本质是利用代码 父类(parent class)： 也称为超类(super class), 基类(base class) 已存在的类，被继承的类，称为父类 子类 也称为派生类(derived class), 孩子类(child class) 新创建的类, 继承被继承类的类， 称这为子类 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:23","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"父类和子类到底有什么关系呢? 子类可以看成一个父类，或者说子类 is-a 父类 代码层面上: 可以用一个父类引用指向一个子类对象，这里其实说明了 子类就是一个父类对象 引用数据类型的定义上: 成员变量 + 成员方法， 继承后，子类得到了父类中的所有的成员，现在子类从定义上看，子类有了父类的所有功能，可以当父类用 从逻辑角度上看 Person Teacher 学生 学生是人，老师也是人，子类就是一个父类 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:24","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"子类可以看成父类，那么父类和子类有关系吗? 父类不一定可以看成一个子类，实际上大部分时间都不可以 子类扩展了父类，多数情况下子类都比父类功能要强大 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:25","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"什么是数据类型的向上转型和向下转型? 父类引用指向子类对象发生了数据类型转换，转换了引用 不需要写代码 从一个子类的引用转换成了父类的引用 实现了向上转型 同样手动写代码从父类向子类的转化, 就是向下转型 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:26","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"使用继承的缺点是什么? 好处: 减少了代码冗余，提高了代码的复用性 更有利于功能的扩展，提升可维护性 弊端: 父类中对成员进行修改，会体现到每一个子类中，不可选择具体哪个子类生效 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:27","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"不同包的子类中访问 protected 成员有几种方式? 子类中创建父类对象，然后用父类对象访问 子类中创建自身对象，然后访问 子类中创建 “兄弟” 类对象，然后访问 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:28","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"被 protected 修饰的成员，其访问权限是什么样的? 同类中，同包中，都可以任意访问(创建父类对象, 子类对象都可以) 不同包时候，必须在子类的的那个类中，创建当前子类的对象才可以访问 创建别的子类对象，不能访问 创建父类对象，不能访问 子类只能在自己的作用范围内访问自己继承的那个父类 protected 域 而无法到访问别的子类(同父类的亲兄弟) 所继承的 protected 域和父类对象的 protected 域 总结: 子类继承自父类的 protected 成员，必须自己来处理，爸爸帮不了，兄弟姐妹更帮不了 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:29","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"将 protected 设置复杂，有什么意思? 如果类中某个成员，非常有价值，希望这个成员总是被子类使用，而不会被滥用 使用 protected 修饰成员以后，一定能够保证该成员被子类所使用 保证子类只能用自己继承的 如 继承财产 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:30","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"如何访问到这个方法? Test t = new Test(); ","date":"2021-04-06","objectID":"/posts/07_extends/:0:31","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"这里访问clone()可以实现吗? 不行 因为 clone 是受保护的，只有在自身类中创建自身对象来访问 Demo d = new Demo(); d.clone(); ","date":"2021-04-06","objectID":"/posts/07_extends/:0:32","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"什么是单继承，多继承? 单继承 一个类有且仅有直接一个父类 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:33","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"java 中有没有多继承? 没有 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:34","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"使用多继承有特点? 支持多继承可就同时获取多个类的成员，这样会更方便 当遇到两个类中有同名的成员时会遇到麻烦 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:35","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"族谱与继承有什么关系(祖先类, 继承层次，继承链)? 祖先类: 处在继承上层的类 继承层次 由某个祖先派生出来的 所有类的集合 叫做继承层次 继承链 从某一个子类开始，到其祖先类的路径 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:36","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"父类的私有成员可以继承吗? 可以 父类的私有成员在创建对象后，无法直接调用，看起来像没有继承 但实际上是因为 没有权限 ，而 不是没有继承 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:37","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"如何证明子类继承了私有成员? ","date":"2021-04-06","objectID":"/posts/07_extends/:0:38","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"父类的构造方法可以继承吗? 构造器不属于成员，并且构造器是给自身类的对象的成员变量赋值用的，也没有必要被继承 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:39","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"父类和子类都是需要类加载的，它们的顺序是什么? 先加载父类，再加载子类 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:40","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"创建子类对象同时会创建父类对象吗?会在内存中真实创建几个对象?父类成员可能会创建一个对象吗? 显然创建多个对象是不现实的，因为这样代价太高了，如果这么设计堆上应该全是 Object 对象 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:41","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"在创建S对象(子类)时，其父类成员放在哪里? 子类对象中的父类成员会在子类对象中，开辟一片独有的空间，用来存放这些成员 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:42","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"成员都是有初始化然后再赋值的过程，请问父类的这些成员和子类独有的成员，谁先谁后? 根据常识，先父后子 代码现象，子类的成员要依赖于父类的成员赋值，所以父类成员的赋值要在子类之前 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:43","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"创建对象后，父类成员变量和子类成员变量谁先赋值? 父类先完成赋值，因为子类成员依赖于父类 必须先完成父类成员变量的赋值， 才能保证子类成员变量的赋值正确 ","date":"2021-04-06","objectID":"/posts/07_extends/:0:44","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["王道"],"content":"其内存图是什么样的? ","date":"2021-04-06","objectID":"/posts/07_extends/:0:45","tags":["java"],"title":"07_extends","uri":"/posts/07_extends/"},{"categories":["software"],"content":"Breakpoints ","date":"2021-04-04","objectID":"/posts/intelldebug/:1:0","tags":["idea"],"title":"IntellDebug","uri":"/posts/intelldebug/"},{"categories":["software"],"content":"Notation If a file with breakpoints was modified externally, for example, update through a VCS or changed in an external editor, and the line numbers have changed, the breakpoints will be moved accordingly. ","date":"2021-04-04","objectID":"/posts/intelldebug/:1:1","tags":["idea"],"title":"IntellDebug","uri":"/posts/intelldebug/"},{"categories":["software"],"content":"Types of breakpoints(Add breakpoints) Setting Line breakpoint keymap Line breakpoints Click the gutter at the executable line of code or press keymap Method breakpoints Click the gutter at the line where the method is declared, or press keymap Field watchpoints Click the gutter at the line where the field is declared, or press keymap Exception breakpoints ","date":"2021-04-04","objectID":"/posts/intelldebug/:1:2","tags":["idea"],"title":"IntellDebug","uri":"/posts/intelldebug/"},{"categories":["software"],"content":"Remove breakpoints one breakpoint click the breakpoint in the gutter. all breakpoints main menu -\u003e Run -\u003e View Breakpoints -\u003e Select the breakpoint, and click Remove delete. notation To avoid accidentally removing a breakpoint and losing its parameters, you can choose to remove breakpoints by dragging them to the editor or clicking the middle mouse button. Setting/Preferences -\u003e Build, Execution, Deployment -\u003e Debugger select Drag to the editor or click with middle mouse button ","date":"2021-04-04","objectID":"/posts/intelldebug/:1:3","tags":["idea"],"title":"IntellDebug","uri":"/posts/intelldebug/"},{"categories":["software"],"content":"Mute breakpoints If you don’t need to stop at your breakpoints for some time, you can mute them. ","date":"2021-04-04","objectID":"/posts/intelldebug/:1:4","tags":["idea"],"title":"IntellDebug","uri":"/posts/intelldebug/"},{"categories":["software"],"content":"Enable/disable breakpoints To temporarily turn an individual breakpoint off without losing its parameters, you can disable it. onepoint right-click it all breakpoint main menu -\u003e Run -\u003e View Breakpoints -\u003e Select the breakpoint, and click Remove delete. ","date":"2021-04-04","objectID":"/posts/intelldebug/:1:5","tags":["idea"],"title":"IntellDebug","uri":"/posts/intelldebug/"},{"categories":["software"],"content":"Move/copy breakpoints Move drag it to another line copy hold Ctrl and drag a breakpoint to another line ","date":"2021-04-04","objectID":"/posts/intelldebug/:1:6","tags":["idea"],"title":"IntellDebug","uri":"/posts/intelldebug/"},{"categories":["王道"],"content":"什么是匿名对象? 如何创建匿名对象? 匿名对象: 没有名字的对象，没有引用指向它的对象 创建匿名对象: new 类名(); ","date":"2021-04-04","objectID":"/posts/06_block/:0:1","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"什么时候用匿名对象? 用 匿名对象调用方法 如果方法的形式参数中需要一个对象，可以 传入一个匿名对象 如果一个方法返回值类型是一个类，要返回一个对象，可以 返回一个匿名对象 ","date":"2021-04-04","objectID":"/posts/06_block/:0:2","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"什么是代码块? 有哪些代码块? 在java中, 使用大括号 {} 括起来的代码被称为 代码块 局部代码块 构造代码块(成员位置) 静态代码块(构造代码块 + static 修饰) 同步代码块(多线程) ","date":"2021-04-04","objectID":"/posts/06_block/:0:3","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"什么是局部代码块? 有什么作用? 和局部变量位置相似， 处在 方法中局部位置 的代码块 作用: 限定局部变量的作用范围和生命周期，及早释放，提高内存利用率 评价 代码太难看了，可读性很差 并没有多大用，不要在代码中使用局部代码块 ","date":"2021-04-04","objectID":"/posts/06_block/:0:4","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"什么是构造代码块? 有什么用? 处于成员位置 {} 作用: 构造代码块会随着构造器的执行而执行，可以用来给成员变量赋值 ","date":"2021-04-04","objectID":"/posts/06_block/:0:5","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"给成员变量赋值的方式有哪些? 创建对象中: 默认初始化 默认值 显式赋值 构造代码块 构造器 ","date":"2021-04-04","objectID":"/posts/06_block/:0:6","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"若要 new 一个对象，其构造代码块的执行顺序是什么样的? 对象创建出来后，就把所有成员变量的值 默认初始化, 然后 开始其余赋值操作 如果构造器在第一行显式的 调用了另一个构造器 ，那么程序先 跳转到this构造器 ，但并不会执行 按照类中定义代码块和成员变量的位置， 从上到下执行 代码块和成员变量自身的初始化语句 继而执行该 this 构造器代码 最后执行该构造器代码 ","date":"2021-04-04","objectID":"/posts/06_block/:0:7","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"在定义代码块中可以使用 this 关键字吗？ 可以 定义代码块是在其定义对象之后执行的， 此时，已经有对象了，所以可以执行 ","date":"2021-04-04","objectID":"/posts/06_block/:0:8","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"构造代码块有什么用? 如何用? 用途: 构造代码块被创建该类每个对象都会调用 可以抽取所有构造器都需要做的事情，放入构造代码块中 注意: 永远将 构造代码块 ，放在成员变量的定义语句下面 如果代码块初始化在上，成员变量声明在下,逻辑上会很奇怪 如果对象的创建依赖于代码块和成员变量的定义位置，很容易引发错误 ","date":"2021-04-04","objectID":"/posts/06_block/:0:9","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"这里可以吗? 可以 static int staticA = 10; 是在类加载的时候执行的 在使用定义代码块的时候，已经有对象了, 早已经出现了 static int staticA = 10; 了 所以可以对执行 ","date":"2021-04-04","objectID":"/posts/06_block/:0:10","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"什么是静态代码块? 位置: 成员位置 语法: static{} 作用: 在类加载时执行，给静态成员变量赋值, 只执行一次 ","date":"2021-04-04","objectID":"/posts/06_block/:0:11","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"给静态成员变量赋值时主哪些方式? 类加载时赋值: 默认初始化， 最先进行, 默认值 显式赋值 静态代码块赋值 类名点的方式去赋值 创建对象时赋值 构造代码块 构造器 ","date":"2021-04-04","objectID":"/posts/06_block/:0:12","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"静态代码块可不可以给普通成员变量赋值? 不可以 类加载时没有对象 ","date":"2021-04-04","objectID":"/posts/06_block/:0:13","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"静态代码块可不可以有 this 关键字? 没有， 类加载时没有对象 ","date":"2021-04-04","objectID":"/posts/06_block/:0:14","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"静态代码块执行几次? 静态代码块全局(一次程序的运行期间) 只执行一次， 不会重复执行 ","date":"2021-04-04","objectID":"/posts/06_block/:0:15","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"在 new 对象过程中，静态代码块, 构造代码块，构造方法的执行顺序是什么样的? 静态代码块 构造代码块 构造方法 ","date":"2021-04-04","objectID":"/posts/06_block/:0:16","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"静态代码块与静态成员有什么 区别 和 联系 ? 静态代码块和静态成员一样，不能在里面调用非静态 静态代码块和静态成员变量的 定义顺序 会影响到静态成员变量的 最终取值 注意 永远将 静态代码块 放在 静态成员变量 的定义 下面 ","date":"2021-04-04","objectID":"/posts/06_block/:0:17","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"静态代码块与构造代码块哪一个先赋值? 静态代码块 总是优于 构造代码块 ","date":"2021-04-04","objectID":"/posts/06_block/:0:18","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"构造代码块, 静态代码块可以给静态成员变量和普通变量赋值吗? 构造代码块可以给静态成员变量赋值，静态代码块不能给普通成员代码块赋值 ","date":"2021-04-04","objectID":"/posts/06_block/:0:19","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"构造代码块有哪些使用场景? 不想让对象共享一个属性(static), 但是还需要对象的某个属性具有相同初始值 ","date":"2021-04-04","objectID":"/posts/06_block/:0:20","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"什么静态代码块可以用来测试一个类有没有被加载? 如何使用? 静态代码块在类加载的时候就会执行 ","date":"2021-04-04","objectID":"/posts/06_block/:0:21","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["王道"],"content":"A类被加载了吗? 为什么? 没有 ","date":"2021-04-04","objectID":"/posts/06_block/:0:22","tags":["java"],"title":"06_block","uri":"/posts/06_block/"},{"categories":["鸟哥的私房菜"],"content":"什么是壳程序? 能够操作 应用程序的接口 都能够称为壳程序 狭义: 命令行方面的软件 广义: 包括图形接口的软件 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:1","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 linux 把运行过后的指令保存在哪里? ~/.bash_history ~/.bash_history 记录的是前一次登录以前执行过的指令 而至于这一次登录所执行的指令都被 暂存在内存中 , 当成功的登出系统后，该指令记忆才会记录到 .vash_history 当中 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:2","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看 cd 是否是 bash 的内置命令? type cd ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:3","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看 ls 是否是 bash 的内置命令? type ls type -a ls ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:4","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 bash 中如何将光标移动到整个指令串的最前面或最后面? [ctrl] + a 移动到最前面 [ctrl] + e 移动到最后面 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:5","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何输出 PATH 这个变量? echo ${PATH} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:6","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何定义一个变量 name， 其内容为 VBird ? name=VBird echo ${name} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:7","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何定义一个变量 name， 其内容为 VBird’s name 中间不能出来空格 name=\"VBird's name\" echo ${name} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:8","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何在 PATH 中累加 :/home/feng/bin 这个目录? PATH=${PATH}:/home/feng/bin ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:9","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"什么是Shell中的子程序? 在目前这个 shell 的情况下，去启用一个新的 shell , 新的那个 shell 就是子程序 一般的状态下，父程序的自订变量是无法在子程序内使用的。 但是通过 export 将变量变成环境变量后，就能够在子程序下面应用了 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:10","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"最后一行命令可以输出吗? 不可以 一般的状态下，父程序的自订变量是无法在子程序内使用的。 但是通过 export 将变量变成环境变量后，就能够在子程序下面应用了 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:11","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何进入当前核心模块目录? uname -r uname - print system information r, –kernel-release print the kernel release cd /lib/modules/$(uname -r)/kernel ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:12","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何取消设置这个 name? unset name ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:13","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何输出环境变量与常见环境变量的说明? env ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:14","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何在 bash 中生成一个 0~32767 的数? ehco ${RANDOM} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:15","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何在 bash 中生成一个 0~9 之间的数值? declare -i number=${RANDOM}*10/32768 ; echo $number; ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:16","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在bash 中 $ 表示的是什么? 表示这个 Shell 中的 PID ehco $$ ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:17","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在bash 中 ? 表示的是什么? ? 表示是上一个执行所回传的值 echo $? 如果成功执行该指令，则会回传一个0值 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:18","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 bash 中什么是父程序? 什么是子程序? bash 就量一个独立的程序 这个程序的识别使用的是一个称为程序识别码, PID 在这个 bash 下面所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为 子程序 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:19","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"程序与变量之间有什么关系? 子程序仅会继承父程序的环境变量, 不会继承父程序的自订变量 通过 export 指令， 可以让该变量内容继续在子程序中使用 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:20","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看系统中支持了多少的语系? locale -a ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:21","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么在 tty1 ~ tty6 环境下，如何设置 LANG=zh_CN.utf8 这个设置值生效后，使用 ls -l 这个参数时，还是会出现乱码? 因为 Linux 主机的终端机接口环境下是无法显示像中文这么复杂的编码文字 需要再 加装一些中文化接口的软件 才可以看到中文 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:22","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"整体系统默认的语系定义在哪里? /etc/locale.conf ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:23","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若原本是中文语系，所有显示的数据通通是中文，但为了网页显示的关系，需要将输出转成英文(en_US.utf8)的语系来展示才行, 应该如何做? locale LANG=en_US.utf8; locale ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:24","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么环境变量的数据可以被子程序所引用呢? 当启动一个 shell, 操作系统会分配一记忆区块给 shell 使用，此内存内这变量可让子程序取用 若在父程序利用 export 功能， 可以让自订变量的内容写到上述的记忆区块当中(环境变量) 当载入另一个 shell (启动子程序，离开原本的父程序), 子 shell 可以将父 shell 的环境变量所在的记忆区块导入自己的环境变量区块当中 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:25","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何让使用者由键盘输入一内容，将该内容变成名为 atest 变量? read atest ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:26","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何提示使用者 30 秒内输入自己的名字，将该输入字符串作为名为 named 的变量内容? read -p \"Please keyin your name:\" -t 30 named ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:27","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 bash 里 进行 100+300+50 的加总结果? declare -i sum=100+300+50 echo ${sum} -i to make NAMEs have the integer attribute ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:28","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 sum, 改成只读属性，不可更动? declare -r sum -r to make NAMEs readonly ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:29","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看系统内置命令的帮助? help 命令 如: help declare ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:30","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"设置一个数组var[1] ~ var[3] , 其值分别为 small min, big min, nice min, 并输出它 var[1]=\"small min\" var[2]=\"big min\" var[3]=\"nice min\" echo \"${var[1]}, ${var[2]}, ${var[3]}\" ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:31","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看当前身份所有限制数据数值? ulimit -a ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:32","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何限制使用都仅能创建 10MBytes 以下的容量的文件? ulimit -f 10240 -f Set (or report, if no blocks operand is present), the file size limit in blocks. The -f option shall also be the default case ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:33","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若账户设置了 ulimit , 如何取消? 登出再登陆 一般用户者如果以ulimit设置了-f的大小，那么它只能继续减小文件大小，不能增加文件大小 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:34","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何自定一个小写的 path 与 PATH 内容相同? path=${PATH} echo ${path} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:35","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如果不喜欢 local/bin , 如何将其删除并输出? ${variable#/*local/bin:} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:36","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何删除最前面的一个目录? 一个 # 代表删除最短的那个 ${variable#/*:} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:37","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何删除最前面的所有目录,仅保留最后一个? 两个 ## 代表删除最长的那个 o${variable##/*:} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:38","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 path 中的 sbin 转成 SBIN, 只替换一次? ${变量/旧字串/新字串} echo ${path/sbin/SBIN} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:39","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 path 中的 sbin 转成 SBIN, 全替换? ${变量/旧字串/新字串} echo ${path//sbin/SBIN} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:40","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何删除feng前面所有内容? 也就是删除/ 与 / 的所有内容 echo ${MAIL##/*/} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:41","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何只保留文件名? echo ${MAIL%/*} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:42","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何从后往前删除删除到第一个 bin: ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:43","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何测试 username 这个变量， 若 不存在 则给予 username 内容为 root? 加上 - username=${username-root} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:44","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何测试 username 这个变量， 若 不存在 或 空字串 则给予 username 内容为 root? 加上 :- username=${username:-root} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:45","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何判断str是否存在, 不存在则 var 的测试结果直接显示 无此变量? var=${str?无此变量} ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:46","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何判断str是否存在, 存在则 var 与 str 相同? str=\"oldvar\"; var=${str?novar} echo \"var=${var}, str=${str}\" ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:47","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看当前系统所有的别名? alias ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:48","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使用 vim 就能打开 nvim? alias vim=‘nvim’ ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:49","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何 取消使用 vim 就能打开 nvim unalias vim ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:50","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"命令别名 与 变量 有什么不同? 命令别名 新创一个新的指令，可以直接下达该指令 变量 需要 echo 指令才能调用出变量的内容 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:51","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何列出目前内存内所有 history 记忆? history ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:52","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何列出最近输入过以sudo为开头的指令? !sudo ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:53","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何执行上一个指令? !! ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:54","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何执行第66行指令? !66 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:55","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若同时开好几个 bash 接口，这些 bash 的身份都是 root, 这样会有**~/.bash_history** 的写入问题吗? 有, 因为这些 bash 在同时以 root 的身份登陆，因此所有的 bash 都有自己的 1000 笔记录在内存中 等到登出时才会更新记录文件，所以，最后登出的那个 bash 才会是最后写入的数据 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:56","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 ehco 命令别名成 echo -n? 再观察 ehco 的执行顺序? alias echo='echo -n' type -a echo ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:57","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看 bash 进站时的画面与欢迎信息? cat /etc/issue ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:58","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看 /etc/issue 文件中各种参数? man issue 与 man agetty ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:59","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何想要让使用者登陆后取得一些讯息，例如想要让大家都知道的讯息，那么可以将讯息加入 /etc/motd 里面去 vim /etc/motd motd - message of the day The contents of /etc/motd are displayed by login after a successful login but just before it executes the login shell. ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:60","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"什么是 login shell 和 non-login shell, 如何区分它们? login shell 与 non-login shell 区别在于有没有登录 login shell 取得 bash 时需要完整的登录流程 non-login shell 取得 bash 接口的方法不需要登陆的举动 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:61","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"login shell 与 non-login shell 有什么不同? login shell 只会读取两个配置文件 /etc/profile 系统整体的设置 ~/.bash_profile 或 ~/.bash_login 或 ~/.profile 属于个人设置 non-login shell 仅会读一个文件 ~/.bashrc ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:62","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"有哪些例子是用 non-login shell 的? 以 X window 登陆 Linux 后，再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入账号与密码，那个 bash 环境被称为 non-login shell 了 在原本的 bash 环境再次下达 bash 这个指令，同样的也没有输入账号密码，那第二个 bash (子程序) 也是 non-login shell ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:63","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若不小心将 ~/.bashrc 删除了，如何恢复? 复制 /etc/skel/.bashrc 到主文件夹中, 并使用 source 去调用 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:64","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"~/.bash_logout 文件是用来干什么的? 默认的情况下，登出时，bash 只是帮我们清楚屏幕信息而已 可以将一些备份或者是其他重要的工作写在这个文件中 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:65","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"~/.bash_history 文件是用来干什么的? 默认的情况下，历史命令就记录在这里 而这个文件能够记录几笔数据，与 HISTFILESIZE 这个变量有关 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:66","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何列出所有的按键与按键内容? stty -a ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:67","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 window 下面，很多软件默认的储存快捷按钮是 [Ctrl] + s, 在 linux 下面使用 vim 时， 按下 [Ctrl] + s 就不动了，该如何做? [Ctrl] + s 是 stop [Ctrl] + q 是 start ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:68","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何显示目前所有的 set 设置值? echo $- ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:69","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 /etc/ 下面文件名 刚好是一个字母 的文件名? ll -d /etc/????? ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:70","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 /etc 下面文件含有数字的文件名? ll -d /etc/*[0-9]* ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:71","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 /etc/ 下面文件名开头为非小写字母的文件? ll -d /etc/[^a-z]* ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:72","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"find /home -name .bashrc \u003e list_right 2\u003e list_error 这句是什么意思? \u003e 标准输出 (stdout) 2\u003e 标准错误输出 (stderr) 将找到的到至 list_right 中 错误放到 list_error 中 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:73","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"*find /home -name bashrc 2\u003e /dev/null 这句会什么意思? 2\u003e 标准错误输出 (stderr) /dev/null 可以吃掉任何导向这个设备的信息 直接会把错误的信息丢弃 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:74","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 find /home -name .bashrc 这语的正确和错误信息全输出到 list? 2\u003e\u00261 和 \u0026\u003e 都可以 find /home -name .bashrc \u003e list 2\u003e\u00261 find /home -name .bashrc \u0026\u003e list ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:75","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何我想用 cat 直接将输入的讯息输出到 catfile 中， 且当由键盘输入 eof 时, 这次输入就结束了, 可以怎么做? cat \u003e catfile \u003c\u003c \"eof\" « 表示 结束的输入字符 的意思 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:76","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"cat \u003e catfile \u003c ~/.bashrc 是什么意思? 会将 ~/.bashrc 作为输入流， 输入到 catfile 中 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:77","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"ls /tmp/abc \u0026\u0026 touch /tmp/abc/hehe 是什么意思? 查阅 /tmp/abc 是否存在，若存在则用 touch 创建 /tmp/abc/hehe ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:78","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"ls /tmp/abc || mkdir /tmp/abc 是什么意思? 判断 /tmp/abc 是否存在， 如何不存在则创建，若存在就不作任何事情 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:79","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如果我不清楚 /tmp/abc 是否存在, 但就是要创建 /tmp/abc/hehe 文件? 为什么? ls /tmp/abc || mkdir /tmp/abc \u0026\u0026 touch /tmp/abc/hehe 若 /tmp/abc 不存在所以加传 $?!=0, 由因为 || 遇到非 0 的 $? 故 mkdir /tmp/abc, 由于 mkdir /tmp/abc 会成功进行, 所以回传 $?=0, 因为 \u0026\u0026 遇到 $?=0 故会执行 touch /tmp/abc/hehe, 最终 hehe 就被创建了 若 /tmp/abc 存在故回传 $?=0 由因为 || 遇到 0 的 $? 不会继续向后传 因为遇到 $?=0 就开始创建 /tmp/abc/hehe 了 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:80","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"以 ls 测试 /tmp/vbirding 是否存在， 若存在则显示 “exist”, 若不存在， 则显示 “not exist” ls /tmp/vbirding \u0026\u0026 echo \"exist\" || echo \"not exist\" ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:81","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"ls /tmp/vbirding || echo “not exitst” \u0026\u0026 echo “exist” 的执行会出现什么问题? 若 ls /tmp/vbirding 不存在， 因此回传一个非为0的数值 经过 || 的判断，发现前一个指令回传非为0的值，因此，程序开始执行 echo “not exist” , 而 echo “not exist” 程序肯定执行成功，因此会回传一个0值后面的指令 经过 \u0026\u0026 的判断， 是0, 所以就开始执行 echo “exist” ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:82","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"当假设判断式有三个时候，一般如何去排布? command 1 \u0026\u0026 command 2 || command 3 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:83","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"管道命令 | 有什么特点? 仅能处理经由前面一个指令传来的正确信息，也就是 standard output 对于 stdandard error 并没有直接处理的能力 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:84","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"echo ${PATH} | cut -d ‘:’ -f 5 是什么意思? cut: remove sections from each line of files -d, –delimiter=DELIM use DELIM instead of TAB for field delimiter -f, –fields=LIST select only these fields; also print any line that contains no delimiter character, unless the -s option is specified. ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:85","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何只想看到 export 中第12个字符以后的字符应该如何处理? export | cut -c 12- cut: remove sections from each line of files -c, –characters=LIST select only these characters ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:86","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 last 显示登录者的信息中, 仅留下使用者的大名? last | cut -d ' ' -f 1 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:87","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使用 last 找出没有 root 的行? last | grep -v ‘root’ -v, –invert-match Invert the sense of matching, to select non-matching lines. ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:88","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使用 last 找出没有 root 的行, 并且只取第一栏? last | grep -v ‘root’ | cut -d ' ' -f1 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:89","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何取 /etc/man_db.conf 内含 MANPATH 的那行? 并实现自动语法高亮? grep –color=auto ‘MANPATH’ /etc/man_db.conf ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:90","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何对 /etc/passwd 的文件内容进行排序? cat /etc/passwd | sort ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:91","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何对 /etc/passwd (以 : 分隔), 如何以第三栏来排序? cat /etc/passwd | sort -t ‘:’ -k 3 -t, –field-separator=SEP use SEP instead of non-blank to blank transition -k, –key=KEYDEF sort via a key; KEYDEF gives location and type ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:92","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何利用 last , 将输出的数据仅取账号，并加以排序? last | cut -d ' ' -f1 | sort -d, –delimiter=DELIM use DELIM instead of TAB for field delimiter ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:93","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何利用 last , 将输出的数据仅取账号，并加以排序, 排序后仅取出一位? last | cut -d ' ' -f1 | sort | uniq uniq report or omit repeated lines ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:94","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何利用 last , 将输出的数据仅取账号，并加以排序, 排序后仅取出一位, 并统计出现的个数? last | cut -d ' ' -f1 | sort | uniq -c uniq report or oomit repeated lines -c, –count prefix lines by the number of occurrences ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:95","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何统计 /etc/man_db.conf 里面有多少相关字、行、字符数? cat /etc/man_db.conf | wc wc print newline, word, and byte counts for each file ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:96","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"last 可以输出登录者，但是 last 最后两行并非账号内容，如何以一行指令串取得登录系统的总人次? last | grep [a-zA-Z] | grep -v ‘wtmp’ | grep -v ‘reboot’ | grep -v ‘unknown’ | wc -l ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:97","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"tee 命令是什么样的? tee - read from standard input and write to standard output and files ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:98","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 last 命令输出的内容, 存一份到 last.list 中， 并输出第一行的内容? tee - read from standard input and write to standard output and files last | tee last.list | cut -d \" \" -f1 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:99","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 last 输出的讯息中，所有的小写变成大写字符? tr - translate or delete characters last | tr ‘[a-z]’ ‘[A-Z]’ ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:100","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 输出的讯息中， 将冒号 (:) 删除? tr - translate or delete characters cat /etc/passwd | tr -d ‘:’ ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:101","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/man_db.conf 中的 [tab] 转成空白? col - filter reverse line feeds from input -x, –spaces Output multiple space instead of tabs. ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:102","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd/ 与 /etc/shadow 相关数据整合成一栏? join -t ‘:’ /etc/passwd /etc/shadow | head -n 3 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:103","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"可以将/home/feng/Desktop/Win10_1909_Chinese(Simplified)_x64.iso 文件分成多份，1份为1个G吗? split -b 1G /home/feng/Desktop/Win10_1909_Chinese(Simplified)_x64.iso win10 split split a file into pieces -b, –bytes=SIZE put SIZE bytes per output file Output pieces of FILE to PREFIXaa, PREFIXab, …; default size is 1000 lines and, default PREFIX is ‘x’ ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:104","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 win10aa ~ win10af, 合成 win10.iso? 数据流重导向即可 cat win10** » win10.iso ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:105","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使用 ls -al / 输出的信息中，每十行记录成一个文件? ls -al / | split -l 10 - lsroot With no FILE, or when FILE is -, read standard input. ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:106","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"xargs 是做什么的? x 是加减乘除的乘号， args 是 arguments 参数的意思 它是产生某个指令的参数的意思 xargs 可以读入 stdin 数据， 并且以空白字符或断行字符作为分辨， 将 stdin 的数据分隔成为 arguments ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:107","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将第个账号内容秀出来? cut -d ‘:’ -f 1 /etc/passwd | head -n 3 | xargs -n 1 id -n max-args, –max-args=max-argumets per command line. ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:108","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将第个账号内容秀出来， 每次执行 id 时，都要询问使用者是否动作? cut -d ‘:’ -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 id -p xargs never terminates its commands; when asked to decres it merely waits for more than one existing command to terminate before starting another. ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:109","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"将所有的 /etc/passwd 内的账号都以 id 查阅， 但查到 sync 就结束指令串? cut -d ‘:’ -f 1 /etc/passwd | xargs -e’sync' -n 1 id -e eof-str Set the end of file string to eof-str 连在一起的 ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:110","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 /usr/sbin 下面具有特殊权限的文件名(/700)，并使用 ls -l 列出详细属性? find /usr/sbin -perm /7000 | xargs ls -l ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:111","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"- 的什么用? 用前一个命令的 stdout 作为这次的 stdin tar -cvf - /home | tar -xvf - -C /tmp/homeback ","date":"2021-04-04","objectID":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/:0:112","tags":["linux"],"title":"Linux第十章","uri":"/posts/linux%E7%AC%AC%E5%8D%81%E7%AB%A0/"},{"categories":["王道"],"content":"什么是显式赋值? 直接赋值的方式 String brand = \"华为\"; ","date":"2021-04-03","objectID":"/posts/05_opp/:0:1","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"其输出结果会是什么样? i 与 i8 会是一样的 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:2","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"在相同的类中，整个程序的执行期间，类加载会执行多少次？ 只加载一次 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:3","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"像 String, System 这种显然也是类，但是在 jdk 当中也会加载吗？ 它们仍然会被加载 类加载都是懒加载，不是必用时，它不会加载 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:4","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"局部变量 与 成员变量 有什么区别？ 在类中定义的位置 局部变量: 局部位置(包含方法，大括号之间往往都是局部位置) 成员变量: 成员位置(类中方法外) 在内存中的位置 局部变量 栈帧中 成员变量 堆上的对象 生命周期不同 局部变量 和方法的栈帧同生共死，方法调用，局部变量生效，方法执行完毕出栈，局部变量销毁 成员变量 和对象同生共死，是不确定的，但是只要是对象的引用被销毁了，这些对象中的成员变量也没有意义了 初始化值不同 局部变量 没有默认初始化值， 必须手动初始化 成员变量 有默认初始值 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:5","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"为什么它不能打印 age ? 加了 static 的方法不属于普通成员方法，它是无法访问成员变量的 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:6","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"这里它输出的是 80 还是 100? 输出的是 80 , 它会选择离它最近的参数调用 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:7","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"为什么没法用 this? 隐含的传参 this 只针对于(普通)成员方法， 不加static的方法 对于加了 static 的方法，没有隐含的传参 this ","date":"2021-04-03","objectID":"/posts/05_opp/:0:8","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"默认提供无参构造，如果我手动写了有参构造，那么默认的无参还有吗? 当写了有参构造方法，默认的无参不再提供 为了优良的编码习惯，新建一个类，一定要把无参构造加上 原因: 框架是可以自己创建对象，它可能去访问类的无参构造方法创建对象 子类对象初始化时，依赖于父类的无参构造方法 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:9","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"在一个构造器中可以调用其他的构造器吗? 可以 但是一个构造器中用 this 调用别的构造器，这行代码一定处在第一行 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:10","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"类中可以用小驼峰法命名吗? 可以，但是会造成 命名混乱 用大驼峰法会比较好 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:11","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"char 的对象类是什么，如何获取其最大值? Character ","date":"2021-04-03","objectID":"/posts/05_opp/:0:12","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"类中如果有两个相同数据类型的成员变量，能否用构造方法对它们分别赋值? 不能 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:13","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"什么是静态区，它是用来干什么的? 在 JVM 内存的设计当中，在方法区中开辟了一块 单独的空间，称之为静态区 静态区是用来存放\"所有对象共享，整个类的对象都只有一份的数据\" 在 Java 当中把存放在这个区域的成员，称之为静态成员，包括 静态成员变量 和 静态成员方法 特点: 这个属性不是某个对象所拥有，而是全体对象所共享 这样做 可以节省内存空间，符合设计思想 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:14","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"可以通过一个对象的引用去访问了一个静态的成员? 可以，但不建议这样做，最好通过 类名. 方式的访问 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:15","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"静态成员变量和普通成员变量有什么区别?(所属， 内存中的位置， 内存中出现的时间，调用方式 ) 所属不同 成员变量: 对象, 同一个类的不同对象的成员变量是独立的 静态成员变量: 类, 同一个类的所有对象共享一个静态成员变量 在内存中的位置不同 成员变量: 堆上的对象里 静态成员变量: 方法区, jdk7 以前在方法区， jdk8之后移到了堆上去了 它们都具有默认值 在内存中出现时间不同 成员变量: 创建对象才出现，没有对象就没有成员变量 静态成员变量: 类加载结束就存在了 调用方式不同 成员变量: 对象名点, 只能通过对象访问 静态成员变量: 类名点, 但是也可以通过对象名点访问，但是不建议用对象名访问 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:16","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"静态成员 与 普通成员有什么不同? (调用方式， 有没有this传参，能不能访问普通成员，访问静态成员) 调用方式: 静态成员方法: 类名点调用 普通成员方法: 对象名点调用 有没有this传参: 静态成员方法: 没有 普通成员方法: 有 能不能访问普通成员变量 静态成员方法: 不能 普通成员方法: 能 能不能访问静态成员变量 静态成员方法: 都可以 普通成员方法: 都可以 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:17","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"什么时候用 static 修饰成员变量? 当要共享对象的属性时可以使用 只希望在整个创建对象过程中，这个 属性仅有一个(不变) ，也可以用static修饰 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:18","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"static 修饰的成员方法有什么用? 用 static 的方法，很好的调用，同类中直接方法名调用，不同类直接类名调用，无需创建对象 Arrays.toString() 当不需要对象， 只需要便捷的调方法时，使用 static , 广泛应用于工具类，方便访问调用 ","date":"2021-04-03","objectID":"/posts/05_opp/:0:19","tags":["java"],"title":"05_opp","uri":"/posts/05_opp/"},{"categories":["王道"],"content":"如何用一个方法捕获栈溢出这个错误？ catch (StackOverflowError error) ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:1","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"什么是成员变量？ 定义在类中，除了方法体之外的区域 语法: [各种修饰符] 数据类型 成员变量名 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:2","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"什么是成员方法 指的是在成员位置, 不带 static 的方法 语法: [访问权限修饰符] 返回值类型 方法名() {} ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:3","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"什么是类的全限定类名？ 就是 类名 全称， 带包路径的用点隔开 如: java.lang.String 全限定名 = 包名 + 类型 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:4","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"这里获取的地址是什么样的？ 类的全限定类名 + 地址值 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:5","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"类和数据类型是否存在关联? 数据类型: 一个数据集合 和 基于这个数据集合的 一组操作 类的定义: 类中包括： 成员变量 和 成员方法 数据集合: 类中成员 变量的集合 操作集合: 类中成员 方法的集合 总结: 一个类的定义，其实就是一种自定义的数据类型，这种数据类型，和基本数据类型不同，它是我们自定义的数据类型 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:6","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"Student s = new Student(); 谁是引用？谁是创建引用类型对象的过程？ s 是对象名或者称之为引用 new Student() 是创建引用类型对象的过程 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:7","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"什么是类加载? 在创建对象之前，把该类的字节码读取(加载)到方法区中 该类的信息就能够被 JVM 获取到，从而创建能够创建对象 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:8","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"若创建一个 Student s, 其JVM内存是什么样的? 方法区保存: 成员变量的信息 成员方法的指令合集 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:9","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"二维数组相对于一维数组有没有特殊的结构? 没有, 二维数组存的是一维数组的地址 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:10","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"如何创建一个长度为0的二维数组? int[][] arr = new int [][]{}; ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:11","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"什么时候用格式一? 什么时候用格式二? 格式一: 初始化后的二维数组可以直接使用, 因为一维数组已经存在了，但是这些一维数组的长度都是一样的，不够灵活 格式二: 初始化后的二维数组不可以直接使用，需要手动初始化其中的一维数组 ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:12","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"int[][] arr = {{1}, {1, 2}, {1, 2, 3}}; 如何打印其引用名? System.out.println(arr); ","date":"2021-04-02","objectID":"/posts/04_recursion/:0:13","tags":["java"],"title":"04_recursion","uri":"/posts/04_recursion/"},{"categories":["王道"],"content":"可变参数的实质是什么? 是用数组作为参数 public static int sum(int[] arr) { int sumValue = 0; for (int i = 0; i \u003c arr.length; i++) { sumValue += arr[i]; } return sumValue; } public static int sum(int... a) { return 1; } ","date":"2021-03-31","objectID":"/posts/03_array/:0:1","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"How to write a function that computes the maximum of a variable double number of values? function private static double max(double... values) { double largest = Double.NEGATIVE_INFINITY; for (double v : values) if (v \u003e largest) largest = v; return largest; } test public class FindMax { public static void main(String[] args) { System.out.println(max(10.2, 10.20, 19.90)); } private static double max(double... values) { double largest = Double.NEGATIVE_INFINITY; for (double v : values) if (v \u003e largest) largest = v; return largest; } } ","date":"2021-03-31","objectID":"/posts/03_array/:0:2","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"在使用可参数列表的时候，需要注意什么? 尽量不要使用带有两个可变参数的方法，构成方法重载时要慎重，因为很容易会导致两个方法都不可用 可变参数一定要在参数列表的最后一个 否则有可能运行不了 ","date":"2021-03-31","objectID":"/posts/03_array/:0:3","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"如何用增强型 for 循环遍历 arr数组? for (int i : arr) { System.out.print(i + \"\\t\"); } 此时这里的i, 相当于数组中的元素，而不是数组中的下标 ","date":"2021-03-31","objectID":"/posts/03_array/:0:4","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"What kind of situation that I can use The for each loop for (variable : collection) statement ? The collection expression must be an array or an object of a class that implement the Iterable interface. ","date":"2021-03-31","objectID":"/posts/03_array/:0:5","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"How to copy one array an array variable into another? copyof public class InputTest { public static void main(String[] args) { int[] luckyNumbers = new int[6]; luckyNumbers[0] = 2; luckyNumbers[1] = 3; luckyNumbers[2] = 5; luckyNumbers[3] = 7; luckyNumbers[4] = 11; luckyNumbers[5] = 12; System.out.println(\"LuckNumbers 遍历\"); for (int num : luckyNumbers) { System.out.print(num + \" \"); } int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length); System.out.println(); System.out.println(\"copiedLuckNumbers 遍历\"); for (int num : copiedLuckyNumbers) { System.out.print(num + \" \"); } int[] copiedLuckyNumbers2 = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length); System.out.println(); System.out.println(\"copiedLuckNumbers2 遍历\"); for (int num : copiedLuckyNumbers2) { System.out.print(num + \" \"); } System.out.println(); System.out.println(\"booleansArray 遍历\"); boolean[] booleansArray = new boolean[2]; for (boolean bool : booleansArray) { System.out.print(bool + \" \"); } } } The additional elements are filled with 0 if the array contains numbers, false if the array contains booleans values; ","date":"2021-03-31","objectID":"/posts/03_array/:0:6","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"How to use Command-Line Parameters? public class Message{ public static void main(String[] args){ if (args.length == 0 || args[0].equals(\"-h\")){ System.out.print(\"hello\"); }else if(args[0].equals(\"-g\")){ System.out.print(\"Goodbye,\"); } for (int i = 1 ; i\u003c args.length; i++){ System.out.print(\" \" + args[i]); } System.out.print(\"!\"); } } java Message -g cruel world args[0] : \"-g\" args[1] : \"cruel\" args[2] : \"world\" ","date":"2021-03-31","objectID":"/posts/03_array/:0:7","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"How can I use for each loop to vist this two-dimensional array? for (int[] row : magicSquare) { for (int value : row) { System.out.println(value); } } or System.out.println(Arrays.deepToString(magicSquare)); ","date":"2021-03-31","objectID":"/posts/03_array/:0:8","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"Does java have true multidimensional arrays? Java has no multidimensional arrays at all, only one-dimensional arrays. Multidimensional arrays are faked as “arrays of arrays” ","date":"2021-03-31","objectID":"/posts/03_array/:0:9","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"二维数组如何声明？ 数据类型[][] 二维数组名; ","date":"2021-03-31","objectID":"/posts/03_array/:0:10","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"int[] m, n[] 其是想表达什么? int[] m; int[] n[]; ","date":"2021-03-31","objectID":"/posts/03_array/:0:11","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"int[][] arr4 = new int[2][3]; 其堆空间是什么样的? ","date":"2021-03-31","objectID":"/posts/03_array/:0:12","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"什么是值传递? 什么是引用传递？ 值传递 实际上参数只传入了它的拷贝 方法结束后，随着方法栈帧的出栈，这个拷贝被销毁了，对原先的参数变量 没有影响 引用传递 方法的实际参数传入的就是地址，就是把它本身传入了 方法结束后，随着方法出栈帧，装地址的变量是被销毁了，原先的变量要 受到影响 ","date":"2021-03-31","objectID":"/posts/03_array/:0:13","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"如果方法重载，同时有固定参数的方法恰好对应，方法调用时会怎样做? 会优先调用固定参数的方法 ","date":"2021-03-31","objectID":"/posts/03_array/:0:14","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"什么是语法糖？ 在实现原理不变，实现效果不变的情况下，但是可以简化程序员的操作，在底层处理数据，底层进行封装 ","date":"2021-03-31","objectID":"/posts/03_array/:0:15","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"这个 for 循环会停下来吗? 为什么? 不会，double无法准确存储0.1这个数 ","date":"2021-03-31","objectID":"/posts/03_array/:0:16","tags":["java"],"title":"03_array","uri":"/posts/03_array/"},{"categories":["王道"],"content":"如何实现 Junit 单元测试? @Test public void methodName() { } public void 是固定格式，不可以修改，否则报错 方法的形参列表，必须为空的，否则会报错 单元测试的类中，不要写main方法 ","date":"2021-03-31","objectID":"/posts/02_method/:0:1","tags":["java"],"title":"02_method","uri":"/posts/02_method/"},{"categories":["王道"],"content":"JVM内存模型是什么样的? Java 的开发者, 在 《Java虚拟机规范》中指出: JVM (运行时数据区)内存分为 JVM栈 堆 方法区 程序计数器 本地方法栈 ","date":"2021-03-31","objectID":"/posts/02_method/:0:2","tags":["java"],"title":"02_method","uri":"/posts/02_method/"},{"categories":["王道"],"content":"JVM内存模型中JVM栈(stack)中有什么样的特点? 只有栈中处于栈顶的栈帧才会生效，称这为当前栈桢，当前方法 ","date":"2021-03-31","objectID":"/posts/02_method/:0:3","tags":["java"],"title":"02_method","uri":"/posts/02_method/"},{"categories":["王道"],"content":"JVM内存模型中JVM堆(heap)中有什么样的特点? 所有new出来的东西（称之为对象）都在堆上 ","date":"2021-03-31","objectID":"/posts/02_method/:0:4","tags":["java"],"title":"02_method","uri":"/posts/02_method/"},{"categories":["王道"],"content":"基本数据类型与引用数据类型有什么区别? 存储位置(本质) 基本数据类型不存在\"引用\"的概念，数据都是直接存储在栈上的栈帧里 引用数据类型在栈帧中存储引用，引用存储的只是该引用类型在堆上对象的内存地址 打印变量名内容: 基本数据类型，打印变量名就是该变量具体的数值 引用数据类型，打印变量名显示该引用变量堆上的内存地址 ","date":"2021-03-31","objectID":"/posts/02_method/:0:5","tags":["java"],"title":"02_method","uri":"/posts/02_method/"},{"categories":["王道"],"content":"堆上对象和栈中变量有什么区别? 从存储的类型来看: 堆上存储的是 new 出来的东西，是 引用数据类型 的对象 栈上存储的是局部变量(基本数据类型, 引用类型的引用) 从默认值来看: 堆上的变量具有默认值 整型 (byte, short, int, long) 默认值为 0 浮点类型 (float, double) 默认值为 0.0 字符类型 char 默认值为 ‘\\u0000’ 空字符 布尔类型 (boolean) 默认值是 false 引用数据类型默认值是 null 栈上变量没有默认值，声明必须显式的初始化，否则无法使用 从生命周期来看: 堆上的对象使用完毕后，就会变成 “垃圾”， 会等待垃圾回收器进行内存回收 栈上的局部变量的生命周期和栈帧保持一致 ","date":"2021-03-31","objectID":"/posts/02_method/:0:6","tags":["java"],"title":"02_method","uri":"/posts/02_method/"},{"categories":["王道"],"content":"What is Overloading? Overloading occurs if several methods have the same name but different parameters. For example, the String class has four public methods called indexOf. They have signatures. indexOf(int) indexOf(int, int) indexOf(String) indexOf(String, int) The return type is not part of the method signature. That is, you cannot have two methods with same names and parameter types but different return types. ","date":"2021-03-31","objectID":"/posts/02_method/:0:7","tags":["java"],"title":"02_method","uri":"/posts/02_method/"},{"categories":["王道"],"content":"[toc] ","date":"2021-03-30","objectID":"/posts/01_basic/:0:0","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"JDK 与 JRE 有什么样的关系? JRE (Java Runtime Environment) Java 运行时环境 JDK(Java Development Kit) Java 开发者工具包 除了JRE外，JDK还提供了Java开发者需要使用的工具,如(javac.exe, java.exe) ","date":"2021-03-30","objectID":"/posts/01_basic/:0:1","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"Java 程序的运行原理是什么样的? ","date":"2021-03-30","objectID":"/posts/01_basic/:0:2","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"给一个 project起名的规范是什么? 全部英文小写， 不要用中文 单词之间用下划线或横杠连接 如: student-manage ","date":"2021-03-30","objectID":"/posts/01_basic/:0:3","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"How to absolutely guarantee a unique package name? Use an Internet domain name written in reverse. For example, consider the domain horstmann.com When written in reverse order, it turns into the package name com.horstmann You can then append a project name, such as com.horstmann.corejava If you then place the Employee class into the package, the “fully qualified” name becomes com.horstmann.corejava.Employee ","date":"2021-03-30","objectID":"/posts/01_basic/:0:4","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"如何给一个包命名? 以反转公司域名为规范 包名应该 全部小写 多级包名以点(.)分隔 包名 com.baidu ","date":"2021-03-30","objectID":"/posts/01_basic/:0:5","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"如何给类、接口命名? 采用大驼峰命名法 public class TestDemo{} public class PersonDemo{} ","date":"2021-03-30","objectID":"/posts/01_basic/:0:6","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"如何给变量和方法命名? 采用小驼峰命名法 int num; String name; ","date":"2021-03-30","objectID":"/posts/01_basic/:0:7","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"什么是小鸵峰式命名法( lower camel case )? 多个单词组全成一个字符串 第一个单词首字母 小写 第二个单词开始，首字母都要大写 myName, myFirstJavaProgram ","date":"2021-03-30","objectID":"/posts/01_basic/:0:8","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"什么是大驼峰式命名法(upper camel case)? 多个单词组合成一个字符串 第一个单词首字母 大写 第二个单词开始，首字母都要大写 MyName, MyFirstJavaProgram ","date":"2021-03-30","objectID":"/posts/01_basic/:0:9","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"如果想要一个整数的字面值常量数据类型为 long, 应该如何做? 需要在后缀上加l或L, 推荐L ","date":"2021-03-30","objectID":"/posts/01_basic/:0:10","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"如何想要一个浮点数字面值 常量数据类型为 float, 应该如何做? 需要在其后缀上加f 或F, 推荐F ","date":"2021-03-30","objectID":"/posts/01_basic/:0:11","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"若想表示一个 十六进制的数(Hexadecimal number), 应该如何做? Hexadecimal number have a prefix 0x or 0X for example 0xCAFE public class TestInt { public static void main(String[] args) { System.out.println(0xF); } } ","date":"2021-03-30","objectID":"/posts/01_basic/:0:12","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"若想表示一个8进制的数(Octual number)，应该如何做? Octual numbers have a prefix 0 naturally, this can be confusing, so we recommend against the use of octal constants for example 010 public class TestInt { public static void main(String[] args) { System.out.println(010); } } ","date":"2021-03-30","objectID":"/posts/01_basic/:0:13","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"若想表示一个二进制(binary)，应该如何做? write number in binary, with a prefix 0b or 0B for example, 0b1001 public class TestInt { public static void main(String[] args) { System.out.println(0b1001); } } Also starting with Java 7, can add underscores to number literals, such as 0b1111_0100_0010_0100_0000 public class TestInt { public static void main(String[] args) { System.out.println(0b1_1000); } } ","date":"2021-03-30","objectID":"/posts/01_basic/:0:14","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"byte, short, int, long, float, double, char, boolean 分别占用几个字节的空间? byte 1个字节 short 2个字节 int 4个字节 long 8个字节 float 4个字节 double 8个字节 char 2个字节 boolean JVM规范, 在内存中 若: boolean 当作 int 处理， 占4个字节 boolean 数组当成 byte 数组处理， 一个 boolean 元素占1个字节 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:15","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"float 只有 4字节, 会比 8 字节的 long 小吗? 不会， float 与 double 类型中都有 E, 会使得它比 int 和 long 要大 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:16","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"float 的有效位数是多少? 7 ~ 8 位 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:17","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"double 的有效位数是多少? 16 ~ 17 位 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:18","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"这几个数据类型相互转换哪些会出现精度丢失问题? 在int 和 long 转成 float 和 double 的时候， 只有 int 转向 double 不会出现精度丢失，其它都会出现精度丢失 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:19","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"int, long, float 哪个大？ float 大， float 中有指数 这些问题会出现什么结果? a 98 helloa1 98hello 5+555 10=5+5 10.0 555.0 总结: 遇到 ‘a’, 直接输出 ‘a’ + 1, 这种先考虑数值相加 ‘a’ + 1 + “hello”, 先考虑数值相加，然后遇到 \"\" 时，合并字符串 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:20","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"What’s the difference between next() and nextLine() methods from Scanner class? next() can read the input only till the space. nextLine() reads input includiung space between teh words (that is, it reads till the end of line \\n Once the input is read, nextLine() positions the cursor in the next line. ","date":"2021-03-30","objectID":"/posts/01_basic/:0:21","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"\\u0000 与 (空格) 有什么区别? \\u0000 对应的是什么都没有 对应的是一个空格 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:22","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"What’s the different between Strongly typed languages and weakly typed languages? Weakly-typed languages make conversions between unrelated types implicitly Strongly-typed languages don’t allow implicit conversions between types. ","date":"2021-03-30","objectID":"/posts/01_basic/:0:23","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"What’s the mean of System.out.println(0x1.0p-3)? 0.125 = $2^{-3}$ can be writeen as 0x1.0p-3 In hexadecimal notation, use a p, not an e, to denote the exponent The base of the exponent is 2, not 10. ","date":"2021-03-30","objectID":"/posts/01_basic/:0:24","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"Could I use $ to declare Java variable? Even though $ is a valid Java letter, you should not use it in your own code. It is intended for names that are generated by the Java compiler and other tools. ","date":"2021-03-30","objectID":"/posts/01_basic/:0:25","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"If I curious as to what Unicode characters are “letters” as for as Java is concerned, what can I do? Use isJavaIdentifierStart and isJavaIndentifierPart System.out.println(Character.isJavaIdentifierPart('c')); ","date":"2021-03-30","objectID":"/posts/01_basic/:0:26","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"What’s mean int i, j;? Declare multiple variables on a single line i, j both are integers Don’t recommend this style, If you declare each variable separately, your programs are easier to read. ","date":"2021-03-30","objectID":"/posts/01_basic/:0:27","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"In Java , how can I declare declare a constant? Use the keyword final to denote a constant. It is customary to name constants in all uppercase For example final double CM_PER_INCH = 2.54; const is a reserved Java keyword, but it is not currently used for anything. You must use final for a constant. ","date":"2021-03-30","objectID":"/posts/01_basic/:0:28","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"How can I use logical “and” operator or logical “or” operator to avoid errors? System.out.println(x != 0 \u0026\u0026 1 / x \u003e x + y); The second part is never evaluated if x equals zero. Thus, 1 / x is not computed if x is zero, and no divide-by-zero error can occur. ","date":"2021-03-30","objectID":"/posts/01_basic/:0:29","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"其输出的结果是什么? 为什么? int 类型在 java 中 4字节 向左， 向左移动是对 32求余后的结果 所以向左移动32位相当于没有移动 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:30","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"\u003e\u003e\u003e 符号是干什么的? 无符号右移 a \u003e\u003e\u003e operator fills the top bits with zero, unlike \u003e\u003e which extends the sign bit into the top bits. There is no \u003c\u003c\u003c operator ","date":"2021-03-30","objectID":"/posts/01_basic/:0:31","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"float 20.5 是如何存储的? 序号 过程 解释 1 首先符号位为0 正数的符号位为0 负数的符号位为1 2 其转化为二进制为 10100.1 正数除以2取余数 负数乘以2取整 3 将二进制数转化成科学计数法 1.01001 x 2^4 4为指数部分 1.01001 为尾数部分 4 将指数部分加上127, 转换成二进制, 作exponent 0111 1111 + 0000 0100 结果为 1000 0011 5 尾数部分，隐藏高位1, 低位补0 101001 结果为0100 100000000…(23)位 0 1000 0011 0100 1000 0000 0000 000 ","date":"2021-03-30","objectID":"/posts/01_basic/:0:32","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["王道"],"content":"Are there any class have a main method? yeah public class StaticTest{ public static void main(String[] args){ var staff = new Employee[3]; staff[0] = new Employee(\"Tom\", 40000); staff[1] = new Employee(\"Tom\", 60000); staff[2] = new Employee(\"Tom\", 65000); for (Employee e : staff){ e.setId(); System.out.println(\"name=\" + e.getName() + \", id=\" + e.getId() + e.getSalary()); } int n = Employee.getNextId(); System.out.println(\"Next available id=\" + n); } } class Employee{ private static int nextId = 1; private String name; private double salary; private int id; public Employee (String n, double s){ name = n; salary = s; id = 0; } public String getName(){ return name; } public double getSalary(){ return salary; } public int getId(){ return id; } public void setId(){ id = nextId; nextId++; } public static int getNextId(){ return nextId; } public static void main(String[] args){ var e = new Employee(\"Harry\", 50000); System.out.println(e.getName() + \" \" + e.getSalary()); } } ","date":"2021-03-30","objectID":"/posts/01_basic/:0:33","tags":["java"],"title":"01_basic","uri":"/posts/01_basic/"},{"categories":["leetcode"],"content":"27. Remove Element 双指针法 考虑 nums != val 时, 加入到当前数组中 class Solution { public int removeElement(int[] nums, int val) { int i = 0; for (int x = 0; x \u003c nums.length; x++){ if (nums[x] != val){ nums[i] = nums[x]; i +=1; } } return i; } } 优化 nums[i] = nums[x]; i += 1; 可以直接写成 nums[i++] = nums[x]; 疑问 空数组 与 只声明未赋值的数组 其长度是多少? 考虑 nums = val 时, 通过将最后的元素覆盖掉 nums 的值 class Solution { public int removeElement(int[] nums, int val) { int i = 0; int n = nums.length; while(i \u003c n){ if (nums[i] == val){ nums[i] = nums[n - 1]; n--; } else { i++; } } return n; } } 优化 else 后之有一条语句， 可以去掉 考虑 nums ","date":"2021-03-27","objectID":"/posts/removeelement/:0:1","tags":["array"],"title":"RemoveElement","uri":"/posts/removeelement/"},{"categories":["algorithm"],"content":"Two Sum 001 ","date":"2021-03-26","objectID":"/posts/twosum/:0:0","tags":["java"],"title":"TwoSum","uri":"/posts/twosum/"},{"categories":["algorithm"],"content":"我的代码(双指针法) class Solution { public int[] twoSum(int[] nums, int target) { if (nums.length \u003c 2){ return new int[0]; } int[] data = new int[2]; for (int x = 0 ; x \u003c nums.length; x ++){ for (int y = x + 1; y \u003c nums.length; y ++){ if (nums[x] + nums[y] == target){ data[0] = x; data[1] = y; } } } return data; } } ","date":"2021-03-26","objectID":"/posts/twosum/:0:1","tags":["java"],"title":"TwoSum","uri":"/posts/twosum/"},{"categories":["algorithm"],"content":"最优解(hash表) 待学hash表 ","date":"2021-03-26","objectID":"/posts/twosum/:0:2","tags":["java"],"title":"TwoSum","uri":"/posts/twosum/"},{"categories":["java"],"content":"什么是类? 什么是对象? 类: 表示一个客观世界中某类群体的一些基本特征抽象 如: 汽车， 轮船，书 对象: 一个个具体的事物 如: 张三同学， 李四账户， 王五的汽车 总结: 类 实际上是对象操作的 模板 ，但是类不能够直接使用，必须通过 实例对象 来使用 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:1","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何定义一个类为 Book, 并提供一个方法, 输出图书的名称和价格? class Book { String title; double price; /* * 输出对象完整信息 */ public void getInfo() { System.out.println(\"图书名称:\" + title + \", 价格:\" + price); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:2","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何定义一个Book类为bk, bk的title为 Java 开发， bk的price为89.9? class Book { String title; double price; /* * 输出对象完整信息 */ public void getInfo() { System.out.println(\"图书名称:\" + title + \", 价格:\" + price); } } public class ClassBook { public static void main(String args[]){ Book bk = new Book(); bk.title = \"Java 开发\"; bk.price = 89.9; } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:3","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何调用类中的 getInfo() 方法? bk.getInfo() ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:4","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"在 java 中什么是堆内存 (heap) 和 栈内存 (stack) ? 栈内存 : 保存的是一块对内存的空间地址 堆内存 : 保存对象的真正数据, 都是每一个对象的属性内容 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:5","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"以本程序为例子，分析其堆内存与栈内存? 声明并实例化对象 设置 title 属性内容 设置 price 属性内容 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:6","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"在类中定义的属性，应该如何封装? 用 private 封装 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:7","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"在类中已用 private 封装的属性，应该如何在外部使用? setter 设置内容 getter 取得属性内容 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:8","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"定义了一个Book类， 如何给这些属性设置 setter 、 getter 操作? ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:9","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"若程序没有使用 getter 方法， 是否可以不定义? 不可以 必须定义, 不管是否使用 本程序中由于 Book 类提供有 getInfo() 方法， 所以就直接利用此方法进行内容的输出。 但是对于 Book 类的使用还可能出现单独取得属性的情况，所以 getter, setter 必须同时提供 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:10","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"什么是构造方法? 构造方法是一种特殊的方法， 它只在 新对象实例化 的时候调用 其 定义的原则 : 方法名称 与 类名称相同， 没有返回值类型声明， 同时构造方法也可以进行重载 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:11","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"在对象的实例化的格式中存在构造方法的使用吗? 存在 类名称 规定了对象的类型，即对象可以使用哪些属性与方法，都是由类定义的 对象名称 如果想使用对象，需要有一个名字，这是一个唯一的标记 new 开辟新的堆内存空间 类名称() 调用了一个和类名称一样的方法 在 java 类中， 为了保证程序可以正常的执行，即使用户没有定义任何构造方法，也会在程序编译之后自动地为类增加一个 没有参数、没有方法名称、类名称相同、没有返回值的构造方法 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:12","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"构造方法与普通方法有什么区别呢? 构造方法 在实例化新对象 (new) 的时候只调用一次 普通方法 在实例化新对象产生之后，通过 对象.方法 调用多次 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:13","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"既然构造方法没有返回值，为什么不使用 void 来声明构造方法呢? 如果在构造方法上使用了 void , 其定义的结构与普通方法就完全一样，而 程序的编译是依靠定义结构来解析的 ，所以不能有返回值声明。 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:14","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何用构造方法来为属性赋值? ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:15","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"当一个类中的结构包含属性、构造方法、普通方法、在编写时应该采取什么样的顺序? 属性 (必须封装，同时提供 setter, getter) 构造方法 普通方法 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:16","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"在一个类中对构造方法重载时，其编写顺序，最好采取什么样的规范? 重载的方法按照参数的个数由 多到少 ，或由 少到多 排列 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:17","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何对 Book 实现重载? [“无参”， “有一个参数 title”, “有两个参数 title, price” , ] 注意 setter 和 getter 一定要设置 这里省略了 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:18","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"根据先编写属性，然后构造方法，最后普通方法的规则，将setter、getter放到前面对吗? 不对， setter, getter 所定义的就是普通方法，它应该放到构造方法后面 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:19","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"什么是匿名对象? 栈内存没有指向堆内存 这种开辟了堆内存空间的实例化对象，只能使用一次, 使用一次之后就将被GC回收 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:20","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何定义一个匿名对象? new Book(“Java开发”, 69.8).getInfo(); public class ClassBook { public static void main(String args[]){ new Book(\"Java 开发\", 69.8).getInfo(); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:21","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"简单 Java 类有什么基本开发要求? 类名称必须存在意义， 例如: Book、 Emp; 类中所有的属性必须 private 封装， 封装后的属性必须提供 setter、 getter; 类中可以提供任意多个构造语句，但是必须保留一个 无参构造方法 类中不允许出现任何输出语句，所有信息输出必须交给被调出处输出 类中需要提供有一个取得对象完整信息的方法， 暂定为 getInfo(), 而且返回 String 型数据 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:22","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"声明并开辟数组有哪两种方法? 数据类型 数组名称 [] = new 数据类型 [长度]; 数据类型 [] 数组名称 = new 数据类型 [长度]; ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:23","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何分步完成声明数组到开辟数组? 声明数组: 数据类型 数组名称 [] = null; 开辟数组: 数组名称 = new 数据类型 [长度] 如: int data[] = num; data = new int [3]; ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:24","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"int data[] = new int[3]; 这里的3指的是什么? 是指数组的长度为3 即 data[0], data[1], data[2] ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:25","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何获取数组的长度? 如 int data[] = new int[3]; 数组名称.length data.length ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:26","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何开辟一个3个长度的数组data, data[0] 为 10, data[1] 为20, data[2] 为 30, 并遍历出来? public class ListArray { public static void main(String args[]){ int data[] = new int[3]; data[0] = 10; data[1] = 20; data[2] = 30; for (int x = 0; x \u003c data.length; x++){ System.out.print(data[x] + \"、\"); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:27","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何分步实现一个数组 data[] , data[] 的长度为3? int data[] = null; data = new int [3]; ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:28","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"数组的引用传递是什么原理? int data[] = new int[3]; data[0] = 10; data[1] = 20; data[2] = 30; int temp[] = data; ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:29","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"什么是数组的静态初始化的操作? 有哪些方法?(以data为例) 简化格式: 数据类型 数组名称 [] = {值, 值, …}; int data[] = {1, 2, 3, 4, 5}; 完整格式: 数据类型 数组名称 [] = new 数据类型 [] {值, 值, …}; int data[] = new int[] {1, 2, 3, 4, 5}; ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:30","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"初始化二维数组有什么方法?, (以data[3][3]为例) 动态初始化: 数据类型 数组名称[][] = new 数据类型[行的个数][列的个数]; int data [][] = new int[3][3]; 静态初始化: 数据类型 数组名称[][] = new 数据类型[][] {{值, 值, 值}, {值, 值, 值}}; int data [][] = new int [][]{ {1, 2, 3},{4, 5, 6}, {7, 8, 9} }; ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:31","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何遍历这个二维数组? 注意y 是小于data[x].length ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:32","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"在实际开发中推荐使用多维数组吗? 为什么? 不推荐 维数越多所描述的概念就越复杂 在实际开发中很少的情况会涉及多维开发 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:33","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"引用传递是什么原理? ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:34","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何实现由小到大排序? ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:35","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"这是冒泡排序, 为什么out 要从 size - 1开始, out \u003e 0? 因为 data[in] \u003e data[in + 1] 表达式 所以 out 要从 size - 1 开始 一直会比较到 data[0] \u003e data[1] out 的最小值是1 所以 out 大于等于 0 都可以 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:36","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何实现冒泡排序? for (int out = size - 1; out \u003e 0; out --){ for (int in = 0; in \u003c out; in ++){ if(data[in] \u003e data[in + 1]){ int temp = data[in]; data[in] = data[in + 1]; data[in + 1] = temp: } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:37","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"转置一个数组有什么样的思路? 定义一个 新的数组 ，将原始数组按照 倒序 的方式插入到新的数组中，最后 改变原始数组引用 ，将其 指向新的数组空间 特点: 代码里面会产生垃圾，而在进行程序开发的过程中应该尽可能少地产生垃圾空间，这样的思路 并不是最合理的 尽可能的在 一个数组 里完成转置操作 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:38","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何采取定义一个新的数组的方法，转置数组? public class ArrayReverse { public static void main(String args[]){ int data [] = new int [] {1, 2, 3, 4, 5, 6, 7, 8}; int temp [] = new int [data.length]; int foot = data.length - 1; for (int x = 0; x \u003c temp.length; x++){ temp[x] = data[foot]; foot--; } data = temp; print(data); } public static void print(int temp[]){ for (int x = 0; x \u003c temp.length; x++){ System.out.print(temp[x] + \"、\"); } System.out.println(); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:39","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"利用算法，只在一个数组上，完成转置操作的思路是什么样的? 偶数: 原始数组: 1, 2, 3, 4, 5, 6 第一次转置: 6 , 2, 3, 4, 5, 1 第二次转置: 6, 5, 3, 4, 2, 1 第三次转置: 6, 5, 4, 3 , 2, 1 奇数 原始数组: 1, 2, 3, 4, 5, 6, 7 第一次转置: 7, 2, 3, 4, 5, 6, 1 第二次转置: 7, 6, 3, 4, 5, 2, 1 第三次转置: 7, 6, 5, 4, 3, 2, 1 不管数组的长度是奇数的个数还是偶数的个数，其转置的次数的计算方式是完全一样的 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:40","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"利用算法，只在一个数组上，完成转置操作, 其代码是如何实现的? public class ArrayReverse { public static void main(String args[]){ int data [] = new int [] {1, 2, 3, 4, 5, 6, 7, 8}; reverse(data); print(data); } public static void reverse(int arr[]){ int len = arr.length / 2; int head = 0; int tail = arr.length - 1; for (int x = 0; x \u003c len; x ++){ int temp = arr[head]; arr[head] = arr[tail]; arr[tail] = temp; head ++; tail --; } } public static void print(int temp[]){ for (int x = 0; x \u003c temp.length; x++){ System.out.print(temp[x] + \"、\"); } System.out.println(); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:41","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"二维数组(行与列相同)如何实现转置? 只有当行数与列数相同的时候才可以发生数据的交换操作 public class transpose { public static void main(String args[]) { int data [][] = new int [][] { {1, 2, 3}, {4, 5, 6}, {7, 8, 9}}; reverse(data); print(data); } public static void reverse(int[][] data){ for (int x = 0; x \u003c data.length; x++){ for (int y = x; y \u003c data[x].length; y++ ){ if (x != y) { int temp = data[x][y]; data[x][y] = data[y][x]; data[y][x] = temp; } } } } public static void print(int[][] data){ for (int x = 0; x \u003c data.length; x++){ for (int y = 0; y \u003c data[x].length; y++){ System.out.print(data[x][y] + \"、\"); } System.out.println(); } System.out.println(); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:42","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何用代码实现这一步骤? public static void arraycopy (Object src, int srcPos, Object dest, int destPos, int length) src - the source array. srcPos - starting position in the source array. dest - the destionation array. destPos - starting position in the destination data. length - the number of array elements to be copied. public class ArrayCopy { public static void main(String args[]) { int dataA[] = new int[] {1, 2, 3, 4, 5, 6, 7, 8}; int dataB[] = new int[] {11, 22, 33, 44, 55, 66, 77, 88}; // 从第5个位置复制，复制到2的位置，复制3个 System.arraycopy(dataA, 4, dataB, 2, 3); print(dataB); } public static void print(int temp[]) { for (int x = 0; x \u003c temp.length; x++){ System.out.print(temp[x] + \"、\"); } System.out.print(\"\"); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:43","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"使基本数据类型的数组按照由小到大的顺序排序的方法是什么? java.util.Arrays.sort(数组名称) ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:44","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"java.util.Arrays.sort(数组名称) 为什么缺陷? 只能对基本数据类型，如 int[], double[], char[] 进行排序, 不能对引用数据排序 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:45","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何使用 java.util.Arrays.sort() 对 data 排序, data 为{3, 6, 1, 2, 8, 0}? public class SortArray { public static void main(String args[]){ int data[] = new int[] {3, 6, 1, 2, 8, 0}; java.util.Arrays.sort(data); print(data); } public static void print(int temp[]){ for (int x = 0; x \u003c temp.length; x++){ System.out.print(temp[x] + \"、\"); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:46","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"什么是对象数组? 数组是 引用类型 类是 引用类型 对象数组表示一个引用类型里面 嵌套其他的引用类型 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:47","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"对象数组有哪些初始化的方式? 动态初始化 类名称 对象数组名称 = new 类名称 [长度]; Book books [] = new Book[3]; books[0] = new Book{\"Java\", 79.8}; books[1] = new Book{\"JSP\", 69.8}; books[2] = new Book{\"Android\", 89.8}; 静态初始化 类名称 对象数组名称 = new 类名称 [] {实例化对象, 实例化对象, …}; Book books[] = new Book[] { new Book(\"Java\", 79.8), new Book(\"JSP\", 69.8), new Book(\"Android\", 89.8); } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:48","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"对象数组的内存关系是什么样的? ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:49","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何采用动态初始化的方法初始化? ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:50","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何采用静态初始化的方法初始化? ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:51","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"String 类有哪两种实例化的方式? 为 String 类对象直接赋值 利用构造方法实例化 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:52","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何采取直接赋值的方式对 String 类赋值 (如: 使str 为 “fengqigang.cn”)？ public class StringAttribute { public static void main(String args[]){ String str = \"fengqigang.cn\"; System.out.println(str); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:53","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何采取构造方法实例化的方式对 String 类赋值 (如: 使str 为 “fengqigang.cn”)？ public class StringAttribute { public static void main(String args[]){ String str = new String(\"fengqigang.cn\"); System.out.println(str); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:54","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"在 java 中 “==” 可以应用到哪些数据类型中? 可以应用在所有数据类型中 包括基本数据类型与引用数据类型 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:55","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何判断 直接赋值的String 与 采用构造方法的创造相同内容的String, 它们是否相等(以hello为例)? 不相等 public class StringCompare { public static void main(String args[]){ String stra = \"hello\"; String strb = new String(\"hello\"); System.out.println(stra == strb); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:56","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"它两相等吗? 为什么? 相等 都是指向相同的堆内存 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:57","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"== 所比较的是什么? 首先， 在整个Java中只要引用数据类型一定会存在内存地址 “==” 可以用于所有的引用数据类型比较 比较的并不会是内容，永远都只是地址的数值内容, 比较的是内存地址 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:58","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何比较 String 类里面字符串的内容? public boolean equals(String str) ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:59","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何实现他们三者在字符串内容上的比较? equls ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:60","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"在 String 类中 “==” 和 “equals()” 比较有什么区别? “==” 是 Java 提供的关系运算符 主要的功能进行数值相等判断，如果用在 String 对象上表示的是 内存地址数值 的方法 “equals()” 是由 String 提供的一个方法，此方法专门负责进行 字符串内容 的比较 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:61","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"其结果是什么样的? 为什么? 这是实现了堆内存空间的重用 即采用直接赋值的方式，在相同内容的情况下不会开辟新的内存空间 , 而会直接指向已有的内存空间 在 JVM 的底层实际上会存在一个 对象池 (不一定只保存 String 对象) , 当代码中使用了直接赋值的方式定义一个 String 类对象时，会将此字符串对象所使用的匿名对象入池保存。 如果后续还有其他 String 类对象也采用了直接赋值的方式，并设置了同样的内容时，将不会开辟新的堆内存空间，而是使用已有的对象进行引用的分配, 从而继续使用。 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:62","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"String 采取直接赋值的方式实例化, 其语法是什么样的(以 “hello” 为例)? String 变量 = 字符串常量(匿名对象) String str = \"hello\"; ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:63","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"String 采取构造方法的方式实例化, 其语法是什么样的(以 “hello” 为例)? String str = new String(\"hello\"); ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:64","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"String 采取构造方法的方式实例化, 其特点是什么? String str = new String(\"hello\"); 因为每一个字符串都是一个 String 类匿名对象 会首先在堆内存中开辟一块空间保存字符串\"hello\", 然后使用关键字 new, 开辟另一块内存空间 在真正使用的是关键字 new 开辟的堆内存， 而之前定义的字符串常量的堆内存空间将不会在任何的栈内存指向，将成为垃圾，等待被 GC 回收. 总结: 使用构造方法开辟的字符串对象，实际上会 开辟两块空间 ，其中有 一块空间将成为垃圾 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:65","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"String 类有哪两种实例化的方式? 直接赋值实例化 String 类对象 构造方法实例化 String 类对象 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:66","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"每一个字符串常量， 其本质上是什么? 为什么？ String 匿名对象 public class StringAnonymity { public static void main(String args[]) { String str = \"hello\"; System.out.println(\"hello\".equals(str)); } } “hello” 直接调用了 equals() 方法 由于 equals() 方法是 String 类定义的，而类中的方法只有实例化对象才可以调用 所以字符串常量就是 String 类的匿名对象 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:67","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"其结果是什么? 为什么? 因为这种采取构造方法定义的内存空间，不会自动入池 所以在使用赋值的方式声明 String 类对象后将开辟新的堆内存空间，因为两个堆内存的地址不同，所以最终的地址判断结果为 false ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:68","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"若采取构造方法定义的新的内存空间如何手动入池? new String(“hello”).intern() ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:69","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"采取 直接赋值 (String str = “字符串”;) 和 构造方法 (String str = new String(“字符串”)) 实例化方式有什么区别? 直接赋值 只会开辟一块堆内存空间，并且会自动保存在对象池以供下次重复使用 构造方法 会开辟两块堆内存空间，其中一块空间将成为垃圾，并且不会自动入池，但是用户可以使用 intern() 方法手动入池 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:70","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"其本质上是什么样的? 首先，声明了一个 **String*8 类对象, 然后修改了两次 String 类对象的内容 (实际上是发生了两次引用改变), 所以最终 String 类对象的内容就是 “Hello, World!!!\" 只是 String 类的对象引用发生了改变，而字符串的内容并没有发生改变 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:71","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"这种操作可以做吗? 为什么? 修改 String 对象的值，相当于修改其引用关系，(所有数据类型遇见String连接操作时都会自动向String类型转换), 并且会产生大量的垃圾空间 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:72","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"因为修改 String 对象的值，相当于修改其引用关系，若在一个项目中要大量的修改一个字符串，该如何解决? 使用 StringBuffer 或 StringBuilder ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:73","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何截取指定索引的字符(如截取第一个字符)? 使用 charAt() 方法 charAt(0) 截取第一个字符 public class CharAt { public static void main(String args[]) { String str = \"hello\"; char c = str.charAt(0); System.out.println(c); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:74","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何实现字符数组与字符串的转换? toCharArray() public class ToCharArray { public static void main(String args[]) { String str = \"hello\"; char[] data = str.toCharArray(); for (int x = 0; x \u003c data.length; x++){ System.out.print(data[x] + \"、\"); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:75","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将字符串转为大写(hello)? 大写字母比小写字母小 32 位 str.toCharArray() public class smallTobig{ public static void main(String args[]){ String str = \"hello\"; char[] data = str.toCharArray(); for (int x = 0; x \u003c data.length; x++){ data[x] -=32; } System.out.println(new String(data)); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:76","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将字符串中的部份字符转成大写(hello, (EL))? str.toCharArray() public class SmallToBig { public static void main(String[] args) { String str = \"hello\"; char[] data = str.toCharArray(); for (int i = 0; i \u003c data.length; i++) { data[i] -= 32; } System.out.println(new String(data, 1, 2)); } } String(data, 位序， 位序) ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:77","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"给定一个字符串，如何判断其是否由数字组成？(123456) str.toCharArray() public class SmallToBig { public static void main(String[] args) { String str = \"12312423\"; if (isNumber(str)){ System.out.println(\"该字符串全是由数字组成\"); }else{ System.out.println(\"该字符串不全是由数字组成\"); } } public static boolean isNumber(String str){ char[] data = str.toCharArray(); for (int i = 0; i \u003c data.length; i++) { if (data[i] \u003e '9' || data[i] \u003c '0') { return false; } } return true; } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:78","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"针对一种真或假判断，Java中的习惯性的命名是什么? isXxxx(); 如: isNumber() ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:79","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"字符串如何全部转成字节数组(helloworld 转成 HELLOWORLD)? str.getBytes() public class StringToByteArray { public static void main(String[] args) { String str = \"helloworld\"; byte[] data = str.getBytes(); for (int i = 0; i \u003c data.length; i++) { data[i] -= 32; } System.out.println(new String(data)); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:80","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何判断两个字符串是否相等(考虑大小写)？ stra.equals(strb) public class IsNumber { public static void main(String[] args) { String stra = \"Hello\"; String strb = \"hello\"; System.out.println(stra.equals(strb)); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:81","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何判断两个字符串是否相等(不考虑大小写)？ stra.equalsIgnoreCase(strb) public class IsNumber { public static void main(String[] args) { String stra = \"Hello\"; String strb = \"hello\"; System.out.println(stra.equalsIgnoreCase(strb)); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:82","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"stra = “Hello” 与 strb = “HEllo” 如何比较大小? stra.compareTo(strb) public class CompareTo { public static void main(String[] args) { String stra = \"hello\"; String strb = \"Hello\"; System.out.println(stra.compareTo(strb)); if (stra.compareTo(strb) \u003e 0) { System.out.println(\"大于\"); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:83","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何查找在 helloworld 满足 world, 第一个字母的索引? indexOf public class IndexOf { public static void main(String[] args) { String str = \"helloworld\"; System.out.println(str.indexOf(\"world\")); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:84","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何查找在 helloworld 中， 从第2个元素开始找e的素引位置? indexOf(“e”, 1) public class IndexOf { public static void main(String[] args) { String str = \"helloworld\"; System.out.println(str.indexOf(\"e\", 1)); } } 其返回的是位序 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:85","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何判断 “helloworld” 中 是否存在 “world” ? contains() 返回 true 或 false indexOf() 返回元素的位置 indexOf() public class Contains { public static void main(String[] args) { String str = \"helloworld\"; if (str.indexOf(\"world\") != -1) { System.out.println(\"可以查询到数据\"); } } } contains() public class Contains { public static void main(String[] args) { String str = \"helloworld\"; if (str.contains(\"world\") == true) { System.out.println(\"可以查询到数据\"); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:86","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何判断 ##@@hello 是否以 ## 开头? str.startsWith(\"##\") public class StartWith { public static void main(String[] args) { String str = \"##@@hello\"; System.out.println(str.startsWith(\"##\")); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:87","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何判断 ##@@hello 是否以 llo 结尾? str.endsWith(“llo”) public class StartWith { public static void main(String[] args) { String str = \"##@@hello\"; System.out.println(str.endsWith(\"llo\")); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:88","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将字符串str = “helloworld” 中的 l 全部替换成 _? str.replaceAll(“l”, “_\") public class Replace { public static void main(String[] args) { String str = \"helloworld\"; String stra = str.replaceAll(\"l\", \"_\"); System.out.println(stra); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:89","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将字符串str = “helloworld” 中的 l 首个替换成 _? str.replaceFirst(“l”, “_\") public class Replace { public static void main(String[] args) { String str = \"helloworld\"; String stra = str.replaceFirst(\"l\", \"_\"); System.out.println(stra); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:90","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何截取字符串str = “helloworld” 从第六个位置开始，截取到最后一个? str.substring(5) public class Replace { public static void main(String[] args) { String str = \"helloworld\"; String stra = str.substring(5); System.out.println(stra); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:91","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何截取字符串str = “helloworld” 从第1个位置开始，截取到第6个之前位置? str.substring(0,5) public class Replace { public static void main(String[] args) { String str = \"helloworld\"; String stra = str.substring(0,5); System.out.println(stra); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:92","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何对字符串str = “hello yootk nihao mldn” 按照空格拆分? str.split(” “); public class Replace { public static void main(String[] args) { String str = \"hello yootk nihao mldn\"; String[] stra = str.split(\" \"); for (int i = 0; i \u003c stra.length; i++) { System.out.print(stra[i] + \"、\"); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:93","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何对字符串str = “hello yootk” 全部拆分? str.split(\"\"); 设置一个空字符串，表示全部拆分 public class Replace { public static void main(String[] args) { String str = \"hello yootk\"; String[] stra = str.split(\"\"); for (int i = 0; i \u003c stra.length; i++) { System.out.print(stra[i] + \"、\"); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:94","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将字符串str = “hello yootk nihao mldn” 按照空格，拆分成2个? public class Replace { public static void main(String[] args) { String str = \"hello yootk nihao mldn\"; String[] stra = str.split(\" \", 2); for (int i = 0; i \u003c stra.length; i++) { System.out.print(stra[i]); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:95","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将str = “192.168.1.2” 按照 “.” 拆分? 直接用 “.” 是无法进行拆分的， 需要用 “\\.” 来转义 public class Replace { public static void main(String[] args) { String str = \"192.168.1.1\"; String[] stra = str.split(\"\\\\.\"); for (int i = 0; i \u003c stra.length; i++) { System.out.println(stra[i]); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:96","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将 str = “张三:20|李四:21|王五:20” 拆成 张三，年龄:20, 这样的格式? 这里需要第一次按照 | 来拆分， 第二次按照 : 来拆分 stra.splilt(”.\"); public class Replace { public static void main(String[] args) { String str = \"张三:20|李四:21|王五:22\"; String[] stra = str.split(\"\\\\|\"); for (int i = 0; i \u003c stra.length; i++) { String[] temp = stra[i].split(\":\"); System.out.println(\"学生\" + temp[0] + \"的年龄为\" + temp[1]); } } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:97","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将str = “((Hello((” 全部转成大写? str.toUpperCase() public class Replace { public static void main(String[] args) { String str = \"(*(*Hello(*(*\"; System.out.println(str.toUpperCase()); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:98","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何将str = “((Hello((” 全部转成小写? public class Replace { public static void main(String[] args) { String str = \"(*(*Hello(*(*\"; System.out.println(str.toLowerCase()); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:99","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何去掉str = \" hello world \" 左右两过的空格? str.trim() public class Replace { public static void main(String[] args) { String str = \" hello world \"; System.out.println(str.trim()); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:100","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何去掉str = \" hello world \" 所有的空格? str.replaceAll(” “,\"\") public class Replace { public static void main(String[] args) { String str = \" hello world \"; System.out.println(str.replaceAll(\" \",\"\")); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:101","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"获取 String类中的length 与 数组中的length 有什么区别? String 中取得长度使用的是 length() 方法，只要是方法后面都要有”()” 数组中没有 length() 方法只有 length 属性 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:102","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何判断 str = “helloworld” 是否是空字符串? str.isEmpty() public class Replace { public static void main(String[] args) { String str = \"hello,world\"; System.out.println(str.isEmpty()); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:103","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何实现str = “yootk” 中首字母大写? temp.substring(); public class Replace { public static void main(String[] args) { String str = \"hello,world\"; System.out.println(initcap(str)); } public static String initcap(String temp){ return temp.substring(0,1).toUpperCase() +temp.substring(1); } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:104","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何想用 this 调用本类方法， 应该如何使用? this.方法() ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:105","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何想用 this 调用本类的构造方法，应该如何使用? this() ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:106","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"使用 this 调用构造方法时，存在什么样的限制? this() 调用构造方式形式的代码只能够放在构造方法的首行 进行构造方法互相调用时，一定要保留调用的出口 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:107","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何利用构造方法互调用简化代码? public class Employer { public static void main(String[] args) { } } class Emp { private int empno; private String ename; private double sal; private String dept; public Emp() { this(0, \"无名氏\", 0.0, \"未定\"); } public Emp(int empno){ this(empno, \"临时工\", 8000.0, \"后勤部\"); } public Emp(int empno, String ename){ this(empno, ename, 2000.0, \"技术部\"); } public Emp(int empno, String ename, double sal, String dept){ this.empno = empno; this.ename = ename; this.sal = sal; this.dept = dept; } public String getInfo(){ return \"雇员编号:\" + this.empno + \", 姓名:\" + this.ename + \", 工资:\" + this.sal + \", 部门:\" + this.dept; } } ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:108","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"它们输出的是一样的吗? 为什么? 是一样的 this 关键字指的就是 当前正在调用类中方法的实例化对象 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:109","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"引用传递的核心意义是什么? 同一块堆内存空间可以被不同的栈内存所指向，不同栈内存 可以对 同一堆内存 进行内容的修改 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:110","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"画出此程序的内存结构图 Message msg = new Message(30); 实例化 Message 类对象 fun(msg) 引用传递，fun 的 temp 参数接收引用 temp.setNum(100) 在 fun() 方法中修改 num 内容为 100 fun() 方法执行完毕 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:111","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"画出此程序的内存结构图 String 类对象内容的改变是通过引用的变更实现的，但是所有的变更都是在 fun() 方法中完成的，一旦 fun() 方法执行完毕 temp 将失效，其对应的堆内存也将成为垃圾 String msg = “Hello” 实例化 String 类对象 fun(msg) 引用传递， temp 与 msg 引用相同地址 temp = “World” 修改 temp 内容， 开辟新内容 fun() 结束 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:112","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"画出此程序的内存结构图 Message msg = new Message(“Hello”); 实例化 Message 类对象 fun(msg) 引用传递， temp 与 msg 引用相同 temp.setInfo(“World”); 修改 info 属性内容 fun() 方法执行完毕 方法执行完毕 temp 断开引用 ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:113","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["java"],"content":"如何实现? ","date":"2021-03-25","objectID":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/:0:114","tags":["java"],"title":"Java第三章","uri":"/posts/java%E7%AC%AC%E4%B8%89%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"什么是纯文本文件? 文件记录就是0与1, 面通过编码系统将这些0与1转成如我们认识的文字 ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:1","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, n + 代表什么操作? 表示光标会向 右 移动 n 个字符 ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:2","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 如何移动到这一列的最后面字符处? $ ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:3","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 如何将光标移动到这个屏幕中央那一列的第一个字符? M ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:4","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 如何移动到第n行? nG ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:5","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 光标如何向下移动n行? n ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:6","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 如何在第 n1 与 n2 列之间寻找 word1 ， 并将该字串取代为 word2? :n1, n2s/word1/word2/g ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:7","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中，如何在第一行到最后一行寻找 word1 字串，并将该字串取为 word2, 且在取代前显示提示字符给使用者确认? :1, $1/word1/word2/gc ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:8","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中，如何在第一行到最后一行寻找 word1 字串，并将该字串取为 word2? :1, $1/word1/word2/g ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:9","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何向后删除n个字符? nx ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:10","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何向前删除n个字符? nX ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:11","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何删除光标所在行到第一行的所有数据? d1G ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:12","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何删除光标所在行到最后一行的所有数据? dG ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:13","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何删除光标所在处，到该列的最后一个字符? d$ ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:14","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何删除光标所在处，到该列的最前面的一个字符? d0 ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:15","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何复制光标所在行到第一行的所有数据? y1G ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:16","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何复制光标所在行到最后一行的所有数据? yG ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:17","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 如何复制光标所在的那个字符到该列行首的所有数据? y0 ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:18","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 如何复制光标所在的那个字符到该列行尾的所有数据? y$ ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:19","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 如何使光标所在行与下一行的数据结合成同一行? J ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:20","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何复原前一个动作? u ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:21","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何重做上一个动作? [Ctrl] + r ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:22","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中，如何将已复制的数据在光标下一列贴上? p ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:23","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中，如何将已复制的数据在光标上一列贴上? P ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:24","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中，如何重复前一个动作? . ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:25","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何在当前光标所在的下一个字符处开始插入? a ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:26","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何在当前光标所在的上一列插入新的一列? O ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:27","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何取代光标所在的那一个字符一次? r ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:28","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何取代光标所在的文字，直到按下 ESC 为止? R ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:29","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何实现若文件没有更动，则不储存离开，若文件已经被更动过，则储存后离开? ZZ ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:30","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中, 如何实现在编辑的数据中，读入另一个文件的数据，将 fielname 这个文件内容加到光标所在的后面？ :r [filename] ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:31","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何实现将 n1 到 n2 的内容储存成 filename 这个文件中? :n1, n2 w [filename] ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:32","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何暂时离开 vim, 执行 bash 中的命令? :! command ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:33","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何设置显示行号? :set nu ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:34","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何进行区块选择（用长方形的方式选择数据）? [Ctrl] + V ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:35","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何列出目前这个 vim 打开的所有文件? :files ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:36","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 若同时打开多个文件，如何编辑下一个文件？ :n ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:37","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 若同时打开多个文件，如何编辑上一个文件？ :N ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:38","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何以当前目录内的\"文件名\"作为关键字，予以补齐? [ctrl] + x –\u003e [Ctrl] + f file CTRL-x_CTRL-F ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:39","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何以正在编辑的这个\"文件的内容文字\"作为关键字，予以补齐? [ctrl] + x –\u003e [Ctrl] + n Keywords in the current file CTRL-x_CTRL-n ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:40","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在 vim 中， 如何以扩展名作为语法补充，以 vim 内置的关键字，予以补齐? [ctrl] + x -\u003e [ctrl] + O omni completion CTRL-x_CTRL-O ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:41","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"~/.viminfo 保存的是什么? 它是记录动作的文件. ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:42","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看到文件中的断行字符? cat -A ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:43","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"window 与 linux 中的断行字符是否相同? 不同 ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:44","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/man_db.conf 重新复制到 /tmp/vitest 下面，并将其修改成为 dos 断行? cd /tmp/vitest cp -a /etc/man_db.conf /tmp/vitest/ unix2dos -k man_db.conf dos2unix DOS/Mac to unix and vice versa text file format converter -k Keep the data stamp of output file same as input file ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:45","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 man_db.conf 转成 Linux 断行字符, 并保留旧文件，新文件放于 man_db.conf.linux dos2unix -k -n man_db.conf man_db.conf.linux -k Keep the data stamp of output file same as input file -n, –newfile INFILE OUTFILE … New file mode. Convert file INFILE and write output to file OUTFILE. ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:46","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看一个文件是 win 下创建的文件还是 linux 下创建的文件？ file man_db.conf* ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:47","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 vi.big5 这个文件转成 vi.utf8? iconv -f BIG5 -t utf8 vi.big5 \u003e vi.utf8 iconv convert text from one character encoding to another -f from-encoding, –from-code=from0encoding Use from-encoding for input characters -t to-encoding, –to-code=to-encoding Use to-encoding for output characters. ","date":"2021-03-21","objectID":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/:0:48","tags":["linux"],"title":"Linux第九章","uri":"/posts/linux%E7%AC%AC%E4%B9%9D%E7%AB%A0/"},{"categories":["java"],"content":"如何做文档注释? 以 /** 开头， 以 */ 如 /** @author gaungsizhongbin */ ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:1","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"在JAVA中数据类型分为哪几种? 基本数据类型 引用数据类型 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:2","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"基本类型 与 引用类型 有什么区别? 基本类型会涉及内存的分配 引用类型不会涉及内存的分配 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:3","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"基本类型 包括哪几种? 数值型 整数类型 (byte, short, int, long) 浮点类型 (float, double) 字符型(char) 布尔型(boolean) ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:4","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"byte 可表示的数据范围是多少? byte 是8位大小， $- (2^8 / 2)$ ~ $(2^8 / 2) - 1$ ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:5","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"short 可表示的数据范围是多少? short 是16位大小, $- (2^{16} / 2)$ ~ $(2^{16} / 2) - 1$ ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:6","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"int 可表示的数据的范围是多少? int 是32位大小，$- (2^{32} / 2)$ ~ $(2^{32} / 2) - 1$ ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:7","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"long 可表示的数据的范围是多少? long 是64位大小, $- (2^{64} / 2)$ ~ $(2^{64} / 2) - 1$ ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:8","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"char 可表示的数据的范围是多少, 其默认值什么? char 是16位大小， 0~255, 其默认值为 \\u0000 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:9","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"为什么在 char 为 16位大小， 其表示的数据范围是$0$ ~ $255$, 而不是 - $(2^{16} / 2)$ ~ $(2^{16} / 2)$ - $1$? ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:10","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"为什么在表示数据的范围时，最小负数绝对值总比最大正数多1? ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:11","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如果要描述日期时间数字或者表示文件或内存大小时，用什么基本数据类型好? long ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:12","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如果要实现内容传递(IO 操作、网络编程)或者是编码转换(JSP开发中使用UTF-8编码), 用什么数据类型好? byte ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:13","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如果要想实现逻辑的控制，使用什么数据类型好? boolean ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:14","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如果要想算是中文，使用什么数据类型可以避免乱码问题? char ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:15","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何避免由于编译器bug所造成的非正常性语法的编译错误? 在每一个操作中都加上一个\" \" 空格 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:16","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何通过代码实现求int的最大值和最小值，并且实现超过其最大值和最小值的结果? Interger.Min_VALUE Interger.MAX_VALUE public class interger_text{ public static void main(String arg[]){ int max = Integer.MAX_VALUE; //取出最大值 int min = Integer.MIN_VALUE; //取出最小值 System.out.println(max); System.out.println(min); // int 变量 + int 型变量 = int 型数据 System.out.println(max + 1); System.out.println(min - 1); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:17","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"为了解决数据溢出的问题，想将 int 型的变量或常量变为 long 数据类型，该怎么做? 常量: 数字L 变量: (long) 变量名称 public class IntToLong{ public static void main(String args[]){ int max = Integer.MAX_VALUE; int min = Integer.MIN_VALUE; // int 变量 + long型常量 = long 型数据 System.out.println(max + 1L); System.out.println(min - (long) 1); // long 变量 - int 型常量 = long 型数据 System.out.println((long) min - 2); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:18","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何将long num = 100, 变成int num的数据类型? int (num) public class LongToIntP{ public static void main(String args[]){ long num = 1000; int x = int (num); System.out.println(x); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:19","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"long num = 2147483650L; 其转换成int会怎样? int 是32位大小， 2147483650L已超过其数据范围 public class LongToIntOverflow{ public static void main(String args[]){ long num = 2147483650L; int x = (int) num; System.out.println(x); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:20","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"ava 中的自动类型转换是如何规定的, 以 byte 变成 int 为例? 如果使用的数据变量类型为 byte, 如果设置的内容在 byte 数据范围 之内，就会自动帮助用户实现数据类型的转换 如果设置的内容在 byte 数据范围 之外 ，就会强制进行类型转换 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:21","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"默认情况下 java 只要是小数，其对应的默认数据类型就是 double, 如何实现 double 向 float 转换? 使用字母 “F” 或 “f” 在变量或常量前使用 “(float)” 声明 public class DoubleToFloat{ public static void main(String args[]){ float f1 = 10.2F; float f2 = (float)10.2; System.out.println(f1 * f2); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:22","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"int, char, long型可以保存小数吗? 不可以， 只有 float 和 double 才可以保存小数 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:23","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"其计算结果有小数吗?为什么? 没有小数 因为两个 int 类型的变量计算后还是 int 类型 而 int 类型是不保存小数的，只有 double 和 float 类型才可以保存小数 将其必成 double 类型，其最终的结果也会自动转换成 double 类型 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:24","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"大写字母范围与小写字母范围是多少？ 它们之间差了多少? 如何用代码实现 ‘A’ 向 ‘a’ 转换? 大写字母范围: 65 ~ 90 小写字母范围: 97 ~ 122 它们之间差了32 public class aToA{ public static void main(String args[]){ char c = 'A'; int num = c; num = num + 32; c = (char) num; System.out.println(c); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:25","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"char 可以与 int 型互相转换吗? 为什么? 可以 public class NumberToChar { public static void main(String args[]){ char c = 'A'; int num = c; System.out.println(c); System.out.println(num); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:26","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"char 可以保存中文字符吗? 为什么? 可以， java 中， 使用了 UNICODE 编码，这种 十六进制 编码可以保存任意的文字 public class ChineseChar{ public static void main(String args[]){ char c = '王'; int num = c; System.out.println(num); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:27","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"java 中可以用 0 或 1 来填充布尔型的变量内容吗? 不可以, 只可以用 false , true, 并且区分大小写 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:28","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何实现在 str = “Hello” 基础上，再加上 “World!!!”? += ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:29","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何使用三目运算符号实现 int max 是 num A 与 num B 中最大的一个? 数据类型 变量 = 布尔表达式 ? 满足此表达式时设置的内容 : 不满足此表达式时设置的内容 public class TernaryOperator{ public static void main(String args[]){ int numA = 10; int numB = 20; int max = numA \u003e numB ? numA: numB; System.out.println(max); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:30","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"普通(\u0026) 与 短路(\u0026\u0026), 普通(|) 与 短路(||) 有什么区别? \u0026\u0026 只要第一个条件 不成立 就不执行了 || 只要第一个条件 成立 就不执行了 而 \u0026 和 | 都需要全部执行完 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:31","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何用代码实现十进制转二进制? ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:32","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何更快的计算出2的3次方? 左移2位 public class TwoToEight { public static void main(String args[]){ int x = 2; System.out.println(x \u003c\u003c 2); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:33","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"什么时候用 if? 什么时候用 switch ? 范围判断时用 if public class CoreDegree { public static void main(String args[]){ double score = 30.0; if(score \u003c 60.0){ System.out.println(\"小白的成绩\"); } else if(score \u003e= 60 \u0026\u0026 score \u003c= 90){ System.out.println(\"成绩中等\"); } else if(score \u003e 90 \u0026\u0026 score \u003c= 100){ System.out.println(\"成绩优秀\"); } else { System.out.println(\"不可能\"); } } } 值判断时用 switch public class GuessNum{ public static void main(String args[]){ int ch = 1; switch (ch) { case 2: { System.out.println(\"内容是2\"); break; } case 1: { System.out.println(\"内容是1\"); break; } case 3: { System.out.println(\"内容是3\"); break; } default: { System.out.println(\"没有匹配内容\"); break; } } } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:34","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"JAVA 中的 while 循环有哪两种? while 循环 do…while 循环 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:35","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何用 do…while 循环实现100以内的加法? public class DoWhileToHundred{ public static void main(String args[]){ int sum = 0; int current = 1; do{ sum += current; current++; } while (current \u003c= 100); System.out.println(sum); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:36","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何用 while 循环实现100以内的加法? 这个在实际开发中比较常用 public class WhileToHundred { public static void main(String args[]){ int sum = 0; int current = 1; while(current \u003c= 100){ sum += current; current++; } System.out.println(sum); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:37","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"在工作中什么时候用for循环和while循环？ while 循环: 在 不确定循环次数 ，但是确定循环结束条件的情况下使用 for 循环: 确定循环次数 的情况下使用 如: 一口口的吃饭，一直吃到饱为止，可是并不知道要吃多少口，只知道结束条件， 用 while 围着操场跑两圈步，已经明确知道了循环的次数， 用 for ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:38","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"continue 与 while 有什么区别? continue 会结束当前一次循环，直接进行下一次循环的操作 public class ObserveContinue{ public static void main(String args[]){ for(int x = 0; x \u003c 10; x++){ if(x == 3){ continue; } System.out.print(\"x = \" + x + \"、\"); } } } break 会直接挑出最近的循环 public class ObserveBreak{ public static void main(String args[]){ for(int x = 0; x \u003c 10; x++){ if(x == 3){ break; } System.out.println(\"x = \" + x + \"、\"); } } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:39","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"其他语言中的函数与 JAVA 中的方法有什么关系? 方法又被称为函数， Java 中的英文单词是 Method 其他语言中的英文单词是 Function ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:40","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何写出一个没有参数，没有返回值的方法 printInfo? 方法要用 static 修饰 public class NoReturnMethod { public static void main(String args[]) { printInfo(); printInfo(); } public static void printInfo() { System.out.println(\"*****************\"); System.out.println(\"* fengqigang.cn *\"); System.out.println(\"*****************\"); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:41","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"在JAVA中，如何要给方法命名，其规范是什么? 第一个单词小写，之后每个单词首字母大写 如： printInfo() getMessage() ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:42","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"写文档注释需要注意什么?如何写出其文档注释? 整个方法的用途 @param 变量的作用 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:43","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何写出其文档注释? ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:44","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"在 Java 中, method 的 return 如何使用? 方法有返回值声明，那么必须返回相应类型的数据 方法没有返回值声明，可以直接编写 return public class NoneReturnMethod { public static void main (String args[]) { set(100); set(3); set(10); } /** * 定义一个设置数据的操作方法，如果该数据为3将无法设置 * @param x 要设置的数据内容 */ public static void set(int x) { if (x == 3) { return; } System.out.println(\"x =\" + x); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:45","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"在 Java 中，什么是方法的重载? 是指 方法名称相同 ，参数的类型或个数不同 ，调用的时候将会按照传递的类型和个数完成不同方法全的执行 public class MethodReload { public static void main(String args[]) { System.out.println(\"两个整型参数:\" + add(10, 20)); System.out.println(\"三个整型参数:\" + add(10,20, 30)); System.out.println(\"两个浮点型参数:\" + add(10.2, 20.3)); } /** * 实现两个整型数字的加法计算操作 * @param x 操作数字一 * @param y 操作数字二 * @return 两个整型数据的加法计算结果 */ public static int add(int x, int y){ return x + y; } /** * 实现三个整型数字的加法计算操作 * @param x 操作数字一 * @param y 操作数字二 * @param z 操作数字三 * @return 三个整型数据的加法计算结果 */ public static int add(int x, int y, int z){ return x + y + z; } /** * 实现三个小数的加法计算操作 * @param x 操作数字一 * @param y 操作数字二 * @return 两个小数的加法计算结果 */ public static double add(double x, double y){ return x + y; } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:46","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"在设计方法重载时需要注意什么? 所有重载后的方法使用同一种返回值类型 根据 参数类型及个数来区分不同的方法 ，而不是依靠返回值的不同来确定的 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:47","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"什么是递归调用? 是指方法自己调用自己形式 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:48","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"若使用递归操作需要满足什么条件? 必须有结束条件 第次调用时都需要改变传递的参数 ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:49","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何用递归写出1-100累加? public class RecusiveAddToHundred { public static void main(String args[]){ System.out.println(sum(100)); } /** * 数据的累加操作 * @param num 要进行累加的操作 * @return 数据的累加结果 */ public static int sum(int num){ if (num == 1){ return 1; } return num + sum(num - 1); } } ","date":"2021-03-17","objectID":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/:0:50","tags":["java"],"title":"Java第二章","uri":"/posts/java%E7%AC%AC%E4%BA%8C%E7%AB%A0/"},{"categories":["java"],"content":"如何查看当前 java 版本? archlinux-jav status ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:1","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"如何编写 Hello.java? public class Hello { public static void mian(String args[]){ System.out.println(\"Hello World!\"); } } ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:2","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"public 定义的的class有什么特点? 类名称必须与文件名称保持一致 在一个 *.java 中只能有一个public class ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:3","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"普通的class有什么特点? 类的名称可以和文件名不致， 但是生成的class定义的名称 一个*.java程序中可以同时存在多个class定义，编译后会分为不同的*.class文件 ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:4","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"System.out.print 与 System.out.println 有什么区别? System.out.print 输出后不换行 System.out.println 输出后换行 ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:5","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"类的命名规范是什么样的? 每一个单词的开关首字母大写 TestDemo ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:6","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"CLASSPATH 与 JVM 有什么关系? 而 JVM 在运行的时候，需要通过 CLASSPATH 加载所需要的类 CLASSPATH 是指类的运行路径, 默认情况下 CLASSPATH 指向当前目录 ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:7","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"PATH 与 CLASSPATH 的区别是什么? PATH 是操作系统的环境属性，指的是可以执行命令的程序路径。 CLASSPATH 是所有 *.class 文件的执行路径， Java 命令执行时将利用此路径加载所需要的 *.class 文件. ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:8","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"Java 源程序文件的后缀和 Java字节码文件的后缀 分别是什么? 源程序文件: *.java 字节码文件: *.class ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:9","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["java"],"content":"Java Application 与 Java Applet 程序有什么区别? Java Applet 主要是在网页中嵌入的 Java 程序 Application 是指有 main 方法的程序 ","date":"2021-03-13","objectID":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/:0:10","tags":["java"],"title":"Java第一章","uri":"/posts/java%E7%AC%AC%E4%B8%80%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"什么是压缩的原理是什么? 压缩 : 如果数据为\"111…“共用100个, 压缩技术会记录为\"100个1\"而不是真的有100个1的位存在 ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:1","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 tar 备份 /etc (tar.gz)? 切换成 root 用户 time tar -zpcv -f /root/etc.tar.gz /etc -z, –gzip, –gunzip, –ungzip Filter the archive through gzip -p, –preserve-permissions, –same-permissions extract information about file permissions(default for superuser) -c, –create Cteate a new archive. Arguments supply the names of the files to be archived. Directories are archived recursively, unless the –no-recursion option is given. -v, –verbose Verbosely list files processed. Each instance of this option on the command line increases the verbosity level by one. The maximum verbosity level is 3. -f, –file=ARCHIVE Use archive file or device ARCHIVE ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:2","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"用 tar 备份时， .tar.gz, tar.bz2, tar.xz 分别要对应什么参数? .tar.gz time tar -zpcv -f /root/etc.tar.gz /etc -z, –gzip, –gunzip, –unzip Filter the archive through gzip. tar.bz2 time tar -jpcv -f /root/etc.tar.bz2 /etc -j, –bzip2 Filter the archive through bzip2 tar.xz time tar -Jpcv -f /root/etc.tar.xz /etc -J, –xz Filter the archive through xz ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:3","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看 /root/etc.tar.bz2 内的文件? tar -jtv -f /root/etc.tar.bz2 -t, –list List the contents of an archive. Arguments are optional. When given, they specify the names of the members to list. ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:4","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么查看 /root/etc.tar.bz2 里面的文件，都没有根目录? 如果拿掉根目录，假设备份数据在 /tmp 解开，那么解压缩的文件就会变成 /tmp/etc/ 如果没有拿掉根目录,解压缩的文件名就会是绝对路径，数据一定会放置到 /etc 中去 ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:5","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"tar -jcvf filename 和 tar -jvfc filename 是一样的吗? 不一样 -jvfc 会导致产生的文件名变成 c 最好将 -f filename 与其他选项项独立出来 ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:6","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /root/etc.tar.bz2 解压到 /tmp 下? tar -jxv -f /root/etc.tar.bz2 -C /tmp -C, –directory=DIR Change to DIR before performing any operations. This option is order0sensitive, i.e. it affects all options that follow. -j, –bzip2 Filter the archive through bzip2 -v, –verbose Verbosely list files processed. Each instance of this option on the command line increases the verbosity level by one. The maximum verbosity level is 3. ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:7","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /root/etc.tar.bz2 中的 etc/shadow 解压出来? 找一找看有没有 shadow tar -jtv -f /root/etc.tar.bz2 | grep ‘shadow’ -j, –bzip2 Filter the archive through bzip2 -t, –list List the contents of an archive. Arguments are optional. When given, they specify the names of the members to list. -v, –verbose Verbosely list files processed. Each instance of this option on the command line increases the verbosity level by one. The maximum verbosity level is 3. 解压 etc/shadow tar -jxv -f /root/etc.tar.bz2 etc/shadow ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:8","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若想用 tar 打包 /etc /root 但不想打包 /root/etc* 开头的文件，该如何做? –exclude= tar -jcv -f /root/system.tar.bz2 –exclude=/root/etc* –exclude=/root/system.tar.bz2 /etc /root 不包括 /root/etc, 同时不能包括自己 ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:9","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 tar 备份 /etc/passwd 中比 /etc/passwd 还要新的文件? 找出比 /etc/passwd 还要新的文件 find /etc -newer /etc/passwd 查看 /etc/passwd 的 mtime 打包 tar -jcv -f /root/etc.newer.then.passwd.tar.bz2 –newer-mtime=“2021/03/01” /etc/* 显示出文件 tar -jtv -f /root/etc.newer.then.passwd.tar.bz2 | grep -v “/$” 调出非 / 的文件名 ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:10","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /home, /root, /etc 备份到磁带机 /dev/st0 上? tar -cv -f /dev/st0 /home /root /etc ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:11","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 tar 一边将 /etc 整个目录打包一边在 /tmp 解开? tar -cvf - /etc | tar -xvf - - 表示被打包的文件 ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:12","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 tar 对系统备份? /etc/ (配置文件) /home/ (使用者的主文件夹) /var/spool/mail/ (系统中，所有账号的邮件信箱) /var/spool/cron/ (所有账号的工作排成配置文件) /root (系统管理员的主文件夹) 设置备份数据的目录与权限 mkdir /backups chmod 700 /backups ls -d /backups 备份 tar -jcv -f /bakups/backup-system-20210312.tar.bz2 /etc /home /var/spool/mail /var/spool/cron /root ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:13","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 ** /etc/passwd ** 备份到 ** /tmp/passwd.back ** 当中? dd if=/etc/passwd of=/tmp/passwd.back ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:14","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 ** /boot ** 整个文件系统通过 dd 备份下来? df -h /boot dd if=/dev/sda1 of=/tmp/vda1.img ls -lh /tmp/vda2.img 文件大小 会跟整颗磁盘的最大量一样大 ","date":"2021-03-11","objectID":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/:0:15","tags":["linux"],"title":"Linux第八章","uri":"/posts/linux%E7%AC%AC%E5%85%AB%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么硬盘在分区后需要进行格式化呢? 因为每个操作系统所设置的文件属性/权限并不相同，为了存放这些文件所需的数据，因此就需要将分区进行格式化, 以成为操作系统能够利用的文件系统格式。 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:1","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在ext2中, superblock, inode和block是什么样的关系? superblock : 记录此 filesystem的整体信息，包括inode/block的总量、使用量、剩余量，以及文件系统的格式与相关信息。 inode: 记录文件的属性，一个文件占用一个inode, 同时记录此文件的数据所在的block号码。 block: 实际记录文件的内容，若文件太大时，会占用多个block ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:2","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么在window系统下常听到需要磁盘整理？ 如U盘，其文件格式是FAT, 这种文件格式没有inode存在，因此FAT没法将这个文件的所有block在一开始就读取出来 其采取的方法是这样的 当数据过于离散的时候，读取一个文件有可能要转好几圈。 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:3","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若Ext2文件系统使用4K block, 而该文件系统中有10000个小文件，每个文件大小均为50Bytes, 请问此时磁盘会浪费多少容量? 在Ext2文件系统中一个block仅能容纳一个文件， 则一个文件将浪费4096 - 50 = 4046 Bytes. 4046 * 10000 / 1024 / 1024 = 38. 58MB ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:4","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出目前系统有被格式化的设备? blkid **** locate/print block device attributes **** ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:5","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"每个inode大小均固定为128bytes, 而inode记录一个block号码要花掉4byte, 假设一个文件有400MB, 且每个block为4KB，那么至少也要10万条block号码的记录，inode哪有这么多的可以记录的信息？它采用了什么样的方法解决这个问题? 系统将indoe 记录的block号码的区域定义为12个直接，一个间接，一个双间接，与一个三间接记录区 则若一个block为1KB, 12个直接: 12 x 1KB = 12KB 1个间接: 256 x 1KB = 256KB 每条block号码的记录会花去 4bytes, 因此1KB 的大小能记录256条记录 1个双间接: 256 x 256 x 1KB = $256^2$ KB 1个三间接: 256 x 256 x 256 x 1KB = $256^3$ KB 即: 当文件系统将block格式化为1K大小时，能够容纳最大文件为16GB ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:6","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若在Linux下的ext2文件系统新建一个目录，ext2会做什么？ ext2 至少会分配一个 inode 与至少一块 block 给该目录 inode 记录该目录的相关权限与属性, 并记录分配到的那块block号码 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:7","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看root目录内的文件所占用的inode号码? ls -li -i, –inode print the index number of each file ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:8","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么这些文件夹的大小都是1024的倍数? 因为 /dev/sda2 采用的 Block size 为 4096 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:9","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么 /proc 文件夹的大小为0? 因为这个目录是一个虚拟文件系统(virtual filestem). 它放置的数据都是在内存当中。 因为这个目录下的数据都是在内存当中，所以本身不占任何硬盘空间。 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:10","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若在ext2下新建一个100KB的文件，block为4KB, ext2会怎么做? 在linux下的ext2新建一个文件时，ext2分分配一个inode与相对于该文件大小的block数量给该文件。 当文件为100KB时，linux会分配一个 inode, 与25个 block来记录数据 但inode仅有12个直接指向 block记录 ，因此还要多一个block间接指向另外的13个 block记录 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:11","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"ext2是如何读取 /etc/passwd这个文件的? **/** 的 inode: 通过挂载点的信息找到inode号码为2的根目录inode, 且 inode 规范的权限让我们可以读该block的内容(有r与x) **/** 的 block: 通过上个步骤取得block的号码，并找到该内容有 /etc inode号码(5767169) **etc/** 的 inode: 读取5767169号 inode 得知feng具有r与x权限，因此可以读取 etc/ 的block内容 **etc/** 的 block: 经过上个步骤取得block号码，并找到有 passwd 文件的 inode 号码 (5775935) passwd 的inode: 读取 5775935 号inode得知feng具有r的权限，因此可以读取passwd的内容 passwd 的block: 最后将该block内容的数据读出来 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:12","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何需要新建一个文件或目录时，Ext2是如何处理的呢? 先确定用户对欲添加文件的目录是否具有w与x的权限，若有的话才能添加 根据 inode bitmap 找到没有使用的 inode 号码， 并将新文件的权限/属性写入 根据 block bit map 找到没有使用的 block 号码， 并将实际的数据写入 block 中， 且更新 inode 的 block 指向数据 将刚才写入的 inode 与 block 数据同步更新 inode bitmap 与 block bitmap, 并更新superblock的内容 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:13","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若在新建一个文件的时候，仅写入 inode table 及 data block ， 但因突然停电 inode bitmap 与 block bitmap, superblock都没有更新，此时linux是如何解决这个问题的? 文件系统中会规划出一个块，该块专门记录写入或修订文件时的步骤 预备: 当系统要写入一个文件时，会先在日志记录块中记录某个文件准备要写入的信息 实际写入: 开始写入文件的权限与数据；开始更新meta data的数据 结束: 完成数据与 meta data 的更新后，在日志记录块当中完成文件的记录 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:14","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"/ /. /.. 是什么关系? / /. /.. 三个文件所对应的 inode 是2, 它们都是相同的，所以这几个文件是相同的 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:15","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将系统内所有的文件系统列出来? df ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:16","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将系统内所有的文件系统更出来同时容量结果以易读的容量格式显示出来? df -h -h, –human-readable print sizes in powers of 1024 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:17","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将系统内所有特殊文件格式入名称及名称都列出来, 如 /proc 挂载点的文件? df -aT -a, –all include pseudo, duplicate, inaccessible file systems -T, –print-type print file system type ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:18","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc 下面的可用的磁盘容量以容量以易读的容量格式显示? df -h /etc ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:19","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将目前各个分区当中可用的 inode 数量列出? df -ih ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:20","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何列出目录下所有目录的容量，包括自己? du ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:21","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何列出目录下所有文件的容量? du -a -a, –all write counts for all files, not just directories ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:22","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何检查根目录下面每个目录所占用的容量? sudo du -sm /* -s, –summarize display only a total for each argument -m like –block-size=1M ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:23","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"hard link的原理是什么样的? 因为: 每个文件都会占用一个 inode, 文件内容由 inode 的记录来指向 想要读取该文件，必须要经过目录记录的文件名来指向到正确的 inode 号码才能读取 文件名只与目录有关，但是文件内容则与 inode 有关 1 和 2 都是通过自己的目录的 inode 指定的 block 找到两个不同的文件名，最终都可以通过 real 的 指向的 inode 来读取数据 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:24","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"可以用 hard link制作目录吗? 为什么呢? 不行 hard link 链接到目录时，链接的数据需要连同被链接目录下面的所有数据都创建链接，会造成环境相当大的复杂度。 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:25","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"symbolic link的原理是什么样的? 两个文件指向不同的 inode , 所以这是两个不同的文件 456.md 有6 Bytes，是因为 456.md 占6个Bytes. Symbolic Link 相当于 Window 的快捷方式 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:26","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在创建一个新的目录的时候，它的默认link是多少? 新的目录会有 /video , /video/. , /video/.. 其中 /video 与 /video/. 相同 /video 指代上一目录 因此， 在创建新目录时, 新目录的 link 为2, 而上层目录的 link 数会增加1 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:27","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何列出当前系统上的所有磁盘列表? lsblk list block device ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:28","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何只列出 /dev/sda 设备内的所有数据的完整文件名? lsblk -ip /dev/sda -i, –ascii Use ASCII characters for tree formatting -p, –paths Print full device paths ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:29","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"什么是设备的UUID?如何获取? UUID 是全域单一识别码 (universally unique identifier) Linux会将系统内的所有设备都给予一个独一无二的识别码, 这个识别码就可以拿来作为挂载或者是使用这个设备/文件系统之用了 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:30","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何输出 /dev/sda 的分区信息? sudo parted /dev/sda print print Display the partition table. ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:31","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"MBR 分区表和 GPT 分区表使用什么工具来分区? MBR 分区表使用 fdisk GPT 分区表使用 gdisk ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:32","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /vdb 分成GPT分区表，创建 /vdb1 和 /vdb2 各10G的ext4格式的分区? 建立 GPT 分区表 分区 格式化 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:33","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何挂载centos光盘到 /data/cdrom 吗? mount /dev/sr0 /data/cdrom ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:34","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 /dev/vdb1 的UUID, 并以UUID挂载到/data/xfs 找出UUID 挂载 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:35","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /var 挂载到另外一个目录去，而不是挂载整个 /? sudo mount –bind /var /data/var -B, –bind Remount a subtree somewhere else (so that its contents are available in both places). ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:36","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /data/var 设备卸载? umount /data/var ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:37","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"假设要将 /dev/nvme0n1p1 每次开机才自动挂载到 /data/var, 该如何进行? 填写 /etc/fstab 测试是否能载入 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:38","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"万一 /etc/fstab 输入的数据错误， 导致无法顺利开机成功，而进入单人维护模式当中， / 是 read only, 无法修改 /etc/fstab , 该怎么办? /etc/fstab 是开机时的配置文件，不过，实际 filesystem 的挂载是记录到 /etc/mtab 与 /proc/mounts 这两个文件当中的, 每次在更动 filestem 的挂载时，也会同时更动这两个文件. mount -n -o remount, rw / -n, –no-mtab Mount without writing in /etc/mtab. This is necessary for example when /etc is on a read-only filesystem. -o, –options opts Use the specified mount option. THe opts argument is a comma-separeated list. remount Attempt to remount an already-mounted filesystem. This is commonly used to change the mount flags for filesystem, especially to make a readonly filesystem writable. ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:39","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何创建一个 512M 的文件在 /tmp 下? dd if=/dev/zero of=/tmp/512 bs=1M count=512 bs=BYTES read and write up to BYTES bytes at a time(default: 512); overrides ibs and obs count=N copy only N input blocks ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:40","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何在原本的分区不更动原有的环境下制作出一个新的分区? 注意一开始就要使用root用户 新创建一个分区, 假设是512M的文件 dd if=/dev/zero of=/tmp/512 bs=1M count=512 格式化 mkfs.xfs -f /tmp/512 挂载 mount -o loop UUID=“6fcbfc5b-f7b6-4e11-a845-adadb3d4dce0” /mnt 查看是否挂载上 df /mnt ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:41","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"** swap ** 分区是干什么用的? CPU 所读取的数据都来自于内存，那当内存不足的时候，为了让后续的程序可以顺利的运行, 因此在内存中暂时不使用的程序与数据就会被挪 swap 中了。 此时内存就会空出来给需要执行的程序载入。 由于 swap 是用磁盘来暂时放置内存中的信息, 所以用到 swap 时, 主机磁盘灯就会开始闪个不停。 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:42","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何分出 512M 磁盘分区作为 swap ? 分区 创建 swap 格式 观察并载入 ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:43","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使用文件创建 swap (/home/feng/swap)下 dd if=/dev/zero of=/home/feng/swap bs=1M count=128 mkswap /tmp/feng/swap swapon /tmp/feng/swap swapon -s ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:44","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何取消掉 swap , 并设置自动启用? 设置 /etc/fstab swapoff /home/feng/swap ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:45","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么 4Bytes 的文件要占用4K的容量? 整个文件系统中包括 superblock , indoe , table与其他中介数据都会浪费磁盘容量. crontab 虽然只有 4Bytes, 但它会用整个 block (每个block为4K) ","date":"2021-03-06","objectID":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/:0:46","tags":["linux"],"title":"Linux第七章","uri":"/posts/linux%E7%AC%AC%E4%B8%83%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何回到之前的目录？ cd - ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:1","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何显示其正确的完整路径，而不是其链接的数据显示? pwd -P ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:2","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何创建一次创建 test1/test2/test3/test4 这样的目录，/test1~4均未创建? mkdir -p test1/test2/test3/test4 -p –parents: no error if existing, make parent directories as needed. ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:3","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何创建一个权限为rwx–x–x的目录test2? mkdir -m 711 test2 -m –mode=MODE: set file mode (as in chomd), not a=rwx - umask ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:4","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何在任何目录均可执行 /root 下面的命令? PATH = “${PATH}:/root” ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:5","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何复制 /var/log/wtmp文件到 ~/wtmp_2, 并且它的文件权限一模一样? cp -a -a, –archive ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:6","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何创建bashrc的实体链接(hard link)和符号链接(symbolic link)? ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:7","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何当 ~/.bashrc 比 /tmp/bashrc 新时则复制? cp -u ~/.bashrc /tmp/bashrc -u, –update copy only when the SOURCE file is newer than the destination file or when the destination file is missing ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:8","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若 bashrc_slink 是软链接文件，则复制的是什么？ 没有加任何选项时，cp复制的是原始文件，而非链接文件的属性 若加 -d 选项，则复制的是链接文件的属性 -d same as –no-dereference –preserve=links ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:9","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"能否使用feng的身份，完整的复制 /var/log/wtmp 文件到 /tmp 下面？ 因为feng身份并不能随意修改文件的拥有者与群组，因此虽然能够复制wtmp的相关权限与时间等属性，但是与拥有者、群组相关的，feng无法身份无法进行操作。 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:10","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何获取 /etc/sysconfig/network 中最后的文件名？ basename /etc/sysconfig/network ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:11","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何获取 /etc/sysconfig/network 的目录名？ dirname /etc/sysconfig/network ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:12","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使 cat /etc/issue 能够显示行号？ cat -n /etc/issue -n, –number number all output lines ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:13","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如果只想列出 /etc/man_db.conf 前20行， 该如何操作？ head - n 20 /etc/man_db.conf ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:14","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何只想列出 /etc/man_db.conf 最后20行，该如何操作？ tail -n 20 /etc/man_db.conf – ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:15","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"不知道 /etc/man_db.conf 有几行，但想列出120行后的数据，该如何操作？ tail -n +120 /etc/man_db.conf ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:16","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何想显示 /etc/man_db.conf的第11到第20行，该如何操作？ head -n 20 /etc/man_db.conf | tail -n 10 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:17","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何想显示 /etc/man_db.conf的第11到第20行，且行号存在， 该如何操作？ cat -n /etc/man_db.conf | head -n 20 | tail -n 10 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:18","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /usr/bin/passwd 的内容用ASCII方式展现？ od -t c /usr/bin/passwd ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:19","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何将 /etc/issue 这个文件内容以8进位列出储存值与ASCII的对照表? od -t oCc /etc/issue -t: -t, –format=Type Select output format or formats C: SIZE may also be C for sizeof(char) c: printable character or backslash escape o: octal, SIZE bytes per integer ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:20","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何立即找到password这几个字的ASCII对照， 该如何通过od来判断？ echo password | od -t oCc echo ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:21","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"当复制一个文件时，复制所有的属性，ctime这个属性可以复制吗？ 不可以， ctime 是记录这个文件最近的状态(status)被改变的时间 mtime: 文件的\"内容数据\"变更时，就会更新这个时间 ctime: 文件的状态更改时，就会更新这个时间 atime: 当文件被取用时，会更新这个时间 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:22","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若你的系统有个一般身份使用者 feng, 他的群组属于 feng, 他的主文件夹在 /home/feng, 你是root, 你想将你的~/.bashrc复制给他，可以怎么作？ cp ~/.bashrc ~feng/bashrc chown feng:feng ~feng/bashrc ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:23","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"我想在 /tmp 下面创建一个目录，这个目录名称为 chapter6_1, 并且这个目录拥有者为 feng, 群组为feng, 此外，任何人都可以进入该目录浏览文件，不过除了feng之外，其他人都不能修改这目录下的文件 整个目录权限应为 drwxr-xr-x mkdir /tmp/chapter6_1 chown -R feng:feng /tmp/chapter6_1 chmod -R 755 /tmp/chapter6_1 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:24","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看使用者在创建文件或目录时候的权限默认值? umask 和 umask -S -S Display readline key sequences bound to macros and the strings they output ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:25","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"umask的分数指的是什么？为什么它们会不一样？ 首先创建文件目录是不一样的: 创建\"文件\"默认没有可执行(x)权限， 只有rw这两个权限， 最大为666分， 默认权限为: -rw-rw-rw- 创建\"目录\"时, x权限是否可以进入此目录有关，因此默认所有权限均开放, 最大为777分， 默认权限为: drwxrwxrwx umask 的分数是指文件或目录需要减去的分数 如umask 为022, 则创建文件时的分数为 666-022 = 644, 即-rw-r–r– 则创建目录时的分数为 777-022 = 755, 即drwxr-xr-x 注意这样直接相减的结果不一定正确 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:26","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"若想自己创建的文件给群组的使用者共同编辑时，umask应如何设置？ 默认 umask: 022; 意味着 G没有w权限 将 umask 改成 002即可 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:27","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"假设你的umask为003, 请问该umask情况下，创建的文件与目录权限为？ umask 为 003, 所以拿掉的权限为——–wx 文件: (-rw-rw-rw-) - (——–wx) = -rw-rw-r– 目录: (drwxrwxrwx) - (d——-wx) = drwxrwxr– 注意不要用666 - 003 = 663, 即文件的权限为-rw-rw–wx, 原来没有x权限，这样一减就有了x权限， 这是不对的 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:28","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使一个文件不能删除、改名、设置链接也无法写入或新增数据? chattr +i ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:29","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何使一个文件只能增加数据，而不能删除也不能修改数据？ chattr +a ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:30","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看当前文件的隐藏属性？ lsattr ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:31","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"这里的s是什么权限？ 例如: /etc/shadow 只有root用户才可以修改 feng用户对于 /usr/bin/passwd 有x权限，表示feng可以执行passwd passwd的拥有者是root这个账号 因为 /usr/bin/passwd 中的 s 权限， feng在执行passwd的过程中，会暂时获得root权限 /etc/shadow 就可以被feng所执行的passwd修改 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:32","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"什么是SUID和SGID呢？ 当s标志在文件拥有者的x项目为SUID (Set UID) 当s在群组的x时则称为SGID (Set GID) ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:33","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"这里的t是对应的什么权限? t 是Sticky Bit, 仅对目录有效 /tmp 的权限是 drwxrwxrwt 任何人都可以在 /tmp 内新增、修改文件 但仅有该文件/目录创建者与root能够删除自己的目录或文件 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:34","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何设置SUID、SGID、SBIT这三个权限？ 只对文件设置: 4 为 SUID 2 为 SGID 只对目录设置: 1 为 SBIT ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:35","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么这里的S和T是大写的? s,t 是替代x权限的，而666中 user , group , others 都没有x权限，ST代表为空 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:36","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何给 test 文件加上SGID和SBIT权限? ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:37","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何查看 ~/.bashrc 的基本数据， 是属于ASCII或者是data，还是binary? file ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:38","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么history找不到？ 因为 history 是bash的内置命令， 不在 PATH 中 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:39","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 find 找出过去系统上面24小时内有更动过内容(mtime)的文件? find / -mtime 0 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:40","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用 find 找出3天前系统上面24小时内有更动过内容(mtime)的文件? find / -mtime 3 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:41","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何在 /etc 下面的文件，如果其日期比 /etc/passwd 新就列出? find /etc -newer /etc/passwd ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:42","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何在 /home 下找到属于feng的文件? find /home -user feng ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:43","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出系统中不属于任何人的文件? find / -nouser ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:44","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 /run 目录下，文件类型为 Socket 的文件名有哪些？ find /run -type s ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:45","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出文件中含有SGID 或 SUID 或 SBIT的属性? find / -perm /7000 7000 就是 —s–s–t 只要含有s或t的就列出， 使用/7000 同时含有三个权限，使用-7000 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:46","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 /usr/bin, /usr/sbin 下， 只要具有 SUID 或 SGID 的文件? find /usr/bin /usr/sbin -perm /6000 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:47","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何找出 /usr/bin, /usr/sbin 下， 只要具有 SUID 或 SGID 的文件, 并将找到的文件用ls -l列出来？ find /usr/bin /usr/sbin -perm /7000 -exec ls -l {} ; {} 代表由 find 找到的内容， -exec 是开始位置， ; 是结束位置 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:48","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"让一个使用者feng能够进行\"cp /dir1/file1 /dir2\"的指令时，则说明dir1, file1, dir2的最小所需权限为何? dir1: x fiel1: r dir2: w, x ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/:0:49","tags":["linux"],"title":"Linux第六章","uri":"/posts/linux%E7%AC%AC%E5%85%AD%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"箭头和方框所指的是什么意思？ 第一个箭头是指连接到此文件的数量 第二个箭头指的是文件的容量 方框所指的是文件最后修改的时间 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/:0:1","tags":["linux"],"title":"Linux第五章","uri":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"如何用ls命令列出全部文件最后修改的确切时间？ ls -al --full-time ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/:0:2","tags":["linux"],"title":"Linux第五章","uri":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"请问testgroup这个群组的成员与其他人(others)是否可以进入本目录？ test1 是本目录的拥有者，有[rwx]权限，可以对该目录进行任何操作 testgroup 这个群组[r-x], 即该组的成员可以进入本目录进行工作，但是不能在本目录下进行写入动作。 other [r–], 由于没有x的权限，因此others的使用者，并不能进入此目录 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/:0:3","tags":["linux"],"title":"Linux第五章","uri":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"系统有个帐号名称为vbird, 这个帐号并没有支持root群组，请问vbird对这个目录有何权限? vbird 对此目录只有r的权限，但没有x权限，表示vbird没法进入该目录，即便有r权限，也无法执行。 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/:0:4","tags":["linux"],"title":"Linux第五章","uri":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"普通用户dmtsai对这目录/文件的权限为何？ 其有r权限，可以查询到文件名，由于没有权限，会有一堆问号 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/:0:5","tags":["linux"],"title":"Linux第五章","uri":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"为什么很多时候没有/dir1 的r权限，也可以对里面的数据进行操作？ 因为， r 代表\"这个抽屉里有灯光\", 可以看到各个文件在哪里 但当有 x 权限的时候，就知道里面的数据在哪里，不需要有灯光，摸黑也可以找到 只是，没有 r 的话，使用 [tab] 时，无法补齐文件名 ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/:0:6","tags":["linux"],"title":"Linux第五章","uri":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"categories":["鸟哥的私房菜"],"content":"在FHS(filesystem hierarchy standard)规定下，各个文件夹都是放什么的?？1 /bin (User Binaries) 与 /sbin (System Binaries) /bin 与 /sbin目录下均是二进制执行文件(binary executables) /etc (Configuration Files) 所有程序的配置文件都在此 如passwd, shadow /dev (Device Files) 所有设备文件都在此 /proc (Process Information) 系统进程的信息都在此 如: /proc/uptime /var (Variable Files) 包含着一些会增加的文件 如: /var/log, /var/lib, /var/mail, /var/tmp /tmp (Temporary Files) 保存着系统和用户生成的临时文件 当系统重启，这里的文件会被删除 /usr (User Programs) 包含着 /usr/bin, /usr/sbin, /usr/lib, /usr/local /home (Home Directories) 所有用户的家目录在此 如/home/feng /boot (Boot Loader Files) 所有的boot文件在此 如 efi, grub文件 /lib (System Libraries) bin 和 /sbin所需要的依赖都在此 如: *.so /opt (Optional add-on Apps) 第三方软件放置的地方 如: google, netease /mnt (Mount Directory) 文件挂载的地方 /media (Removable Devices) 可移动媒体设备挂载的地方 /srv (Service Data) 服务数据放置的地方 Linux Directory Structure (File System Structure) Explained with Examples ↩︎ ","date":"2021-03-02","objectID":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/:0:7","tags":["linux"],"title":"Linux第五章","uri":"/posts/linux%E7%AC%AC%E4%BA%94%E7%AB%A0/"},{"categories":["java"],"content":"基础概念问答 请问Java语言是跨平台的吗？JVM是跨平台的吗？为什么？ Java语言是跨平台的，但JVM不是跨平台的，不同的平台有不同的JVM。 首先, 后缀为 \"*.java\" 的文件，经过javac命令编译后会生成public class定义类名称的.class文件(字节码文件)。然后, 不同平台的JVM会根据不同操作系统所提供的接口，实现.class文件中的功能。 例如: Hello.java所对应的程序 public class Hello { public static void main(String args[]){ System.out.println(\"Hello, World!\"); } } 编译后(Hello.class): 再经过linux中的jre-openjdk中的jvm执行hello.class使得java看起来具有跨平台的能力。 ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:1:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"环境变量 设置环境变量使QQ或者微信可以在任意平台下，通过命令行执行 linux平台下: export 文件路径:$PATH 使用永久化: echo \"export 文件路径:$PATH\" \u003e\u003e .zshrc ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:2:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"3.[入门题目] 独立编写Hello World程序，并在命令行下运行 hello.java public class Hello{ public static void main(String args[]){ System.out.println(\"Hello,world\"); } } public class hello{ public static void main(String args[]){ System.out.println(\"Hello,world\"); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:3:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"4.进制转换 将67转换为二进制，八进制，十六进制，将0b10100101,0345,0xef转换为十进制 67 将67除以2, 商33余数为1 将商33除以2, 商16余数为1 将商16除以2, 商8余数为0 将商8除以2, 商4余数为0 将商4除以2, 商2余数为0 将商2除以2, 商1余数为0 将商1除以2, 商0余数为1 则67转换为二进制为100 0011 所对应的十六进制为43 1 000 011 对应的八进制是103 0b10100101 二进制:0b 1010 0101 $12^{7} + 12^{5} + 12^{2} 12^{0} = 165$ 八进制:0345 $38^{2} + 48^{1} + 5*8^{0} = 229$ 十六进制:0xef $1416^{1} + 1516^{0} = 239$ ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:4:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"5.原码反码补码 字长为8, 已知原码 0110 1010 和1100 0110, 求他们的补码，已知补码0110 1010 和1100 0110求它们的原码 正数的补码是其本身 负数的补码是在原码的基础上，符号位不变，其余各位取反后+1 0110 1010，它是正数, 其补码为其本身 0110 1010 1100 0110, 它是负数, 其补码为1011 1010 正数补码是其本身 负数补码的原码是在其被码的基础上，符号位不变，其余各位取反后+1 0110 1010, 它是正数，其原码为其本身 0110 1010 1100 0110, 它是负数，其补码为1011 1010 ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:5:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"6. 基本数据类型 语句 byte b = 300; 编译能通过吗？ 如果不能，如何让它通过？转换之后其值是多少？ 不能， byte 为 8 位， 考虑符号位， 它能表示$2^7$个数, 即0 ~ 127, -128 ~ (-1) ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:6:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"7. 位运算 用位运算求一个整数的绝对值 public class number { public static void main(String args[]){ int num = -10; if (num\u003e=0){ System.out.println(\"其绝对值为:\" + num); }else{ int negativenum = ~num + 1; System.out.println(\"其绝对值为:\" + negativenum); } } } public class number { public static void main(String args[]){ int num = -10; int absolute = num \u003e 0? num : ~num + 1; System.out.println(absolute); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:7:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"8.逻辑运算 有三个int变量，a, b, c 假设三个变量中有两个变量的值相同，请问如何快速求出，那个和其他两个变量不同的第三个变量的值? public class diffnum{ public static void main(String args[]){ int a = 1; int b = 2; int c = 1; if (a == b){ System.out.println(\"c是不同的那个\"); }else if(a == c){ System.out.println(\"b是不同的那个\"); }else{ System.out.println(\"a是不同的那个\"); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:8:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"9.左移右移 public class TestOdd { public static void main(String args[]){ int num = 10; if (num %2 == 0){ System.out.println( num + \"是2的整数次幂\" ); } else{ System.out.println( num + \"不是2的整数次幂\" ); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:9:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"10.键盘录入 public class WeekDay{ public static void main(String args[]){ int day = 1; switch (day) { case 1: { System.out.println(\"星期一\"); break; } case 2: { System.out.println(\"星期二\"); break; } case 3: { System.out.println(\"星期三\"); break; } case 4: { System.out.println(\"星期四\"); break; } case 5: { System.out.println(\"星期五\"); break; } case 6: { System.out.println(\"星期六\"); break; } case 7: { System.out.println(\"星期日\"); break; } default: { System.out.println(\"没有这天\"); } } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:10:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"11.回文数 public class palnum{ public static void main(String args[]){ int num = 12322; int digit = num % 10; //个位数 int tens = (num % 100 - num % 10) / 10; //十位数 int thou = (num % 10000 - num % 1000) / 1000; //千分位 int ten_t = (num % 100000 - num % 10000) / 10000; //万分位 /* System.out.println(digit); System.out.println(tens); System.out.println(thou); System.out.println(ten_t); */ if (digit == ten_t \u0026\u0026 tens == thou) System.out.println( num + \"是回文数\" ); else System.out.println( num + \"不是回文数\"); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:11:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"12.switch分支 public class score{ public static void main(String args[]) { int score = 100; // 获取十位数 int tens = (score % 100 - score % 10) / 10; switch (tens){ case 1,2,3,4,5: { System.out.println(\"不及格\"); break; } case 6: { System.out.println(\"及格\"); break; } case 7: { System.out.println(\"中\"); break; } case 8:{ System.out.println(\"良\"); } case 9, 0:{ System.out.println(\"优\"); } } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:12:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"13.水仙花数 public class dafnum{ public static void main(String args[]){ for (int num = 100; num \u003c= 999; num ++){ int digit = num % 10; //个位数 int tens = (num % 100 - digit) / 10; //十位数 int hundreds = (num - (num % 100)) / 100; //百位数 /* System.out.println(digit); System.out.println(tens); System.out.println(hundreds); */ if (digit * digit * digit + tens * tens * tens + hundreds * hundreds * hundreds == num){ System.out.println( num + \"是水仙花数\" ); } } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:13:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"14.输出素数 import java.lang.Math; public class prime{ public static void main(String args[]){ boolean flag = false; for (int num = 101; num \u003c= 200; num++){ flag = false; for (int a = 2; a \u003c= Math.sqrt(num); a++){ if ( num % a == 0 ){ flag = true; break;} } if ( flag == false ){System.out.println(num + \"是素数\");} } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:14:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"15.简单排序 public class sort{ public static void main(String args[]){ int a = 1; int b = 2; int c = 3; if ((a \u003e b) \u0026\u0026 (a \u003e c)) { if (b \u003e c){ System.out.println(\"a \u003e b \u003e c\"); } else { System.out.println(\"a \u003e c \u003e b\"); } }else if ((a \u003e b) \u0026\u0026 (a \u003c c)){ System.out.println(\"c \u003e a \u003e b\"); }else if ((a \u003c b) \u0026\u0026 (a \u003c c)){ if (b \u003e c){ System.out.println(\"b \u003e c \u003e a\"); } else { System.out.println(\"c \u003e b \u003e a\"); } }else if ((a \u003c b) \u0026\u0026 (c \u003e a)){ if (b \u003e c){ System.out.println(\"b \u003e c \u003e a\"); } else { System.out.println(\"c \u003e b \u003e a\"); } } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:15:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"16.打印三角形图案 public class intrangle{ public static void main(String args[]){ int num = (7+1)/2 -1; for(int i = 1; i \u003c= 7; i++){ if (i%2 == 0){ System.out.println(\"\"); continue; }else{ for(int j = num; j \u003e 0; j--) System.out.print(\" \"); num-=1; } for(int k = 1; k \u003c= i; k++){ System.out.print(\"*\"); } System.out.println(\"\"); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:16:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"17.打印9*9乘法表 public class NtimesN{ public static void main(String args[]){ for(int i=1;i\u003c=9;i++){ for(int j=1;j\u003c=i;j++){ System.out.print( i + \"*\" + j + \"=\" + ( i * j ) + \"\\t\" ); } System.out.println(); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:17:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"18. 求完数 public class factor{ public static void main(String args[]){ for (int num =1; num\u003c100; num++){ int count = 0; for(int i = 1; i \u003c num; i++) { if(num % i == 0 ){ count += i; } } if (count == num){ System.out.println(num + \"是完数\"); } } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:18:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"19. 求不重复数字 public class NotRepeat{ public static void main(String args[]){ for (int i = 1; i \u003c= 4; i++){ for (int j = 1; j \u003c=4; j++){ for (int k = 1; k \u003c=4; k++){ if (i == j | i == k | j == k) continue; System.out.println(i*100 + j*10 + k); } } } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:19:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"20. 求日期 public class daysum{ public static void main(String args[]){ int year = 2012; int month = 12; int day = 5; int day_count = 0; int Jan = 31; int Feb = 28; int Mar = 31; int Apr = 30; int May = 31; int Jun = 30; int Jul = 31; int Aug = 31; int Sept = 30; int Oct = 31; int Nov = 30; if ((year % 4 == 0 \u0026\u0026 year % 100 != 0) || (year % 400 == 0)){ System.out.println(\"该年是闰年\"); Feb = 29; } switch (month){ case 1: { day_count = day; break; } case 2: { day_count = Jan + day; break; } case 3: { day_count = Jan + Feb + day; break; } case 4: { day_count = Jan + Feb + Mar + day; break; } case 5: { day_count = Jan + Feb + Mar + Apr + day; break; } case 6: { day_count = Jan + Feb + Mar + Apr + May + day; break; } case 7: { day_count = Jan + Feb + Mar + Apr + May + Jun + day; break; } case 8: { day_count = Jan + Feb + Mar + Apr + May + Jun + Jul + day; break; } case 9: { day_count = Jan + Feb + Mar + Apr + May + Jun + Jul + Aug + day; break; } case 10: { day_count = Jan + Feb + Mar + Apr + May + Jun + Jul + Aug + Sept + day; break; } case 11: { day_count = Jan + Feb + Mar + Apr + May + Jun + Jul + Aug + Sept + Oct + day; break; } case 12: { day_count = Jan + Feb + Mar + Apr + May + Jun + Jul + Aug + Sept + Oct + Nov + day; break; } } System.out.println(day_count); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:20:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"21. 根据条件求数字 import java.lang.Math; public class findnum{ public static void main(String args[]){ for(int num = 0 ; num \u003c= 100000 ; num ++){ if (Math.round(Math.sqrt(Math.sqrt(num + 100)+ 268)) == num) System.out.println(num); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:21:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"22. 根据输入求输出 public class rev{ public static void main(String args[]){ int num = 12345; digts(num); } public static void digts(int num){ int first = num % 10; int second = (num % 100 - first) / 10; int third = (num % 1000 - second) / 100; int four = (num % 10000 - third) / 1000; int five = (num % 100000 - four) / 10000; System.out.println(\"原来的数:\" + num); if(num % 10 == num){ System.out.println(\"此数为一位数\"); }else if(num % 100 == num){ System.out.println(\"此数为二位数\"); }else if(num % 1000 == num){ System.out.println(\"此数为三位数\"); }else if(num % 10000 == num){ System.out.println(\"此数为四位数\"); }else {System.out.println(\"此数五位数\");} System.out.println(\"转换后的数:\" + first + second + third + third + five ); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:22:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"23. 求前20项之和 public class sum{ public static void main(String args[]){ number(20); } public static void number(int num){ double a = 2; double b = 1; double c = a; double member; double denominator; double sum = 0; for(int i = 1; i \u003c= num; i++){ member = a; denominator = b; sum += a/b; c = a + b; b = a; a = c; } System.out.println(sum); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:23:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"24. 求阶乘 public class factorial{ public static void main(String args[]){ int count = 0; for(int i = 1; i \u003c= 20; i++){ count = count + sum(i); } System.out.println(count); } public static int sum(int num){ if (num == 1){ return 1; } return num * sum(num - 1); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:24:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"25.回文数 public class palnum{ public static void main(String args[]){ int num = 12322; int digit = num % 10; //个位数 int tens = (num % 100 - num % 10) / 10; //十位数 int thou = (num % 10000 - num % 1000) / 1000; //千分位 int ten_t = (num % 100000 - num % 10000) / 10000; //万分位 /* System.out.println(digit); System.out.println(tens); System.out.println(thou); System.out.println(ten_t); */ if (digit == ten_t \u0026\u0026 tens == thou) System.out.println( num + \"是回文数\" ); else System.out.println( num + \"不是回文数\"); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:25:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"26.求星期几 public class week{ public static void main(String args[]){ char first_word = 'T'; char second_word = 'u'; weekday (first_word, second_word); /* * Monday * Tuesday * Wednesday * Thursday * Friday * Saturday * Sunday */ } public static void weekday(char firstword, char secondword){ switch (firstword){ case 'M' :{ System.out.println(\"星期一\"); break; } case 'T' : { switch(secondword){ case 'u' :{ System.out.println(\"星期二\"); break; } case 'h' :{ System.out.println(\"星期四\"); break; } } break; } case 'W' : { System.out.println(\"星期四\"); break; } case 'F' : { System.out.println(\"星期五\"); break; } case 'S' : { switch(secondword){ case 'a' :{ System.out.println(\"星期二\"); break; } case 'u' :{ System.out.println(\"星期四\"); break; } } break; } } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:26:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"27.求素数 import java.lang.Math; public class prime{ public static void main(String args[]){ boolean flag = false; for (int num = 1; num \u003c= 100; num++){ flag = false; for (int a = 2; a \u003c= Math.sqrt(num); a++){ if ( num % a == 0 ){ flag = true; break;} } if ( flag == false ){System.out.println(num + \"是素数\");} } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:27:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"28.排序算法 public class sort{ public static void main(String args[]){ int data[] = new int[]{1, 5, 3, 2, 6, 4, 7, 8, 9, 10}; traverse(data); int [] sort_data = sortnum(data); traverse(sort_data); } public static int[] sortnum(int[] data) { int min = 0; int temp; for(int x = 0;x \u003c data.length; x++){ for(int y = x + 1; y \u003c data.length; y++){ if(data[y] \u003c data[min]) { min = y; } } temp = data[x]; data[x] = data[min]; data[min] = temp; min = x+1; } return data; } public static void traverse(int[] data){ for(int x = 0; x \u003c data.length; x++){ System.out.print(data[x] + \" \"); } System.out.println(); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:28:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"29.杨辉三角 public class triangle{ public static void main(String args[]){ int a[] = {0, 1, 0}; for(int i = 1; i \u003c 10; i++){ for(int y = 10 - i; y \u003e 1; y--){ System.out.print(\" \"); } traverse(a); a = tri(a); } } public static int[] tri(int[] data){ // int data[] = new int[] {0, 1, 0}; int dataNew[] = new int[data.length + 1]; dataNew[0] = 0; dataNew[dataNew.length - 1] = 0; for(int x = 0, y = 1; y \u003c data.length; x++, y++){ dataNew[y] = (data[x] + data[y]); } return dataNew; } public static void traverse(int[] data){ for(int x = 1; x \u003c data.length - 1; x++) { System.out.print(data[x] + \" \"); } System.out.println(); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:29:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"30.被9整除 public class number3{ public static void main(String args[]){ int num = 81; if (num % 9 == 0){ int count = 1; if (num/9 == 9) { count += 1; } System.out.println(num + \"能被\" + count + \"个\" + \"9除净\"); }else {System.out.println(num + \"不能被9整除\");} } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:30:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"31.三个数排序 public class ArrayDemo{ public static void main(String args[]){ int temp; int data[] = new int[]{1, 2, 3, 4}; int i = 0; int j = data.length - 1; while (i \u003c j){ temp = data[i]; data[i] = data[j]; data[j] = temp; i+=1; j-=1; } for(int x = 0; x \u003c data.length; x++){ System.out.print(data[x] + \"、\"); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:31:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"32.加密 public class encry{ public static void main(String args[]){ int num = 1234; encryNum(num); } public static void encryNum(int num){ int first = num % 10; int second = (num % 100 - first) / 10; int third = (num % 1000 - second) / 100; int four = (num % 10000) / 1000; System.out.println(first + \" \" + second + \" \" + third + \" \" + four); first = (first + 5)%10; second = (second + 5)%10; third = (third + 5)%10; four = (four + 5)%10; System.out.println(first + \" \" + second + \" \" + third + \" \" + four); int temp; temp = first; first = four; four = temp; temp = second; second = third; third = temp; System.out.println(first * 1000 + second * 100 + third * 10 + four); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:32:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"33.数组排序 public class reverse{ public static void main(String args[]){ int Array_origial[] = new int []{1, 2, 3, 5}; Array_origial = reverseArray(Array_origial); traverse(Array_origial); } public static int[] reverseArray(int Array_origial[]){ int temp [] = new int [Array_origial.length]; int foot = temp.length - 1; for(int x = 0; x \u003c temp.length; x++){ temp[x] = Array_origial[foot]; foot --; } return temp; } public static void traverse(int temp[]){ for(int x = 0; x \u003c temp.length; x++) { System.out.print(temp[x] + \" \"); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:33:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"34.左移右移 public class selectnum{ public static void main(String args[]){ int num = 1234567; System.out.println(select(num)); } public static int select(int num){ int fourToseven = (((num % 10000000) - num % 1000) / 1000); return fourToseven; } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:34:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"35.求奇数的个数 ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:35:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"36.打印星号 public class asterisk{ public static void main(String args[]){ int data[] = {1, 2, 3, 4, 5, 6, 7}; for(int y = 0; y \u003c data.length; y++){ printaster(data[y]); } } public static void printaster(int num){ for(int x = 1; x \u003c= num; x++){ System.out.print(\"*\"); } System.out.println(\"\"); } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:36:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"37.最大最小交换 public class arrayChange{ public static void main(String args[]){ int Array [] = new int[] {11, 1, 0, 6, 5}; int positionMax = findMax(Array); int positionMin = findMin(Array); int changeMax [] = changeMax(Array, positionMax); System.out.println(\"替换最大的元素后:\"); traverse(changeMax); int changeMin [] = changeMin(changeMax, positionMin); System.out.println(); System.out.println(\"替换最小的元素后:\"); traverse(changeMin); } public static int findMax(int temp[]){ int max = 0; for(int x = 1; x \u003c temp.length; x++) { if(temp[x] \u003e temp[max]){max = x;}; } return max; } public static int findMin(int temp[]){ int min = 0; for(int x = 1; x \u003c temp.length; x++) { if(temp[x] \u003c temp[min]){min = x;}; } return min; } public static int[] changeMax(int temp[], int position){ int tempNum = temp[0]; temp[0] = temp[position]; temp[position] = tempNum; return temp; } public static int[] changeMin(int temp[], int position){ int tempNum = temp[temp.length - 1]; temp[temp.length - 1] = temp[position]; temp[position] = tempNum; return temp; } public static void traverse(int temp[]){ for(int x = 0 ;x \u003c temp.length; x++) { System.out.print(temp[x] + \" \"); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:37:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"38.输入数字求和 public class numsum{ public static void main(String args[]){ System.out.println(num(2,5)); } public static int num (int a, int b){ if (b == 1) return a; if (b == 2) return a*10 + a + num(a, 1) ; else{return num(a, b-1)*10 + a + num(a, b - 2);} } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:38:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"39.求最大公约数及最小公倍数 public class elimination{ public static void main(String args[]){ int m = 12; int n = 30; System.out.println(eli(m, n) + \"是最大公约数\"); System.out.println(((m * n) / eli(m, n)) + \"是最小公倍数\"); } public static int eli(int m, int n){ int c = m % n; if (c == 0){ return n; }else {return eli(n, c);} } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:39:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"40.分数累加 public class acc{ public static void main(String args[]){ int num1=2; int num2=3; System.out.println(sum(num1)); System.out.println(sum(num2)); } public static double sum(int num){ double sum = 0; if (num % 2 == 0){ for(double i = 2.0; i \u003c= num; i+=2) { sum += (1)/i; } }else{ for(double i = 1.0; i \u003c= num; i+=2){ sum += (1)/i; } } return sum; } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:40:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"41.自由落体 public class rec{ public static void main(String args[]){ double meter = 100; int num = 10; for(int x = 1; x \u003c= num-1; x++) { meter += high(x) * 2; } System.out.println(\"第10次落地时共经过了\" + meter + \"米\"); System.out.println(\"第10次反弹有\" + high(10) + \"米\"); } public static double high(int num) { if (num == 1) return 50; else {return (high( num - 1) / 2);} } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:41:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"42.不死神兔子 public class rabbit{ public static void main(String args[]){ int sum = 0; for(int day = 1; day \u003c= 31; day++){ sum += count(day); } System.out.println(sum); } public static int count(int day) { if (day == 1){ return 1; }else if (day == 2){ return 1; }else{return count(day - 1) + count(day - 2);} } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:42:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"43.猴子吃桃子问题 public class monkey{ public static void main(String args[]){ System.out.println(peach(10)); } public static int peach(int day){ if (day == 1){return 1;} else { return peach( day - 1 ) * 2 + 1; } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:43:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"44.球赛 ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:44:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"45.递归求阶乘 public class renum{ public static void main(String args[]){ System.out.println(rec(5)); } public static int rec(int num) { if(num == 1) { return 1; }else{return rec(num - 1) * num;} } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:45:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"46.求岁数 public class age{ public static void main(String args[]){ System.out.println(whatAge(5)); } public static int whatAge(int people){ if(people == 1){ return 10; } else{ return whatAge(people - 1) + 2; } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:46:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"47.插入数字 ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:47:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"48.移动位置 public class move{ public static void main(String args[]){ int data[] = {1, 2, 3, 4, 5, 6, 7}; movePosition(data); } public static void movePosition(int data[]){ int middle; if(data.length % 2 == 0){ middle = data.length / 2; int tmpData[] = new int[middle]; for(int i = 0, x = middle; i \u003c middle; i++, x++) { tmpData[i] = data[i]; data[i] = data[x]; data[x] = tmpData[i]; } } else { middle = (data.length - 1) / 2; int tmpData[] = new int[middle]; for(int i = 0, x = middle+1; i \u003c middle; i++, x++) { tmpData[i] = data[i]; data[i] = data[x]; data[x] = tmpData[i]; } }; travel(data); } public static void travel(int data[]){ for(int j = 0; j \u003c data.length; j++){ System.out.print(data[j] + \" \"); } } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:48:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"49.报数 ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:49:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["java"],"content":"50.猴子分桃 public class monkey{ public static void main(String args[]){ boolean flag = false; for(int i = 1; i\u003c=5000; i++) { if(peach(i, flag) == true){break;} } } public static boolean peach(int i, boolean flag){ if((1.25 * i + 1) % 5 == 1 ){ //第一只猴子分之前 if((1.25 * (1.25 * i + 1) + 1) % 5 == 1){ //第二只猴子分之前 if((1.25 * (1.25 * (1.25 * i + 1) + 1) + 1) % 5 == 1){ //第三只猴子分之前 if((1.25 * (1.25 * (1.25 * (1.25 * i + 1) + 1) + 1) + 1) % 5 == 1){ //第四只猴子分之前 if((1.25 * (1.25 * (1.25 * (1.25 * (1.25 * i + 1) + 1) + 1) + 1)+1) % 5 == 1){ //第五只猴子分之前 System.out.println(i); flag = true; } else {return flag;}; } else {return flag;}; } else {return flag;}; } else {return flag;}; } return flag; } } ","date":"2021-02-26","objectID":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/:50:0","tags":["java"],"title":"Java基础练习题","uri":"/posts/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"categories":["鸟哥的私房菜"],"content":"主机规划与磁盘分区 ","date":"2021-02-25","objectID":"/posts/linux_5/:0:0","tags":["linux"],"title":"Linux_5","uri":"/posts/linux_5/"},{"categories":["鸟哥的私房菜"],"content":"Linux与硬件的搭配 ","date":"2021-02-25","objectID":"/posts/linux_5/:1:0","tags":["linux"],"title":"Linux_5","uri":"/posts/linux_5/"},{"categories":["鸟哥的私房菜"],"content":"各硬件设备在Linux中的文件名 虚拟机中的磁盘名称是什么? 在虚拟机的环境下，为了加速会使用/dev/vd[a-p]这种设备文件名。 SATA接口的磁盘名称是什么? 由于SATA/USB/SAS等硬盘接口都是SCSI模块来驱动，因此这些接口的磁盘设备文件都是/dev/sd[a-p]的格式。 ","date":"2021-02-25","objectID":"/posts/linux_5/:1:1","tags":["linux"],"title":"Linux_5","uri":"/posts/linux_5/"},{"categories":["鸟哥的私房菜"],"content":"磁盘分区 ","date":"2021-02-25","objectID":"/posts/linux_5/:2:0","tags":["linux"],"title":"Linux_5","uri":"/posts/linux_5/"},{"categories":["鸟哥的私房菜"],"content":"MSDOS(MBR)与GTP磁盘分区表 MSDOS的结构是什么样的？ MBR (Master Boot Record, 主要开机记录区) 这个区在磁盘的第一个扇区，其放转置着开机管理程序记录区与分区表 通常为512 Bytes 主要开机记录区(Master Boot Record, MBR): 可以安装开机管理程序的地方。 446 Bytes 分区表(partition table): 记录整颗硬盘分区的状态 64 Bytes 为什么要分区？ 数据安全 重装系统时，各个分区之间不会相互影响 性能考虑 P1: /dev/sda1 P2: /dev/sda2 P3: /dev/sda3 P4: /dev/sda4 分区表只记录四组数据，则分出多于四个分区是如何实现的？ P1 为主要分区(Primary) p2 为延伸分区(Extended) p2分出来的L1, L2, L3, L4, L5为逻辑分区(logical partition) 设备文件名分别为: P1: /dev/sda1 P2: /dev/sda2 L1: /dev/sda5 L2: /dev/sda6 L3: /dev/sda7 L4: /dev/sda8 L5: /dev/sda9 /dev/sda3与/dev/sda4是保留给Primary或Extended用的，逻辑分区的设备名称号码由5号开始 ? 当D与E盘均属于延伸分区内的逻辑分区，将两个分区删除，然后再重新创建一个新的分区，能够在不影响其他分区的情况下，将两个分区的容量整合成为一个。 当D与E分属于主分区与逻辑分区时，两者不能够整合在一起，除非将延伸分区破坏掉后再重新分区。但如此一来会影响到所有的逻辑分区。 ? 因为P(Primary) + E(Extended)最多只能有四个，若有4个P了，即便还有剩余容量，因为无法再继续分区，所以容量就被浪费掉了 想要将所有的四笔记录都花光，则P+P+P+E比较好 因为P(Primary) + E(extended)最多为4个 P+P+P+E的环境 P+E的环境 为什么会出现GPT? 操作系统无法抓取到2.2T以上的磁盘容量 MBR仅有一个区块，若被破坏后，经常无法或很难援救 MBR内的存放开机管理程序的区块仅446Bytes, 无法容纳较多的程序码 GPT的结构是什么样的？ GPT: GUID partition table LBA0 (MBR相容区块) 446 Bytes 第一阶段开机管理程序 特殊标志分区,用来表示此磁盘为GPT格式 LBA1 (GPT表头纪录) 分区表本身的位置与大小 备份用的GPT分区(最后34个LBA区块)放置位置 分区表的检验机制码(CRC32) LBA2-33 (实际纪录分区信息处) 每个LBA可以记录4笔分区记录， 即32*4笔记录 每个LBA有512 Bytes, 则每笔记录用于128 Bytes的空间 GPT在每笔记录中分别提供了 64 bits 来记载开始/结束的磁区号码 对于GPT分区表对于单一分区来说，它的最大容量为:$2^{64} *512bytes = 2^{63} * 1Kbytes = 2^{33}*TB = 8 ZB$ ","date":"2021-02-25","objectID":"/posts/linux_5/:2:1","tags":["linux"],"title":"Linux_5","uri":"/posts/linux_5/"},{"categories":["鸟哥的私房菜"],"content":"开机流程中的BIOS与开机检测程序 ","date":"2021-02-25","objectID":"/posts/linux_5/:2:2","tags":["linux"],"title":"Linux_5","uri":"/posts/linux_5/"},{"categories":["鸟哥的私房菜"],"content":"主机的服务规划与硬件的关系 ","date":"2021-02-25","objectID":"/posts/linux_5/:2:3","tags":["linux"],"title":"Linux_5","uri":"/posts/linux_5/"},{"categories":["鸟哥的私房菜"],"content":"假设你的主机为虚拟机，里面仅有一颗VirtIO接口的磁盘，请问他在Linux操作系统里面的设备文件名为何？ 虚拟机使用的是/dev/vd[a-p]来命名的 所以其名为/dev/vda ","date":"2021-02-22","objectID":"/posts/linux_4/:0:1","tags":["linux"],"title":"Linux_4","uri":"/posts/linux_4/"},{"categories":["鸟哥的私房菜"],"content":"如果你的PC上面有两个SATA磁盘以及一个USB磁盘，而主板上面有六个SATA的插槽，这两个磁盘分别安插在主板上的SATA1, SATA5插槽上，请问这三个磁盘Linux中设备文件名为何？ USB闪存盘与SATA相同，均用/dev/sd[a-p]来命名的 且采用侦测到的顺序来决定设备文件名，并非与实际插槽代号有关 SATA1: /dev/sda SATA5: /dev/sdb USB磁盘(开机完成后才被系统捉到): /dev/sdc ","date":"2021-02-22","objectID":"/posts/linux_4/:0:2","tags":["linux"],"title":"Linux_4","uri":"/posts/linux_4/"},{"categories":["鸟哥的私房菜"],"content":"什么是MSDOS（MBR）分区 ","date":"2021-02-22","objectID":"/posts/linux_4/:0:3","tags":["linux"],"title":"Linux_4","uri":"/posts/linux_4/"},{"categories":["鸟哥的私房菜"],"content":"Linux是什么? ","date":"2021-02-20","objectID":"/posts/linux_3/:0:0","tags":["linux"],"title":"Linux_3","uri":"/posts/linux_3/"},{"categories":["鸟哥的私房菜"],"content":"关于GNU计划、自由软件与开源代码 ","date":"2021-02-20","objectID":"/posts/linux_3/:1:0","tags":["linux"],"title":"Linux_3","uri":"/posts/linux_3/"},{"categories":["鸟哥的私房菜"],"content":"什么是Free Software? Free Software 即自由软件 自由软件关乎的是自由而非价格 它允许任何人使用、复制和/或再分发 ","date":"2021-02-20","objectID":"/posts/linux_3/:1:1","tags":["linux"],"title":"Linux_3","uri":"/posts/linux_3/"},{"categories":["鸟哥的私房菜"],"content":"开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL都有什么区别？1 GPL: - 只要在一个软件中使用GPL协议的产品，则该软件产品必须也采用GPL协议，即开源和免费 BSD: - “为所欲为\"的BSD协议需要满足三个条件 MIT: MIT和BSD一样宽范的许可协议，作者只想保留版权，而无任何其他限制，必须在发行版里包含原许可协议的声明。 LGPL: 主要是为类库使用设计的开源协议。LGPL允许商业软件通过类库引用方式使用LGPL类库而不需要开源商业软件的代码 开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别 ↩︎ ","date":"2021-02-20","objectID":"/posts/linux_3/:1:2","tags":["linux"],"title":"Linux_3","uri":"/posts/linux_3/"},{"categories":["鸟哥的私房菜"],"content":"个人电脑架构与相关设备元件 ","date":"2021-02-16","objectID":"/posts/linux_2/:0:0","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构 ","date":"2021-02-16","objectID":"/posts/linux_2/:1:0","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-什么是南北桥?它们是干什么的？1 北桥: 负责链接速度较快的元件(在目前的主流架构中，大多将北桥内存控制器整合到CPU封装中了) CPU 内存 显卡接口等 南桥: 负责链接速度较慢的元件 硬盘 USB 网卡 ","date":"2021-02-16","objectID":"/posts/linux_2/:1:1","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-为什么现在的主流架构中，要将北桥内存控制器整合到CPU中？ 首先, 北桥是负责链接速度较快的元件(内存), 然后，若CPU需要与内存交流，就需要经过北桥，这样就会瓜分掉北桥的总可用带宽，影响其他元件的沟通。最后，若将内存控制器整合到CPU后，CPU与内存之间的沟通是直接交流，速度较快，而且消耗更多的带宽。 ","date":"2021-02-16","objectID":"/posts/linux_2/:1:2","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-什么是CPU的频率？2 即CPU每秒钟可以进行的工作次数 速度单位使用的是十进制 即$3.5 \\times 10 ^ 9$MHz ","date":"2021-02-16","objectID":"/posts/linux_2/:1:3","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-什么是CPU的外频与倍频？什么会有外频和倍频出现？ 外频: CPU与外部元件进行数据传输时的速度 倍频: CPU内部用来加速工作性能的一个倍数 首先，所有的设备都得通过北桥来链接，因此每个设备的工作频率都应该相同。然后，CPU的运算速度应比其他设备要快，所以厂商会在 CPU内部进行加速。 ","date":"2021-02-16","objectID":"/posts/linux_2/:1:4","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-如何查看计算机的外频与倍频？ 即总线速度为外频 核心速度 = 倍频 x 总线速度 ","date":"2021-02-16","objectID":"/posts/linux_2/:1:5","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-超频指的是超什么频？ 首先，超频是指超外频, 在以前所有的数据都需要通过北桥，但是北桥不可能比CPU快，成为系统性能的瓶颈。其次，在新的CPU设计中，将北桥的功能整合到CPU内，使得CPU直接与内存、显卡进行沟通，CPU的频率设计就不需要考虑外频了，只需要考虑整体的频率。最后，现在的CPU-z中，外频变成100MHZ而倍频可以到30以上。 ","date":"2021-02-16","objectID":"/posts/linux_2/:1:6","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-前端总线速度是什么？ 前端总线速度(Front Side Bus) CPU中的所有数据都是由内存提供的 查看内存信息 sudo dmidecode -t memory MT/s 与 MHz有什么关系?3 等价 CPU可能从内存中取得的最快带宽是2400 MHz x 64 bit = 2400 MHz 8 Bytes = 19.2GB/s ","date":"2021-02-16","objectID":"/posts/linux_2/:1:7","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-什么是CPU字组大小?4 CPU每次能够处理的数据量称为字组大小(word size) 32位的CPU最多支持最大到4GBytes 如何计算？ 首先, CPU计算的时候不能直接访问硬盘的数据，但是可以直接访问内存里的数据。其次，32位的CPU是指它能寻找到$2^32$个地址，不是存储空间有多大。最后，若一个地址单元为8位，则32位的CPU最多为4GBytes. $2^{32}$个地址 = $2^{32} \\times 8 / 8$ Byte = $2^{22}$ KByte = $2^{12}$ MByte = $2^2$GB = $4$GB ","date":"2021-02-16","objectID":"/posts/linux_2/:1:8","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"Intel芯片架构-什么是CPU的超线程? 超线程 Hyper-Threading, HT 线程是操作系统进行运算调动的最小单位, 它被包含在进程之中，是进程中实际运作单位，一个进程中可又并发多个线程。 超线程技术是把一个物理处理器在软件层变成两个逻辑处理器，可以使处理器在某一时刻，同步并行处理更多指令数据。 超线程是一种将CPU内部暂时闲置处理资源充分\"调动\"起来的技术，在多加入一个逻辑处理单元 ，这让CPU可以同时执行多个程序而共享一颗CPU内的资源，当两个线程都同时需要某一个资源时，其中一个要暂时停止，并让出资源，直到这些资源闲置后才能继续。 ","date":"2021-02-16","objectID":"/posts/linux_2/:1:9","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"内存 ","date":"2021-02-16","objectID":"/posts/linux_2/:2:0","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"内存-什么是动态随机存取内存？ 动态随机存取内存: Dynamic Random Access Memory, DRAM 只有在通电时才能记录与使用，断电后数据就消失，因此也称这种RAM为挥发性内存 ","date":"2021-02-16","objectID":"/posts/linux_2/:2:1","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"内存-什么是SDRAM与DDR SDRAM? DDR 是所谓的双倍数据传送速度(Double Data Rate) ","date":"2021-02-16","objectID":"/posts/linux_2/:2:2","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"内存-什么是多通道设计? 传统的总线宽度一般大约为64位，为了要加大这个宽度，因此芯片组厂商就将两个内存汇总在一起，如果一支内存可达64位，两支内存可达到128位了 两支内存最好容量大小，型号也最好相同 ","date":"2021-02-16","objectID":"/posts/linux_2/:2:3","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"内存-什么是DRAM与SRAM? 动态随机存取内存: Dynamic Random Access Memory, DRAM 静态随机存取内存: Static Random Access Memory, SRAM L2 cache即采用的是SRAM设计，L2内存速度必须要与CPU频率相同，在设计上使用的电晶体较多，且价格较高，且L2内存速度必须要与CPU频率相同，在设计上使用的电晶体较多，价格较高，且不易做成大容量 ","date":"2021-02-16","objectID":"/posts/linux_2/:2:4","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"内存-什么是ROM? 只读存储器: Read Only Memory, ROM ROM是一种非挥发性的内存 BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面的一个内存芯片中，这个内存芯片在没有通电时也能够将数据记录下来。 ","date":"2021-02-16","objectID":"/posts/linux_2/:2:5","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"显卡 ","date":"2021-02-16","objectID":"/posts/linux_2/:3:0","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"显卡-假设你的桌面使用1024x768分辨率，且使用全彩色(每个像素占用3Bytes的容量), 请问你的显卡至少需要多少内存才能使用这样的彩度？ 1024 x 768 x 3 Bytes = 2.359296 MBytes ","date":"2021-02-16","objectID":"/posts/linux_2/:3:1","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"硬盘与存储设备 ","date":"2021-02-16","objectID":"/posts/linux_2/:4:0","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"对于机械硬盘，它的扇区，磁道，柱面都是什么？5 磁道(track): 即不同大小的同心圆 扇区(sector): 磁盘存储数据最小的数据块 - 因为同心圆外圈的圆比较大，占用的面积比内圈多，为了善用这些空间，会将外围的圆分配更多的扇区 柱面(cylinder): 所有盘片上面的同一个磁道组合成所谓的柱面 ","date":"2021-02-16","objectID":"/posts/linux_2/:4:1","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"对于机械硬盘-如何计算它的容量？ 容量 = 磁道 x 扇区 x 柱面 x Units ","date":"2021-02-16","objectID":"/posts/linux_2/:4:2","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"主板 ","date":"2021-02-16","objectID":"/posts/linux_2/:5:0","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"主板-什么是设备的I/O位址与IRQ中断信道? I/O 位址相当于各设备的门牌号码 IRQ 相当于各个门牌连接到邮件中心(CPU)的专门路径 linux下查看IRQ中断信息: cat /proc/interrupts ","date":"2021-02-16","objectID":"/posts/linux_2/:5:1","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"主板-COMS与BIOS是什么?有什么不同？ COMS: 主要是记录主板上面的重要参数 - 系统时间 - CPU电压与频率 - 各项设备的I/O位址与IRQ BIOS: 为写入到主板上某一块flash或EEPROM的程序，可以在开机的时候执行，以载入CMOS当中的参数，并尝试调用储存设备中的开机程序。 ","date":"2021-02-16","objectID":"/posts/linux_2/:5:2","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"操作系统 ","date":"2021-02-16","objectID":"/posts/linux_2/:6:0","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"操作系统-什么是操作系统核心(Kernel)？ 操作系统 Operating System 一组程序: 管理电脑的所有活动以及驱动系统中的所有硬件的程序 CPU开始判断逻辑与运算数值 让内存可以开始载入/读出数据与程序码 让硬盘可以开始被存取 让网卡可以开始传输数据 让所有周边可以开始运行 南北桥架构的演变 ↩︎ CPU-Z的参数怎么看 CPU-Z检测CPU型号全面解析 ↩︎ MT/s=MHz? ↩︎ 32位CPU最多支持4G内存是怎么算出来的？（解惑篇） ↩︎ Vol 072 你的硬盘是如何储存数据的？ ↩︎ ","date":"2021-02-16","objectID":"/posts/linux_2/:6:1","tags":["linux"],"title":"Linux_2","uri":"/posts/linux_2/"},{"categories":["鸟哥的私房菜"],"content":"电脑: 辅助人脑的好工具 ","date":"2021-02-15","objectID":"/posts/linux_1/:0:0","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"计算机硬件的五大单元 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:0","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"计算机硬件有哪五大单元？ 输入单元 输出单元 控制单元 算数逻辑单元 存储单元 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:1","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"cpu中包含哪些单元？ 控制、算术逻辑单元 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:2","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"CPU-什么是CPU的架构？ 首先，使用软件都需要经过CPU内部的微指令集来达成才行。其次，这些指令集的设计主要被分为两种设计理念，也就是两种主要的CPU架构: 分别为:精简指令集(RISC)与复杂指令集(CISC)系统。 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:3","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"CPU-什么是精简指令集(RISC)？ RISC 即 Reduced Instruction Set Computer. 其特点是: 每个指令的执行时间很短 完成的动作单纯 指令的执行性能较佳 若做复杂的事情，需要多个指令来完成 其应用： 甲骨文的SPARC CPU 学术领域的大型工作站 银行金融体系的主要服务器 IBM的Power Architecture 索尼的Play Station 3 安谋(ARM Holdings)的ARM CPU 手机 PDA(Personaldigital assistant) 导航系统 网络设备(交换器、路由器) ","date":"2021-02-15","objectID":"/posts/linux_1/:1:4","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"CPU-什么是复杂指令集(CISC)? CISC 即 Complex Instruction Set Computer. 其特点是: 每个微指令集可又执行一些较低阶的硬件操作 指令数目多而且复杂 每条指令的长度并不相同 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:5","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"CPU-所谓的x86架构是如何而来的？ 因为最早的Intel发展出来的CPU代号称为8086, 后来依此架构以开发出80286, 80386…, 因此这种架构的CPU就被称为x86架构 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:6","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"CPU-所谓的x86_64中的64指的是什么？ 64CPU代表CPU一次可以读写64bits这么多的数据 64bits有多大？ 即2的64方 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:7","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"CPU-如何在linux下查看当前CPU所支持的指令集？ cat /proc/cpuinfo ","date":"2021-02-15","objectID":"/posts/linux_1/:1:8","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"容量单位-计算中的容量单位有哪些？它们如何进行转化？ 文件大小使用的是二进制的方式 进位制 Kilo Mega Giga Tera Peta exta Zetta 二进制 1024 1024K 1024M 1024G 1024T 1024P 1024E 十进制 1000 1000K 1000M 1000G 1000T 1000P 1000E ","date":"2021-02-15","objectID":"/posts/linux_1/:1:9","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"容量单位-假设你今天购买了500GB的硬盘一颗，但是格式化完毕后却剩下460GB左右的容量，这是什么原因? 因为一般的硬盘制造商会使用十进制的单位 500GByte 代表为 500 * 1000 * 1000 * 1000 Byte 转成文件的容量单位时使用二进制(1024为底)，所以就成466GB左右容量 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:10","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"速度单位-计算中的速度单位有哪些？它们如何进行转化？ CPU的运算速度常用MHZ或者是GHZ 网络常使用的单位为Mbps即Mbits per second 进位制 Kilo Mega Giga Tera Peta exta Zetta 二进制 1024 1024K 1024M 1024G 1024T 1024P 1024E 十进制 1000 1000K 1000M 1000G 1000T 1000P 1000E ","date":"2021-02-15","objectID":"/posts/linux_1/:1:11","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["鸟哥的私房菜"],"content":"速度单位-20M/5M传输速度，如果转成文件大小的Byte时，其实理论最大传输为多少？ 网络常使用的单位为Mbps即Mbits per second 其实理论最大的传输值为 每秒2.5MByte/每秒625KByte的下载/上传速度 ","date":"2021-02-15","objectID":"/posts/linux_1/:1:12","tags":["linux"],"title":"Linux_1","uri":"/posts/linux_1/"},{"categories":["hugo"],"content":"Hugo is one of the most popular open-source static site generators. Basics ","date":"2021-02-01","objectID":"/posts/hugo/:0:0","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"1 Requirements install hugo sudo pacman -S hugo ","date":"2021-02-01","objectID":"/posts/hugo/:1:0","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"2 Installation ","date":"2021-02-01","objectID":"/posts/hugo/:2:0","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"2.1 Create a Project hugo new site my_website cd my_website ","date":"2021-02-01","objectID":"/posts/hugo/:2:1","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"2.2 Install the Theme git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2021-02-01","objectID":"/posts/hugo/:2:2","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"2.3 Configuration my_website/config.toml baseURL = \"https://fengqigang.cn\" defaultContentLanguage = \"en\" languageCode = \"en\" title = \"xiaonan's Blog\" theme = \"LoveIt\" [params] version=\"0.2.X\" defaultTheme = \"auto\" dataFormat = \"2006-01-02\" [parmas.app] title = \"Xiaonan's Blog\" noFavicon = false svgFavicon = \"\" [params.search] enable = true type = \"lunr\" contentLength = 4000 placeholder = \"\" maxResultLength = 10 snippetLength = 30 highlightTag = \"em\" absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] desktopMode = \"fixed\" mobileMode = \"auto\" [params.footer] enable = true custom = '' hugo = true copyright = true author = true since = 2019 [params.section] paginate = 20 dataFormat = \"01-02\" rss = 10 [params.list] paginate = 20 dataFormat = \"01-02\" rss = 10 [params.home] rss = 10 [params.home.profile] enable = true gravatarEmail = \"\" avatarURL = \"/images/avatar.png\" title = \"Xiaonan's Blog\" subtitle = \"\" typeit = true social = true disclaimer = \"\" [params.home.posts] enable = true paginate = 6 defaultHiddenFromHomePage = false [params.social] GitHub = \"guangsizhongbin\" Email = \"guangsizhongbin@gmail.com\" RSS = true [params.page] hiddenFromHomePage = false hiddenFromSearch = false twemoji = false lightgallery = false ruby = true fraction = true fontawesome = true linkToMarkdown = true rssFullText = false [parmas.page.toc] enable = true keepStatic = true auto = true [parmas.page.math] enable = true blockLeftDelimiter = \"\" blockRightDelimiter = \"\" copyTex = true mhchem = true [params.page.code] copy = true maxShowLines = 10 [menu] [[menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/Tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"categories\" url = \"/categories/\" title = \"\" weight = 3 [markup] [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumberInTable = true noClasses = false [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] unsafe = true [markup.tableOfContents] startLevel = 2 endLevel = 6 [author] name = \"fengxiaonan\" email = \"gaungsizhongbin@gmail.com\" link = \"fengqigang.cn\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2021-02-01","objectID":"/posts/hugo/:2:3","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"2.4 Create Post 2.4.1 Setting archetypes my_website/archetypes/default.md --- title: \"{{ replace .Name \"-\" \" \" | title }}\" date: {{ .Date }} lastmod: {{ now.Format \"2006-01-02\"}} author: \"xiaonan\" tags: [] categories: [] featuredIamge: \"\" featuredImagePreview: \"\" draft: true --- 2.4.2 Create a new website hugo new posts/first_post.md ","date":"2021-02-01","objectID":"/posts/hugo/:2:4","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"2.5 Launching the Website Locally hugo serve Go to http://localhost:1313 ","date":"2021-02-01","objectID":"/posts/hugo/:2:5","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"2.6 Build the Website hugo Markdown Syntax ","date":"2021-02-01","objectID":"/posts/hugo/:2:6","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"1 Blockquotes Add \u003e before any text you want to quote: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. The rendered output looks like this: Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. ","date":"2021-02-01","objectID":"/posts/hugo/:3:0","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"2 Task Lists - [x] Write the press release - [ ] Update the website - [ ] Contact the media The rendered output looks like this: Write the press release Update the website Contact the media ","date":"2021-02-01","objectID":"/posts/hugo/:4:0","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"3. Tables | Option | Description | |--------|-------------| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | The rendered output looks like this: Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2021-02-01","objectID":"/posts/hugo/:5:0","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["hugo"],"content":"4 Footnotes This is a digital footnote[^1]. This is a footnote with \"label\"[^label] [^1]: This is a digital footnote [^label]: This is a footnote with \"label\" This is a digital footnote1. This is a footnote with “label”2 This is a digital footnote ↩︎ This is a footnote with “label” ↩︎ ","date":"2021-02-01","objectID":"/posts/hugo/:6:0","tags":["hugo"],"title":"Hugo","uri":"/posts/hugo/"},{"categories":["nvim"],"content":"1 snippet \"(\\w+).par\" \"Parenthesis (postfix)\" r (`!p snip.rv = match.group(1)`$1)$0 endsnippet Tip \\w+ 匹配一个或多个字母、数字、下划线 () 分组 $0 结束位置 $1 结果时光标位置 ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:0","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"2 snippet \"([^\\s].*)\\.return\" \"Return (postfix)\" r return `!p snip.rv = match.group(1)`$0 endsnippet Note \\s 匹配所有空白符，包括换行 [^\\s] 除去所有空白符，包括换行 ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:1","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"3 snippet t \u003ctag\u003e${VISUAL:inside text/should/is/g}\u003c/tag\u003e endsnippet Note ${VISUAL} The syntax is: ${VISUAL:default/search/replace/option} ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:2","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"4 snippet \"be(gin)?( (\\S+))?\" \"begin{} / end{}\" br \\begin{${1:`!p snip.rv = match.group(3) if match.group(2) is not None else \"something\"`}} ${2:${VISUAL}} \\end{$1}$0 endsnippet Note ? 表示匹配前面的子表达式零次或一次 be(gin)? 可以匹配 be, beg, begi, begin \\S 匹配任何非空白字符 \\S+ 匹配一个或多个非空白字符 ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:3","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"5 global !p def upper_right(inp): return (75 - 2 * len(inp))* ' ' + inp.upper() endglobal snippet wow ${1:Text}`!p snip.rv = upper_right(t[1])` endsnippet Note 75 - 2 * len(inp) ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:4","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"6 snippet letter Dear $1, $0 Yours sincerely, $2 endsnippet Note $0 It is always the last tabstop in the snippet no matter how many tabstops are defined. ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:5","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"7. choice tabstop snippet q Your age: ${1|\u003c18,18~60,\u003e60|} Your height: ${2|\u003c120cm,120cm~180cm,\u003e180cm|} endsnippet Note ${1|item1, item2, item3, ...|} ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:6","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"8. mirrors snippet env \\begi{${1:enumerate}} $0 \\end{$1} endsnippet ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:7","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"9. Transformations Note {\u003ctab_stop_no/regular_expression/replacement/options} The components are defined as follows: components defined tab_stop_no The number of the tabstop to reference regular_expression The regular expression the value of the referenced tabstop is matched on replacement The replacement string, explained in detail below options Options for the regular expression The options can be any combination of options combination g global replace i case insensitive m multiline a ascii conversion snippet title \"Title transformation\" ${1:a text} ${1/\\w+\\s*/\\u$0/} endsnippet Note \\w+ 匹配一个或多个字母、数字、下划线 \\s* 匹配零个或多个任何空白字符 \\u Uppercase next letter snippet title \"Title transformation\" ${1:a text} ${1/\\w+\\s*/\\u$0/g} endsnippet Note g - blobal replace By default, only the first match of the regular expression is replaced. With this option allmatches are replaced. ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:8","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["nvim"],"content":"参考文章 正则表达式 - 语法 UltiSnips.txt ","date":"2021-01-30","objectID":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/:1:9","tags":["ultisnips"],"title":"UltiSnip中的正则","uri":"/posts/ultisnip%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99/"},{"categories":["archlinux"],"content":"Arch Linux is an independently developed, x86_64-optimised Linux distribution targeted at competent Linux users. Pre-installation ","date":"2021-01-29","objectID":"/posts/archlinux/:0:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"download ","date":"2021-01-29","objectID":"/posts/archlinux/:1:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"ios download ","date":"2021-01-29","objectID":"/posts/archlinux/:1:1","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"copy sudo fdisk -l dd bs=4M if=path/archlinux.iso of=/dev/sdx status=progress oflag=sync ","date":"2021-01-29","objectID":"/posts/archlinux/:1:2","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Partition the disks fidsk -l cfdisk xxx format Boot: mkfs.fat -F32 /dev/sdx_Boot Root: mkfs.ext4 /dev/sdx_Root mount mount /dev/sdx_Root /mnt mkdir /mnt/boot mount /dev/sdx_Boot /mnt/boot Installation ","date":"2021-01-29","objectID":"/posts/archlinux/:1:3","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"connect to the internet iwctl device list station scan station get-networks station connect xxxx quit ","date":"2021-01-29","objectID":"/posts/archlinux/:2:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Update the system clock timedatectl set-ntp true ","date":"2021-01-29","objectID":"/posts/archlinux/:3:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Select the mirrors vim /etc/pacman.d/mirrorlist reflector –verbose –latest 5 –country China –sort rate –save /etc/pacman.d/mirrorlist ","date":"2021-01-29","objectID":"/posts/archlinux/:4:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Install essential packages pacstrap /mnt base linux linux-firmware vim sudo configure the system ","date":"2021-01-29","objectID":"/posts/archlinux/:5:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Fstab genfstab -L /mnt » /mnt/etc/fstab -L define by labels ","date":"2021-01-29","objectID":"/posts/archlinux/:6:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"chroot arch-chroot /mnt ","date":"2021-01-29","objectID":"/posts/archlinux/:7:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Time zone Set the time zone ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime Run hwclock hwclock –systohc ","date":"2021-01-29","objectID":"/posts/archlinux/:8:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Localization Uncomment en_US.UTF-8 UTF-8 in /etc/locale.gen and generate it with locale-gen Create the /etc/locale.conf file, and set the LANG variable accordingly:LANG=\"en_US.UTF-8\" ","date":"2021-01-29","objectID":"/posts/archlinux/:9:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Network configuration Create the hostname file in /etc/hostname myhostname Add matching entries to /etc/hosts 127.0.0.1 localhost ::1 localhost 127.0.1.1 myhostname.localdomain myhostname ","date":"2021-01-29","objectID":"/posts/archlinux/:10:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Root password passwd ","date":"2021-01-29","objectID":"/posts/archlinux/:11:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Boot loader Install Boot loader packages pacman -S os-prober ntfs-3g grub efibootmgr grub-install grub-install –target=x86_64-efi –efi-directory=/boot –bootloader-id=grub grub-mkconfig grub-mkconfig -o /boot/grub/grub.cfg ","date":"2021-01-29","objectID":"/posts/archlinux/:12:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Intel-ucode pacman -S intel-ucode ","date":"2021-01-29","objectID":"/posts/archlinux/:13:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Reboot umount /mnt/boot umount /mnt reboot Post-installation ","date":"2021-01-29","objectID":"/posts/archlinux/:14:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"KDE Plasma install Xorg sudo pacman -S xorg KDE applications sudo pacman -S plasma konsole dolphin systemctl enable sudo systemctl enable NetworkManager sudo systemctl enable sddm ","date":"2021-01-29","objectID":"/posts/archlinux/:15:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Add a user to Wheel group add User useradd -m -G wheel -s /bin/bash xxx visudo uncomment ##%wheel ALL=(ALL) passwd passwd xxx ","date":"2021-01-29","objectID":"/posts/archlinux/:16:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Reboot software Installtion ","date":"2021-01-29","objectID":"/posts/archlinux/:17:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"archlinxcn vim /etc/pacman.conf [archlinuxcn] Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch Server = https://mirrors.cloud.tencent.com/archlinuxcn/$arch Server = https://mirrors.zju.edu.cn/archlinuxcn/$arch Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch sudo pacman -S archlinuxcn-keyring ","date":"2021-01-29","objectID":"/posts/archlinux/:18:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"git download sudo pacman -S git config git config --global user.name feng git config --global user.email guangsizhongbin@gmail.com SSH key ssh-keygen -t rsa -C \"guangsizhongbin@gmail.com\" test connect ssh -T git@github.com upload id_ras.pub to github ","date":"2021-01-29","objectID":"/posts/archlinux/:19:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"yay git clone https://aur.archlinux.org/yay.git cd yay sudo pacman -S base-devel makepkg -si ","date":"2021-01-29","objectID":"/posts/archlinux/:20:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"font sudo pacman -S nerd-fonts-complete sudo pacman -S wqy-zenhei wqy-bitmapfont wqy-microhei ttf-wps-fonts adobe-source-han-sans-cn-fonts adobe-source-han-serif-cn-fonts ","date":"2021-01-29","objectID":"/posts/archlinux/:21:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"v2ray sudo pacman -Sy v2ray sudo pacman -Sy qv2ray ","date":"2021-01-29","objectID":"/posts/archlinux/:22:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"joplin yay joplin ","date":"2021-01-29","objectID":"/posts/archlinux/:23:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Obsidian yay -S obsidaian ","date":"2021-01-29","objectID":"/posts/archlinux/:24:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"support nvim ","date":"2021-01-29","objectID":"/posts/archlinux/:24:1","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"anki sudo pacman -S anki ","date":"2021-01-29","objectID":"/posts/archlinux/:25:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"add-on AwesomeTTS (Google Cloud Text-to-Speech) [unofficial] 814349176 Fast Word Query: Multi-threaded queries for words from local or web dictionaries 1807206748 Image Occlusion Enhanced for Anki 2.1 (alpha) 1374772155 ReviewHeatmap 723520343 Browser: Table/Editor side-by-side 831846358 Beautify Anki (Material design , Deck Background and icon ) 1150874988 Batch Editing 291119185 editor: apply font color, background color, custom class, custom style 1899278645 9.Edit Field During Review 1020366288 ","date":"2021-01-29","objectID":"/posts/archlinux/:25:1","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"GPU sudo pacman -S linux-headers sudo pacman -S nvidia bbswitch optimus-manager-qt-kde systemctl enable optimus-manager.service ","date":"2021-01-29","objectID":"/posts/archlinux/:26:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"kde connect sudo pacman -S kdeconnect ","date":"2021-01-29","objectID":"/posts/archlinux/:27:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"screen-shot yay flameshot (community) shortcuts(flameshot gui) sudo pacman -S peek xclip sudo pacman -S xclip ","date":"2021-01-29","objectID":"/posts/archlinux/:28:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"widget Network speed pager ","date":"2021-01-29","objectID":"/posts/archlinux/:29:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"music sudo pacman -S iease-music ","date":"2021-01-29","objectID":"/posts/archlinux/:30:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"googlechrome sudo pacman -S google-chrome ","date":"2021-01-29","objectID":"/posts/archlinux/:31:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"plugin Dark Reader 沙拉查词 AdBlock Vimium infinity octotree language Tool SimpleExManage ","date":"2021-01-29","objectID":"/posts/archlinux/:31:1","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"video sudo pacman -S mpv sudo pacman -S vlc ","date":"2021-01-29","objectID":"/posts/archlinux/:32:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"neovim sudo pacman -S neovim plugin sudo pacman -S ctags clipboard sudo pacman -S xclip node.js sudo npm install -g neovim python pip install neovim C/C++ sudo pacman -S ccls ","date":"2021-01-29","objectID":"/posts/archlinux/:33:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"fcitx download sudo pacman -S fcitx fctix-im kcm-fcitx vim ~/.xprofile export GTK_IM_MODULE=fcitx export QT_IM_MODULE=fcitx export XMODIFIERS=\"@im=fcitx\" sogou-input yay -Sy fcitx-sogoupinyin ","date":"2021-01-29","objectID":"/posts/archlinux/:34:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"download you-get sudo pacman -S python-pip sudo pip3 install you-get youtube-dl sudo pip3 install youtube-dl ","date":"2021-01-29","objectID":"/posts/archlinux/:35:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"aria2 + youtube-dl youtube-dl -f 22 https://www.youtube.com/playlist?list=PLFx-dS8yeeGPPQAdpV6hiAqgi4Qzohcmk –external-downloader aria2c –external-downloader-args “-x 16 -k 1M” wget sudo pacman -S wget wget -c \"www.baidu.com\" -O baidu.index.html aria2 sudo pacman -S aria2 ","date":"2021-01-29","objectID":"/posts/archlinux/:35:1","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"zsh zsh sudo pacman -S zsh export https_proxy=“https://0.0.0.0:8119” oh-my-zsh export https_proxy=\"http://0.0.0.0:8189\" sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" plugin zsh-autosuggestions git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions ","date":"2021-01-29","objectID":"/posts/archlinux/:36:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"bluetooth sudo pacman -S pulseaudio-alsa pulseaudio-bluetooth bluez bluez-libs bluez-utils yay -S bluez-firmware systemctl enable bluetooth systemctl start bluetooth ","date":"2021-01-29","objectID":"/posts/archlinux/:37:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"pdf yay Okular ","date":"2021-01-29","objectID":"/posts/archlinux/:38:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"Clion sudo pacman -S clion clion-jre clion-cmake clion-gdb clion-lidb ","date":"2021-01-29","objectID":"/posts/archlinux/:39:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"java sudo pacman -S jdk ","date":"2021-01-29","objectID":"/posts/archlinux/:40:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"compress/decompress sudo pacman -S ark ","date":"2021-01-29","objectID":"/posts/archlinux/:41:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"drawing sudo pacman -S KolourPaint ","date":"2021-01-29","objectID":"/posts/archlinux/:42:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"图像查看 sudo pacman -S Gwenview ","date":"2021-01-29","objectID":"/posts/archlinux/:43:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"downloader - motrix yay -S aur/motrix ","date":"2021-01-29","objectID":"/posts/archlinux/:44:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"WPS sudo pacman -S wps-office-cn yay -S wps-office-mui-zh-cn ttf-wps-fonts ","date":"2021-01-29","objectID":"/posts/archlinux/:45:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"nutstore sudo pacman -S nutstore ","date":"2021-01-29","objectID":"/posts/archlinux/:46:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["archlinux"],"content":"timeout sudo pacman -Syyu –disable-download-timeout ","date":"2021-01-29","objectID":"/posts/archlinux/:47:0","tags":["archlinux"],"title":"Archlinux","uri":"/posts/archlinux/"},{"categories":["nvim"],"content":"Markdown1 Plug 'godlygeek/tabular' \"必要插件 Plug 'plasticboy/vim-markdown' \" To disable math conceal with LaTex math syntax enabled, add the following let g:tex_conceal = \"\" let g:vim_markdown_math = 1 [[: go to previous header. ]]: go to next header. ]c: go to Current header. ]u: go to parent header (Up). zR: opens all flods zM: folds everything all the way zr: reduces fold level throughout the buffer zm: increases fold level throughout the buffer ","date":"2021-01-27","objectID":"/posts/nvim%E6%8F%92%E4%BB%B6/:1:0","tags":["nvim"],"title":"Nvim插件","uri":"/posts/nvim%E6%8F%92%E4%BB%B6/"},{"categories":["nvim"],"content":"snippets2 ","date":"2021-01-27","objectID":"/posts/nvim%E6%8F%92%E4%BB%B6/:2:0","tags":["nvim"],"title":"Nvim插件","uri":"/posts/nvim%E6%8F%92%E4%BB%B6/"},{"categories":["nvim"],"content":"UltisnipsEdit进入编辑页面3 snippet triggerWord \"Comment\" iAwrb your snippets endsnippet triggerWord 为关键词 iAwrb为snippet的选项 - i 表示片段可在句中被触发 - A 表示片段会被自动出发 - w 表示片段会在关键词为单独单词的情况下被触发 - r 表示关键词语使用正则表达式, 正则表达式必须用两个引号'‘包围 - b 表示只有在一行的开头才会被触发 数学模式下自动加下标 snippet'([A-Za-z])(\\d)'\"auto subscript\"wrA`!psnip.rv=match.group(1)`_`!psnip.rv=match.group(2)`endsnippet Note [A-Za-z]: 匹配A-Z, a-z python代码 - fn 表示当前文件名 - path 当前文件名的路径 - t 占位符的字典, 可以用t[1], t[2], t.v来取占位符内容 - snip.rv 表示 return value - snip.fn 表示当前文件名 - snip.ft 表示当前文件类型 - snip.v 表示VISUAL模式变量 - snip.v.mode 表示模式类型 - snip.v.text 表示VISUAL模式中选择的字符 占位符选择 - /\u003ctab\u003e 切换下一个占位符 - \u003cshift-tab\u003e 切换上一个占位符 创建表格 snippet '(?\u003c!\\\\)([0-9])([0-9])tb' \"new table\" r $1`!p x=match.group(1) y=match.group(2) row1=\"\" row2=\"\" for i in range(int(x)): row1+=\"| \" row2+=\"|:-:\" row1+=\"|\\n\" row2+=\"|\\n\" out=row1+row2+int(y)*row1 snip.rv=out `$0 endsnippet e vim-markdown ↩︎ 高效做笔记:vim + markdown ↩︎ UltiSnips Screencast Episode 2 ↩︎ ","date":"2021-01-27","objectID":"/posts/nvim%E6%8F%92%E4%BB%B6/:2:1","tags":["nvim"],"title":"Nvim插件","uri":"/posts/nvim%E6%8F%92%E4%BB%B6/"},{"categories":["linux"],"content":"关联方法1 ","date":"2021-01-26","objectID":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/:1:0","tags":["joplin"],"title":"使用WebDAV关联坚果云与Joplin","uri":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/"},{"categories":["linux"],"content":"1. 在坚果云上创建一个英文名称的根目录的文件夹, 如\"note\" ","date":"2021-01-26","objectID":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/:1:1","tags":["joplin"],"title":"使用WebDAV关联坚果云与Joplin","uri":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/"},{"categories":["linux"],"content":"2. 配置Joplin WebDAV URL: https//dav.jiangguoyun.com/dav/note (note为刚才创建的文件夹名称) WebDAV 名称: 坚果云账号邮箱 WebDAV 密码: 在坚果云中生成的第三方应用密码2 ","date":"2021-01-26","objectID":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/:1:2","tags":["joplin"],"title":"使用WebDAV关联坚果云与Joplin","uri":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/"},{"categories":["linux"],"content":"3. 点击检查\"同步配置\" ","date":"2021-01-26","objectID":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/:1:3","tags":["joplin"],"title":"使用WebDAV关联坚果云与Joplin","uri":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/"},{"categories":["linux"],"content":"BUG 1. Too many requests are received recently 可以将同步的并发连接数调低(调成1后，等一会, 即可)3 如何使用WebDAV关联坚果云与Joplin? ↩︎ 坚果云第三方应用授权WebDAV开启方法 ↩︎ joplin使用坚果云webdav同步时出现以下问题如何解决？ ↩︎ ","date":"2021-01-26","objectID":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/:1:4","tags":["joplin"],"title":"使用WebDAV关联坚果云与Joplin","uri":"/posts/%E4%BD%BF%E7%94%A8webdav%E5%85%B3%E8%81%94%E5%9D%9A%E6%9E%9C%E4%BA%91%E4%B8%8Ejoplin/"},{"categories":["linux"],"content":"To disable a laptop’s internal keyboard ","date":"2021-01-25","objectID":"/posts/xinput/:0:0","tags":["xinput"],"title":"Xinput","uri":"/posts/xinput/"},{"categories":["linux"],"content":"xinput list1 Execute the command xinput list to list input devices. $ xinput list ⎡ Virtual core pointer id=2 [master pointer (3)] ⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)] ⎜ ↳ ETD2303:00 04F3:3083 Mouse id=11 [slave pointer (2)] ⎜ ↳ ETD2303:00 04F3:3083 Touchpad id=12 [slave pointer (2)] ⎜ ↳ ETPS/2 Elantech Touchpad id=17 [slave pointer (2)] ⎣ Virtual core keyboard id=3 [master keyboard (2)] ↳ Virtual core XTEST keyboard id=5 [slave keyboard (3)] ↳ Power Button id=6 [slave keyboard (3)] ↳ Video Bus id=7 [slave keyboard (3)] ↳ Power Button id=8 [slave keyboard (3)] ↳ Video Bus id=9 [slave keyboard (3)] ↳ XiaoMi USB 2.0 Webcam: XiaoMi U id=10 [slave keyboard (3)] ↳ Intel HID events id=13 [slave keyboard (3)] ↳ Xiaomi WMI keys id=14 [slave keyboard (3)] ↳ Xiaomi WMI keys id=15 [slave keyboard (3)] ↳ AT Translated Set 2 keyboard id=16 [slave keyboard (3)] ","date":"2021-01-25","objectID":"/posts/xinput/:0:1","tags":["xinput"],"title":"Xinput","uri":"/posts/xinput/"},{"categories":["linux"],"content":"Locate AT Translated Set 2 keyboard take note of its id number ","date":"2021-01-25","objectID":"/posts/xinput/:0:2","tags":["xinput"],"title":"Xinput","uri":"/posts/xinput/"},{"categories":["linux"],"content":"disable the keyboard xinput float \u003cid#\u003e, where \u003cid#\u003e is the keyboard’s id number. For example, if the id was 10, then the command would be xinput float 16 ","date":"2021-01-25","objectID":"/posts/xinput/:0:3","tags":["xinput"],"title":"Xinput","uri":"/posts/xinput/"},{"categories":["linux"],"content":"re-enable the keyboard xinput reattach \u003cid#\u003e \u003cmaster#\u003e master is that second number we noted down. For example, if the master was 3, you would do xinput reattach 16 3 Is there a way to disable a laptop’s internal keyboard? ↩︎ ","date":"2021-01-25","objectID":"/posts/xinput/:0:4","tags":["xinput"],"title":"Xinput","uri":"/posts/xinput/"},{"categories":["python"],"content":"sxtw1 import sxtwl def lunar_calendar(yyyy,mm,dd): import sxtwl lunar = sxtwl.Lunar() daylunar = lunar.getDayBySolar(yyyy, mm, dd) if daylunar.Lmc \u003e 1: ly, lmm = str(daylunar.y), str(daylunar.Lmc - 1) else: ly, lmm = str(daylunar.y - 1), str(daylunar.Lmc + 11) if daylunar.Lleap: lm=\"闰\"+lmm else: lm=lmm ld=str(daylunar.Ldi+1) ShX = [\"鼠\", \"牛\", \"虎\", \"兔\", \"龙\", \"蛇\", \"马\", \"羊\", \"猴\", \"鸡\", \"狗\", \"猪\"] sx = ShX[daylunar.Lyear2.dz] return ly,lm,ld,sx lunar = lunar_calendar(2021,1,24) print(lunar[0] + \"年\" + lunar[1] + \"月\" + lunar[2] + \"日\") 用sxtwl模块轻松实现农历转换 ↩︎ ","date":"2021-01-24","objectID":"/posts/solartolunar/:0:1","tags":["python"],"title":"SolarToLunar","uri":"/posts/solartolunar/"},{"categories":["linux"],"content":"Install sudo pacman -S imagemagick sudo pacman -S ghostscript ","date":"2021-01-23","objectID":"/posts/pdftoimage/:0:1","tags":["convert"],"title":"PdfToImage","uri":"/posts/pdftoimage/"},{"categories":["linux"],"content":"Error1 Tip convert: attempt to perform an operation not allowed by the security policy `PDF' @ error/constitute.c/IsCoderAuthorized/408. convert: no images defined `output.png' @ error/convert.c/ConvertImageCommand/3288. /etc/ImageMagick-7/policy.xml -: \u003cpolicy domain=\"delegate\" rights=\"none\" pattern=\"gs\" /\u003e --- +: \u003cpolicy domain=\"coder\" rights=\"read | write\" pattern=\"PDF\" /\u003e ","date":"2021-01-23","objectID":"/posts/pdftoimage/:0:2","tags":["convert"],"title":"PdfToImage","uri":"/posts/pdftoimage/"},{"categories":["linux"],"content":"Convert2 # convert single page of PDF file to image convert presentation.pdf[0] test.jpg # convert from page 0 to page 5 convert presentation.pdf[0-5] test.jpg Note -density used to specify the DPI of the output images. quality specify the quality for the generated images. %3d used to specify the format for generated image names. The generated images will be named output-001.jpg, output-002.jpg ImageMagick安全策略’PDF’阻止转换 ↩︎ How to Convert PDF to Images with Imagemagick ↩︎ ","date":"2021-01-23","objectID":"/posts/pdftoimage/:0:3","tags":["convert"],"title":"PdfToImage","uri":"/posts/pdftoimage/"},{"categories":["archlinux"],"content":"自动安装vim-plug1 if empty(glob('~/.vim/autoload/plug.vim')) silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim autocmd VimEnter * PlugInstall --sync | source $MYVIMRC endif Note $MYVIMRC The $MYVIMRC environment variable is set to the file that was first found, unless $MYVIMRC was already set and when using VIMINIT. ","date":"2021-01-21","objectID":"/posts/nvim/:1:0","tags":["Nvim"],"title":"Nvim","uri":"/posts/nvim/"},{"categories":["archlinux"],"content":"基本配置 ","date":"2021-01-21","objectID":"/posts/nvim/:2:0","tags":["Nvim"],"title":"Nvim","uri":"/posts/nvim/"},{"categories":["archlinux"],"content":"行相关配置 set number set relativenumber set cursorline set tabstop=2 set shiftwidth=2 set softtabstop=2 Note What is the difference between tabstop, shiftwidth, expandtab, softtabstop? 1 tabstop effectively how many columns of whitespace a \\t is worth shiftwidth how many colums of whitespace a “level of identation” is worth expandtab Setting expandtab means that you never wanna see a \\t again in your file softtabtop how many columns of whitespace a tab keypress or a backspace keypress is worth Tab settings in Vim ↩︎ swap, backup, undo Files 配置2 silent !mkdir -p ~/.config/nvim/tmp/backup silent !mkdir -p ~/.config/nvim/tmp/undo set backupdir=~/.config/nvim/tmp/backup,. set directory=~/.config/nvim/tmp/backup,. Note Swap file .myfile.txt.swp is a swap file, containg the unsaved changes. Backup file myfile.txt`` is a backup file -- the version of myfile.txt` before your edited it. Undo file `.myfile.txt.un`` is an undo file, containing the undo trees of the file edited. directory List of directory names for the swap file, separated with commas. updatetime If this many milliseconds nothing is type the swap file will be written to disk（default 4000） colorcolumn colorcolum is a comma separated list of screen columns that are highlighted with ColorColumn hl-ColorColumn. ","date":"2021-01-21","objectID":"/posts/nvim/:2:1","tags":["Nvim"],"title":"Nvim","uri":"/posts/nvim/"},{"categories":["archlinux"],"content":"Basic Mappings \u003cLEADER\u003e let mapleader=\" \" Note let {var-name} = {expr1} Set internal variable {var-name} to the result of the expression {expr1}. The variable will get the type from the {expr}. If {var-name} didn’t exist yet, it is created. Save \u0026 quit noremap Q :q\u003cCR\u003e noremap \u003cC-q\u003e :qa\u003cCR\u003e noremap S :w\u003cCR\u003e Note noremap {lhs} {rhs} Map the key sequence {lhs} to {rhs} for the modes where the map command applies. Disallow mapping of {rhs}, to avoid nested and recursive mappings. What is the difference between the remap, noremap, nnoremap and vnoremap mapping commands in Vim? 3 remap is an option that makes mappings work recursively. :map and :noremap are recursive and non-recursive versions of the various mapping commands. :map j gg (moves cursor to first line) :map Q j (moves cursor to first line) :noremap w j (moves cursor to down one line) j will be mapped to gg. Q will also be mapped to gg, because j will be expanded for the recursive mapping. W will be mapped to j (and not to gg) because j will not be expanded for the non-recursive mapping. normal modes: :map and :nnoremap visual modes: :vmap and :vnoremap Select modes: :smap adn :snoremap Open the vimrc file in anytime noremap \u003cLEADER\u003e :e ~/.config/nvim/init.vim\u003cCR\u003e copy content \" make Y to copy till the end of the line nnoremap Y y$ \" Copy to system clipboard vnoremap Y \"+y Search set ignorecase set smartcase noremap \u003cLEADER\u003e\u003cCR\u003e :nohlsearch\u003cCR\u003e scrolloff set scrolloff=4 Note scrolloff: Minimal number of screen lines to keep above and below the cursor. This will make some context visible around where you are working. Resize splits noremap \u003cup\u003e :res +5\u003cCR\u003e noremap \u003cdown\u003e :res -5\u003cCR\u003e noremap \u003cleft\u003e :vertical resize -5\u003cCR\u003e noremap \u003cright\u003e :vertical resize +5\u003cCR\u003e Markdowm Setting \u003cdiv class=\"details admonition tip open\"\u003e \u003cdiv class=\"details-summary admonition-title\"\u003e \u003ci class=\"icon fas fa-lightbulb fa-fw\"\u003e\u003c/i\u003eTip\u003ci class=\"details-icon fas fa-angle-right fa-fw\"\u003e\u003c/i\u003e \u003c/div\u003e \u003cdiv class=\"details-content\"\u003e \u003cdiv class=\"admonition-content\"\u003e\u003cblockquote\u003e \u003cp\u003e\u003ccode\u003e_\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e \u003cp\u003e1 lines downward, on the first non-blank\u003c/p\u003e \u003cblockquote\u003e \u003cp\u003e\u003ccode\u003e[\u0026quot;x]c{motion}\u003c/code\u003e\u003c/p\u003e \u003c/blockquote\u003e \u003cp\u003eDelete \u003ccode\u003e{motion}\u003c/code\u003e text [into register x] adn start insert.\u003c/p\u003e \u003cblockquote\u003e \u003cp\u003e\u003ccode\u003el\u003c/code\u003e \u003ccode\u003e[count]\u003c/code\u003e characters to the right.\u003c/p\u003e \u003c/blockquote\u003e \u003cblockquote\u003e \u003cp\u003e\u003ccode\u003ef{char}\u003c/code\u003e To \u003ccode\u003e[count]\u003c/code\u003e\u0026lsquo;th occurrence of \u003ccode\u003e{char}\u003c/code\u003e to the right.\u003c/p\u003e \u003c/blockquote\u003e \u003cblockquote\u003e \u003cp\u003e\u003ccode\u003eF{char}\u003c/code\u003e To the \u003ccode\u003e[count]\u003c/code\u003e\u0026lsquo;th occurrence of \u003ccode\u003e{char}\u003c/code\u003e to the right.\u003c/p\u003e \u003c/blockquote\u003e \u003cblockquote\u003e \u003cp\u003e\u003ccode\u003e\u0026quot;\u003c/code\u003e Use register {a-zA-Z0-9.%#:-\u0026quot;} for next delete, yank or put (use uppercase character to append with delete and yank) ({.%#:} only work with put)\u003c/p\u003e \u003c/blockquote\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e junegunn/vim-plug ↩︎ Vim: Remove swap, backup and undo Files from Working Directory ↩︎ What is the difference between the remap, noremap, nnoremap and vnoremap mapping commands in Vim? ↩︎ ","date":"2021-01-21","objectID":"/posts/nvim/:2:2","tags":["Nvim"],"title":"Nvim","uri":"/posts/nvim/"},{"categories":["数据结构"],"content":"123 ","date":"2021-01-20","objectID":"/posts/quicksort/:0:0","tags":["sort"],"title":"QuickSort","uri":"/posts/quicksort/"},{"categories":["java"],"content":"Java运行机制 ","date":"2021-01-20","objectID":"/posts/java/:1:0","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["java"],"content":"高级语言的运行机制 编译型 使用专门的编译器, 针对特定平台(操作系统)将某种高级语言源代码一次性’翻译’成可被该平台硬件执行的机器码(包括机器指令和操作数), 并包装成该平台所能识别的可执行性的程序格式。 解释型 使用专门的解释器对源程序逐行解释成特定的机器码并立即执行的语言 ","date":"2021-01-20","objectID":"/posts/java/:1:1","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["java"],"content":"Java安装 ","date":"2021-01-20","objectID":"/posts/java/:2:0","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["java"],"content":"archlinux下安装 sudo pacman -S jdk ","date":"2021-01-20","objectID":"/posts/java/:2:1","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["java"],"content":"输出Hello World ","date":"2021-01-20","objectID":"/posts/java/:3:0","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["java"],"content":"编写Hello World代码 HelloWorld.java public class HelloWorld { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } String 大写 System 大写 ","date":"2021-01-20","objectID":"/posts/java/:3:1","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["java"],"content":"编译 javac -d . HelloWorld.java Note javac -d Specify where to place generated class files ","date":"2021-01-20","objectID":"/posts/java/:3:2","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["java"],"content":"运行 java HelloWorld ","date":"2021-01-20","objectID":"/posts/java/:3:3","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["java"],"content":"参考 疯狂的java ","date":"2021-01-20","objectID":"/posts/java/:4:0","tags":["java"],"title":"Java","uri":"/posts/java/"},{"categories":["树莓派"],"content":"安装samba sudo apt-get update sudo apt-get intall samba samba-common-bin ","date":"2021-01-19","objectID":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["samba"],"title":"Samba服务器","uri":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["树莓派"],"content":"配置smb.conf /etc/samba/smb.conf [share] path = /home/pi valid users = pi browseable = yes public = yes writable = yes ","date":"2021-01-19","objectID":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/:2:0","tags":["samba"],"title":"Samba服务器","uri":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["树莓派"],"content":"重新运行smaba服务 sudo /etc/init.d/samba restart ","date":"2021-01-19","objectID":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/:3:0","tags":["samba"],"title":"Samba服务器","uri":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["树莓派"],"content":"添加pi用户为Samba用户 sudo smbpasswd -a pi ","date":"2021-01-19","objectID":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/:4:0","tags":["samba"],"title":"Samba服务器","uri":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["树莓派"],"content":"参考 树莓派4设置Samba的最新版本 树莓派3-搭建SAMBA服务器 ","date":"2021-01-19","objectID":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/:5:0","tags":["samba"],"title":"Samba服务器","uri":"/posts/samba%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["python"],"content":"URL拼接 替换参数1 url = 'https://www.aliexpress.com/item/{}.html'.format(123) print(url) https://www.aliexpress.com/item/123.html ","date":"2021-01-18","objectID":"/posts/momo/:0:1","tags":["momo"],"title":"Momo","uri":"/posts/momo/"},{"categories":["python"],"content":"termcolor2 colored(text, color=None, on_color=None, attrs=None) color: 字体颜色， on_color: 背景颜色 from termcolor import colored, cprint text = colored('Hello, World!','red', 'on_white', attrs=['blink']) print(text) cprint('Hello, World!', 'red', 'on_white', attrs=['blink']) ","date":"2021-01-18","objectID":"/posts/momo/:0:2","tags":["momo"],"title":"Momo","uri":"/posts/momo/"},{"categories":["python"],"content":"momo #encoding: utf8 import aiohttp import asyncio from termcolor import colored from requests import get import re import time import sys ids = () def getProxy(completion, TargetNum, proxynum, ProxyList): global proxies if completion \u003e= TargetNum: return 0 ## print('[+] %s' % colored('get proxy...', 'blue', attrs=['bold']), end='') while 1: try: url = 'http://www.89ip.cn/tqdl.html?num=%s' % proxynum html = get(url).text proxies = set(re.findall( r\"[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}:[0-9]+\", html)) - set(ProxyList) if not len(proxies): ## print('\\n [-]Waiting') time.sleep(3) continue ## print(colored('[%d]' % len(proxies), 'yellow', attrs=['bold']), '%s' % ( ## colored('Done!', 'green', attrs=['bold']))) return 1 except Exception as e: ## print('\\n [-]Error: ' + str(e)) time.sleep(5) async def autoVisit(proxy, sem): global ProxyList, completion async with sem: async with aiohttp.ClientSession() as session: try: for id in ids: async with session.get(url=id, proxy='http://' + proxy, timeout=5) as resp: print('[%s]' % colored(proxy, 'cyan', attrs=['bold']), colored('Successfully!', 'green', attrs=['bold'])) ProxyList.append(proxy) completion += 1 except Exception as e: print('', end='') proxies = [] ProxyList = [] completion = 0 # how many proxies you want to # get in one request of free proxy site proxynum = 100 # how many visition your want to get TargetNum = 40 loop = asyncio.get_event_loop() sem = asyncio.Semaphore(proxynum) while getProxy(completion, TargetNum, proxynum, ProxyList): tasks = [asyncio.ensure_future(autoVisit(i, sem)) for i in proxies] loop.run_until_complete(asyncio.wait(tasks)) loop.close() print(colored(completion, 'yellow', attrs=['bold'])) python3 使用format函数对URL进行拼接 ↩︎ python库termcolor用法 ↩︎ ","date":"2021-01-18","objectID":"/posts/momo/:0:3","tags":["momo"],"title":"Momo","uri":"/posts/momo/"},{"categories":["python"],"content":"asyncio1 import time def hello(): time.sleep(1) def run(): for i in range(5) hello() print('Hello World:%s' % time.time()) if __name__ == '__main__': run() Note ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:1:0","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["python"],"content":"1. time.time1 Return the time in seconds since the epoch as a floating point number. The epoch is the point where the time starts, and is platform dependent. For Unix, the epoch is January 1, 1970, 00:00:00 (UTC) ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:1:1","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["python"],"content":"2. What does __name__ == '__main__' do? Whenever the Python interpreter reads a source file, it does two thing: it sets a few special variables like __name__. it executes all of the code found in the file. Code Sample print(\"before import\") import math print(\"before functionA\") def functionA(): print(\"Function A\") print(\"before functionB\") def functionB(): print(\"Function B {}\".format(math.sqrt(100))) print(\"before __name__ guard\") if __name__ == '__main__' functionA() functionB() print(\"after __name__ guard\") Special Variables Executing the Module’s Code Summary Food for Thought Q: Can I have multiple __name__ checking blocks? import os, sys; sys.path.insert(0, os.path.dirname(__file__)) def functionA(): print(\"a1\"); from foo2 import functionB print(\"a2\") functionB() print(\"a3\") def functionB(): print(\"b\") print(\"t1\") if __name__ == \"__main__\": print(\"m1\") functionA() print(\"m2\") print(\"t2\") t1 -\u003e m1 -\u003e a1 -\u003e module :(t1 -\u003e t2 -\u003e a2 -\u003e b -\u003e a3) -\u003e m2 -\u003e t2 import os, sys; sys.path.insert(0, os.path.dirname(__file__)) def functionA(): print(\"a1\") from foo3 import functionB print(\"a2\") functionB() print(\"a3\") def functionB(): print(\"b\") print(\"t1\") print(\"m1\") functionA() print(\"m2\") print(\"t2\") t1 -\u003e m1 -\u003e a1 -\u003e module:（t1 -\u003e m1 -\u003e a1-\u003e a2 -\u003e b -\u003e a3 -\u003e m2 -\u003e t2）a2-\u003e b -\u003e a3 -\u003e m2 -\u003e t2 docs.python.org ↩︎ import time import asyncio async def hello(): print('Hello World:%s' % time.time()) await asyncio.sleep(1) print('Hello wow World:%s' % time.time()) def run(): tasks = [] for i in range(5): tasks.append(hello()) loop.run_until_complete(asyncio.wait(tasks)) loop = asyncio.get_event_loop() if __name__ == '__main__': run() Note ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:1:2","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["python"],"content":"1. async def Functions prefixed with the async keyword become asynchronous functions, also known as coroutines. keyword: await: which allows a coroutine to wait for results from another coroutine without blocking. ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:1:3","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["python"],"content":"2. Event loops The asyncio library creates and manages event loops, the mechanisms that run coroutines until they complete. ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:1:4","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["python"],"content":"3. Task When you submit a coroutine to an event loop for processing, you can get back a Task object, which provides a way to control the behavior of the coroutine from outside the event loop. keyword .run_until_complete: It runs all of the supplied tasks until they’re done, then returns their results in a single batch. .get_event_loop: method provides us with an object that lets us control the event loop directly, by submitting async functions to it programmatically via .run_util_complete() ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:1:5","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["python"],"content":"aiohttp import asyncio from aiohttp import ClientSession tasks = [] url = \"http://fengqigang.cn/\" async def hello(url): async with ClientSession() as session: async with session.get(url) as response: response = await response.read() print(response) if __name__ == '__main__': loop = asyncio.get_event_loop() loop.run_until_complete(hello(url)) Note ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:2:0","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["python"],"content":"1. async with ClientSession() as session: async with session.get(url) as response: ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:2:1","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["python"],"content":"2. What different between wait and gather?1 import asyncio async def task(arg): await asyncio.sleep(5) return arg async def cancel_waiting_task(work_task, waiting_task): await asyncio.sleep(2) waiting_task.cancel() try: await waiting_task print(\"Waiting done\") except asyncio.CancelledError: print(\"Waiting task cancelled\") try: res = await work_task print(f\"Work result: {res}\") except asyncio.CancelledError: print(\"Work task cancelled\") async def main(): print() work_task = asyncio.create_task(task(\"done\")) waiting = asyncio.create_task(asyncio.wait({work_task})) await cancel_waiting_task(work_task, waiting) work_task = asyncio.create_task(task(\"done\")) waiting = asyncio.gather(work_task) await cancel_waiting_task(work_task, waiting) asyncio.run(main()) If gather() is cancelled, all submitted awaitables (that have not completed yet) are also cancelled. If the wait() task is cancelled, it simply throws an CancelledError and the waited tasks remain intact. Asyncio.gather vs asyncio.wait ↩︎ import time import asyncio from aiohttp import ClientSession tasks = [] url = \"https://www.baidu.com\" async def hello(url): async with ClientSession() as session: async with session.get(url) as response: response = await response.read() print('Hello World:%s' % time.time()) def run(): for i in range(5): task = asyncio.ensure_future(hello(url.format(i))) tasks.append(task) if __name__ == '__main__': loop = asyncio.get_event_loop() run() loop.run_until_complete(asyncio.wait(tasks)) import time import asyncio from aiohttp import ClientSession tasks = [] url = \"https://www.baidu.com/{}\" async def hello(url): async with ClientSession() as session: async with session.get(url) as response: print(response) print('Hello World:%s' % time.time()) return await response.read() def run(): for i in range(5): task = asyncio.ensure_future(hello(url.format(i))) tasks.append(task) result = loop.run_until_complete(asyncio.gather(*tasks)) print(result) if __name__ == '__main__': loop = asyncio.get_event_loop() run() 【python】详解异步async库的使用 ↩︎ ","date":"2021-01-16","objectID":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/:2:2","tags":["python"],"title":"同步与异步","uri":"/posts/%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"},{"categories":["android"],"content":" 下载adb sudo pacman -S adb 查看当前连接的设备 adb devices 授权后，由unauthorized变成如图 查看当前所有软件 adb shell pm list packages 以删除美团为例子 搜索软件 adb shell pm list packages | grep meituan 删除软件 进入交互模式 adb shell 卸载软件 pm uninstall -k --user 0 com.sankuai.meituan Tip -k: keep the data and cache directories --user 0: Where 0 is ID of main user in Android system. This way you don’t need to root your device. 1 stack overflow: adb uninstall failed ↩︎ ","date":"2021-01-15","objectID":"/posts/%E5%88%A0%E9%99%A4%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AEapp/:0:0","tags":["android"],"title":"删除手机内置app","uri":"/posts/%E5%88%A0%E9%99%A4%E6%89%8B%E6%9C%BA%E5%86%85%E7%BD%AEapp/"},{"categories":["数据结构"],"content":"顺序表代码实现 #define 与 typedef 的区别: 1 #define OK 1 当使用OK的时候会替换成1 #define 归预处理器管 typedef int Status 定义int 为Status类型 typedef 归编译器管 命名规范： SqList 这样的两个单词的合并，首字母要大写, 如ElemType, GetElem, ListDelete 使用#define后全要大写, 如#define TRUE 1 . 与 -\u003e 使用 当传递的是数组本身的时候用. 当传递的是指针的时候用-\u003e 定义SqList思路 ElemType 类型的 data[MAXSIZE]数组 必须确定当前的线性表的长度 int length GetElem的思路 不需要对数组进行修改，所以不传递数组指针SqList * 返回位序为i的元素的值, 需要指针来返回 ElemType *e, 数组下标是从0开始的，所以用*e=L.data[i-1] ListInsert的思路 边界上: 位序可以插入到第一个位置到当前长度+1的所有位置(在不满的情况下) 移动上: 从后往前移，此时操作的是数组，将位序转化为数组语言 k=L-\u003elength-1; k\u003e=i-1;k--) �序所对应位置的元素也需要移动 L-\u003edata[k+1] = L-\u003edata[k]; ata[i-1]=e; //插入新的元素 `` ListDelete的思路 边界上: 可以删除第一个位置到当前长度 移动上: 从位序开始，后面元素依次覆盖掉前面的元素 for (k = i; k \u003c L-\u003elength; k++) ata[k-1] = L-\u003edata[k]; `` //linerlist.h #ifndef LEETCODE_LINERLIST_H #define LEETCODE_LINERLIST_H #include \u003cstdio.h\u003e #define MAXSIZE 20 /* 存储空间初始分配量*/ #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef int Status; typedef int ElemType; /* 将ElemType 类型定为int */ typedef struct { ElemType data[MAXSIZE]; /*数组存储数据元素，最大值为MAXSIZE;*/ int length; /*线性表当前长度*/ }SqList; // 获得元素操作 Status GetElem(SqList L, int i, ElemType *e); // 插入操作 Status ListInsert(SqList *L, int i, ElemType e); // 删除操作 Status ListDelete(SqList *L, int i, ElemType *e); // 遍历操作 void TravelList(SqList L); // 按值查找 int LocateElem(SqList L, ElemType e); #endif //LEETCODE_LINERLIST_H // linerlist.cpp #include \"SequenceList.h\" /*Status 是函数的类型，其值是函数结果状态代码，如OK等*/ /*初始条件： 顺序线性表L已存在， 1\u003c=i\u003c=ListLength(L)*/ /*操作结果: 用e返回L中第i个数据元素的值*/ Status GetElem(SqList L, int i, ElemType *e) { if(L.length==0 || i\u003c1 || i\u003eL.length) return ERROR; *e=L.data[i-1]; return OK; } /*初始条件： 顺序线性表L已存在， i\u003c=i\u003c=ListLength(L)*/ /*操作结果： 在L中第i位置之前插入新的数据元素e, L的长度加1*/ Status ListInsert(SqList *L, int i, ElemType e) { int k; if(L-\u003elength==MAXSIZE) /*顺序线性表已经满*/ return ERROR; if (i\u003c1 || i\u003eL-\u003elength+1) /*当i不在范围内时*/ return ERROR; if (i\u003c=L-\u003elength) /*若插入数据位置不在表尾*/ { for (k=L-\u003elength-1; k\u003e=i-1; k--) L-\u003edata [k+1] = L-\u003edata[k]; } L-\u003edata[i-1]=e; /*将新元素插入*/ L-\u003elength++; return OK; } /*初始条件： 顺序线性表L已在在, i\u003c=i\u003c=ListLength(L)*/ /*操作结果: 删除L的第i个数据元素，并用e返回其值，L的长度减1*/ Status ListDelete (SqList *L, int i, ElemType *e) { int k; if (L-\u003elength == 0) return ERROR; if (i \u003c 1 || i \u003e L-\u003elength) /*删除位置不正确*/ return ERROR; *e = L-\u003edata[i - 1]; if (i \u003c L-\u003elength) { /*如果删除不是最后位置*/ for (k = i; k \u003c L-\u003elength; k++) /*将删除位置后继元素前移*/ L-\u003edata[k - 1] = L-\u003edata[k]; } L-\u003elength--; return OK; } /*初始条件： 顺序线性表L已在在, i\u003c=i\u003c=ListLength(L)*/ /*操作结果: 返回顺序表L中的所有元素， 用空格分开*/ void TravelList(SqList L) { int i; for (i=0; i \u003c L.length; i++) printf(\"%d \", L.data[i]); printf(\"\\n\"); } /*初始条件： 顺序线性表L已存在， i\u003c=i\u003c=ListLength(L)*/ /*操作结果： 返回顺序表L中值为e的元素的位序*/ int LocateElem(SqList L, ElemType e) { int i; for(i=0; i\u003cL.length; i++) if(L.data[i]==e) return i+1; return 0; } //main.cpp #include \"SequenceList.h\" int main(void){ SqList L; L.length = 0; //插入测试 ListInsert(\u0026L, 1 ,2); ListInsert(\u0026L, 2, 3); printf(\"当前线性表中所有的元素:\\n\"); TravelList(L); //删除测试 int e; ListDelete(\u0026L, 1, \u0026e); printf(\"被删除的元素是 %d\\n\", e); printf(\"当前线性表中所有的元素:\\n\"); TravelList(L); //查找测试 int a; GetElem(L, 1, \u0026a); printf(\"第1个元素是: %d \\n\", a); printf(\"数值为3的元素在哪里？ %d\\n\", LocateElem(L, 3)); return 0; } 知乎 ↩︎ ","date":"2021-01-14","objectID":"/posts/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/:1:0","tags":["顺序表"],"title":"顺序表代码实现","uri":"/posts/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"categories":["树莓派"],"content":"什么是WAN口和LAN口?1 WAN端口用于连接至Internet LAN端口用于连接局域网设备 图1不能访问的原因在于路由器2认为WAN口连接的是另外一个网络，而设备2访问设备1的IP地址是在同一个网络中，所以不会向WAN口发送网络包，因此不通。 ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:1:0","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["树莓派"],"content":"什么是网关？ 网关(Gateway)就是一个网络连接到另一个网络的\"关口\" ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:2:0","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["树莓派"],"content":"什么是默认网关？ 一个房间可又有多扇门一样，一台主机可又有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。 ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:2:1","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["树莓派"],"content":"网关与路由器有什么关系？2 “网关”是一个概念，“路由器\"是一个产品。 网关: 帮助两个不能直接互通的网络，进行数据转发的。 路由器，手机，防火墙均可实现网关功能: 路由器将家庭局域网和互联网相连 手机开了热点后，笔记本接进来，手机作为网关把笔记本和互联网相连 防火墙可能做网关，局域网连至防火墙，防火墙把局域网和互联网相连 ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:3:0","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["树莓派"],"content":"旁路由如何实现？ ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:4:0","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["树莓派"],"content":"网络数据在其中会怎样流动？3 国内网站: 局域网设备发出数据 -\u003e 到达主路由LAN1口 -\u003e 到达主路由LAN2口 -\u003e 到达旁路由LAN口 -\u003e 旁路由分析数据走位 -\u003e 到达旁路由LAN口 -\u003e 到达主路由LAN2口 -\u003e 到达主路由WAN口 -\u003e 到达互连网 互联网服务器返回数据 -\u003e 到达主路由WAN口 -\u003e 到达主路由LAN1口 -\u003e 到达局域网设备 国外网站: 局域网设备发出数据 -\u003e 到达主路由LAN1口 -\u003e 到达主路由LAN2口 -\u003e 到达旁路由LAN口 -\u003e 旁路由分析数据走位, 加密数据 -\u003e 到达旁路由LAN口 -\u003e 到达主路由LAN2口 -\u003e 到达主路由WAN口 -\u003e 到达互联网 互联网服务器返回数据 -\u003e 到达主路由WAN口 -\u003e 到达主路由LAN2口 -\u003e 到达旁路由LAN口 -\u003e 旁路由解密数据 -\u003e 到达旁路由LAN口 -\u003e 到达主路由LAN2口 -\u003e 到达主路由LAN1口 -\u003e 到达局域网设备 ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:4:1","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["树莓派"],"content":"旁路由实现 WAN口 ip: 192.168.1.2 mask: 255.255.255.0 broad: 192.168.1.1 DNS: 192.168.1.1 0.0.0.0 LAN口 ip: 192.168.0.101 mask: 255.255.255.0 raspberrypi ip: 192.168.0.120 安装V2ray.FunPi(Debian Buster)4 下载安装 sudo su - root cd /usr/local git clone https://github.com/twotreesus/V2ray.FunPi.git V2ray.Fun cd V2ray.Fun/script ./install.sh 修改启动配置(面板用户名、密码、端口) /usr/local/V2ray.Fun/config/app_config.json { \"py/object\": \"core.app_config.AppConfig\", \"user\": \"admin\", \"password\": \"admin\", \"port\": 1086, \"proxy_mode\": 1, \"inited\": true } 设置树莓派的DHCP /etc/dhcpcd.conf ip_address: 设置为树莓派的IP地址 routers: 设置为当前树莓派的路由IP地址 interface etho static ip_address=192.168.0.120/24 static ip6_address=fd51:42f8:caae:d92e::f/64 static routers=192.168.0.1 static domain_name_servers=192.168.0.1 8.8.8.8 fd51:42f8:caae:d923::1 重启服务 sudo supervisorctl restart v2ray.fun 重启树莓派 sudo reboot 设置路由器的DHCP网关 将路由器的DHCP网关设置为树莓派的地址, 例中为192.168.0.120 设置代理 192.168.0.120:1086 进入面板， 设置代理 添加配置节点 开启代理 知乎:LAN口和WAN口的区别是什么 ↩︎ 网关和路由器的区别是什么? ↩︎ OpenWrt中，旁路由的设置与使用 ↩︎ V2ray.FunPi ↩︎ ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:4:2","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["linux"],"content":"Install cron1 sudo pacman -S cronie ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:1:0","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["linux"],"content":"Quick running ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:2:0","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["linux"],"content":"config setting default Editor export EDITOR=/usr/bin/nvim systemctl systemctl enable cronie.service systemctl start cronie.service ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:2:1","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["linux"],"content":"create cron job2 crontab -e Crontab format1 Symbol Description * Wildcard, specifies every possible time interval , List multiple values separated by a comma. - Specify a range between two numbers, separated by a hyphen / Specify a periodicity/frequency using a slash example run every ten minutes */10 * * * * echo ‘Hello’ » /tmp/test.txt run every hours from 1-5 am 0 1-5 * * * * echo ‘Hello’ » /tmp/test.txt run every 30 minutes Mon-Fri 9am-5pm */30 9-17 * * 1-5 echo ‘Hello’ » /tmp/test.txt ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:2:2","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["linux"],"content":"command user crontab -u user list crontab -l remove crontab -r Cron-Archwiki ↩︎ Linux/Mac Tutorial: Cron Jobs - How to Schedule Commands with crontab ↩︎ ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:2:3","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["C"],"content":"重复包含问题的解决 ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:0","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["C"],"content":"1. 在main.cpp中只需要包含xxx.h即可，不需要包含xxx.cpp 原因分析： PS: 命令中没有提到\"speak.h\"文件(原因是:在\"speak.cpp\"中已经包含了\"speak.h\") ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:1","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["C"],"content":"2. 在xxx.h中，需要写上, 而xxx.cpp不需要写 #ifndef xxxxx #define xxxxx (...) #endif 原因分析： C++是采用独立编译，就是每个cpp单独编译成对应的.o文件，最后链接器再将多个.o文件链接成可执行程序。(防止同一个.o文件中包含多个相同的.h内容) ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:2","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["C"],"content":"3. 使用xxx.h与xxx.cpp这种方式的时候，声明放在xxx.h中，定义放在xxx.cpp中 原因分析： C++是采用独立编译，就是每个cpp单独编译成对应的.o文件，最后链接器再将多个.o文件链接成可执行程序。(在将多个.o文件链接成可执行程序的时候，有可能会在不同的.o文件中含有相同的定义) ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:3","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["C"],"content":"参考文章 注意头文件规则，避免链接错误：重复定义(multiple defination) 编译链接 C++ Compiling Cpp ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:2:0","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["树莓派"],"content":"安装Nginx和PHP sudo apt-get update sudo apt-get install nginx php7.3-fpm php7.3-cli php7.3-curl php-7.3-gd php7.3-cgi sudo service nginx start sudo service php7.3-fpm restart 使Nginx能处理PHP sudo nano /etc/nginx/sites-available/default location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } 修改为 location / { index index.html index.htm index.php default.html default.htm default.php; } location ~\\.php$ { fastcgi_pass unix:/run/php/php7.3-fpm.sock; #fastcgi_pass 127.0.0.1:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 重启nginx sudo service nginx restart ","date":"2021-01-11","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/:1:0","tags":["Dashboard"],"title":"树莓派安装pi_Dashboard","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/"},{"categories":["树莓派"],"content":"下载pi-dashboard sudo apt-get install git cd /var/www/html sudo git clone https://github.com/nxez/pi-dashboard.git sudo chown -R www-data pi-dashboard 通过http://树莓派IP/pi-dashboard访问部署好的Pi Dashboard ","date":"2021-01-11","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/:2:0","tags":["Dashboard"],"title":"树莓派安装pi_Dashboard","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/"},{"categories":["树莓派"],"content":"参考 Pi Dashboard (Pi 仪表盘) ","date":"2021-01-11","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/:3:0","tags":["Dashboard"],"title":"树莓派安装pi_Dashboard","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/"},{"categories":["树莓派"],"content":"内网穿通SSH 修改服务器端的frps.ini [common] bind_port = 7000 服务器端开启frp ./frps -c ./frps.ini 客户端修改frpc.ini [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.x.x.x local_port = 22 remote_port = 6000 开启客户端的frpc ./frpc -c ./frpc.ini 通过ssh连接 ssh user@x.x.x.x -p 6000 ","date":"2021-01-10","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:0","tags":["frp"],"title":"树莓派实现内网穿透","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["树莓派"],"content":"参考 github ","date":"2021-01-10","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:2:0","tags":["frp"],"title":"树莓派实现内网穿透","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["树莓派"],"content":"今天总有拿到树莓派4B+, 想着搭建一个下载机器，供家里人使用。 ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:0:0","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"各个接口功能 第一次入手，刚开始连电源键都没有找到, 官网提供了说明. ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:1:0","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"安装Raspberry Pi OS ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:0","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"下载系统 系统下载地址Raspberry Pi OS ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:1","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"烧录镜像 sudo fdisk -l 先查看SD卡的名称 sudo dd bs=4M if=系统路径 of=/dev/SD名称 status=progress oflag=sync Tip 使用dd时，写SD卡的名称，不要写SD卡分区的名称 使用dd时，报错 d: opening /dev/sdc: Read-only file system dd参数 bs=BYTES read and write up to BYTES bytes at a time (default:512); overrides ibs and obs status=LEVEL The LEVEL of information to print to sederr; none suppresses everything but error messages, noxfer suppresses the final transfer statistics, progress shows periodic transfer statistics. nocache Request to drop cache. See also oflag=sync ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:2","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"开启SSH，并连接 SD卡的boot，创建名为ssh`的文件即可 ssh pi@pi_ip_address 默认密码raspberry ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:3","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"配置 设置镜像 切换到清华源 下载并配置samba sudo apt install samba samba-common-bin // 下载samba sudo apt install vim // 下载vim sudo vim /etc/samba/smb.conf //配置samba 末尾加入 [MyNAS] valid users = pi, root path = /media/pi browseable = yes writable = yes create mask = 0644 directory mask = 0775 testparm //测试是否通过 sudo smbpassed -a pi //smb加入pi用户 systemctl enable smbd //开机启动smbd systemctl start smbd //启动smbd 下载并配置aria2 sudo apt install nginx sudo apt install aria2 cd /var/www/html sudo wget https://github.com/mayswind/AriaNg/releases/download/1.1.7/AriaNg-1.1.7-AllInOne.zip unzip AriaNg-1.1.7-AllInOne.zip systemctl start nginx //启动nginx systemctl enable nginx //开机启动nginx Tip 创建root用户 sudo passwd root ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:4","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"参考 raspberrypi.org raspberrypi.stackexchange.com ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:3:0","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["数据结构"],"content":"ShellSort Shell 排序动图 Tip 14\u003e\u003e2 如何计算？ \u003e\u003e为右移运算符 14 的二进制为(0000 1110) 正数向右移动，低位舍弃，高位补零 移动之后的二进制为(0000 0011), 为3 #include \u003cstdio.h\u003e int main(void) { int number = 14 \u003e\u003e 2; printf(\"右移二位后的值为: %d \", number); } gap = len \u003e\u003e 1 是什么意思？ 表示 gap = len 不断的对半分 ","date":"2021-01-07","objectID":"/posts/shellsort/:1:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"ShellSort C语言实现 #include \u003cstdio.h\u003e void print_list(int arr[], int len); void shell_sort(int arr[], int len) { int gap, i, j; int temp; int k = 1; for (gap = len \u003e\u003e 1; gap \u003e 0; gap \u003e\u003e= 1){ printf(\"gap 为%d时: \\n\", gap); for (i = gap; i\u003clen; i++) { temp = arr[i]; for(j = i-gap; j\u003e=0 \u0026\u0026 arr[j] \u003e temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; printf(\"第%d次list: \", k); print_list(arr,len); k+=1; printf(\"\\n\"); } } } void print_list(int arr[], int len) { for(int i=0;i\u003clen;i++) printf(\"%d \", arr[i]); } int main (void) { int arr[] = {3, 21, 412, 1, 4,39, 123, 6}; int len = (int) sizeof(arr) /sizeof (*arr); printf(\"初始list: \"); print_list(arr,len); printf(\"\\n\"); shell_sort(arr,len); printf(\"最终list: \"); print_list(arr,len); printf(\"\\n\"); } gap = 4 gap = 2 gap = 1 ","date":"2021-01-07","objectID":"/posts/shellsort/:2:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"Shell 排序复杂度和稳定性分析 啥是序偶(Ordered pair)? 序: 就是有序的意思 偶: 一对儿 证明N个互异的数组的平均逆序数是$N(N-1)/4$ 表$L$: 34, 8, 64, 51, 32, 21 其反序表$L_r$: 21, 32, 51, 64, 8, 34 该表中任意两个数的序偶$(x, y)$, 且$y \u003e x$, 显然在$L$与$L_r$中，在表L和它的反序表$L_r$中的序偶的总个数为$C_N^2=N(N-1)/2$, 因此，平均每个表的逆序是$N(N-1)/4$ 证明通过交换相邻元素进行排序的任何平均需要$\\Omega(N^2)$ 已知初始的平均逆序数$N(N - 1)/4 = \\Omega(N^2)$, 而每次交换只减少一个逆序，因此需要$\\Omega(N^2)$交换 ","date":"2021-01-07","objectID":"/posts/shellsort/:3:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"时间复杂度 为啥希尔排序的时间复杂度可以突破$O(N^2)$? 以希尔增量时希尔排序的最坏情形为$O(N^2)$ 啥是希尔增量? 希尔排序使用一个序列$h_1, h_2, … h_t$, 叫做增量序列 希尔增量：$h_t = \\lfloor N/2 \\rfloor$ $h_k = \\lfloor h_{k+1} \\rfloor$ 相隔 $h_k$个元素都被排序，此时称文件是$h_k$排序 以Hibbard增量的希尔排序的最坏情形为$O( N^\\frac{3}{2})$ 啥是Hibbard增量？ $1, 3, 7, …, 2^k - 1$ ","date":"2021-01-07","objectID":"/posts/shellsort/:3:1","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"空间复杂度 $O(1)$ ","date":"2021-01-07","objectID":"/posts/shellsort/:3:2","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"稳定性 Tip 在一个数组中，存在相同的数，经过排序后，这些数的相对次序保持不变，即原来数组中r[i] = r[j], r[i] 在r[j] 之前，经过排序后，r[i]仍在r[j]之前， 则称这种排序算法是稳定的，否则称为不稳定的。 序列： 3 5 10 $8_1$ 7 2 $8_2$ 1 20 6 对于gap=5时 (3, 2), (5, $8_2$), (10, 1), ($8_1$, 20), (7, 6) 排序后(2, 3), (5, $8_2$), (1, 10), ($8_1$, 20), (7, 6) 2 5 1 $8_1$ 7 3 $8_2$ 10 20 6 对于gap=2时，向下取整 (2, 1, 7, $8_2$, 20), (5, $8_1$, 3, 10, 6) 排序后 (1, 2, 7, $8_2$, 20), (3, 5, 6, $8_1$, 10) 1, 3, 2, 5, 7, 6, $8_2$, $8_1$, 20, 10 此时$8_2$已经跑到$8_1$之前，表示Shell排序不稳定 ","date":"2021-01-07","objectID":"/posts/shellsort/:3:3","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"如何用C语言实现Hibbard增量的Shell排序? 为什么要从希尔增量变成Hibbard增量？ 在希尔增量的情况下: 间隔为8时，分为8组 (1, 5), (9, 13), (2, 6), (10, 14), (3, 7), (11, 15), (4, 8), (12, 16) 间隔为4时，分为4组 (1, 3, 5, 7), (9, 11, 13, 15), (2, 4, 6, 8), (10, 12, 14, 16) 间隔为2时，分为2组 (1, 2, 3, 4, 5, 6, 7, 8), (9, 10, 11, 12, 13, 14, 15, 16) 间隔为1时，分为1组 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16) 前3个增量没有起任何作用 啥是一个好的增量？ 最后一个增量必须为1 避免序列中的值(尤其是相邻的值)互为倍数的情况 ","date":"2021-01-07","objectID":"/posts/shellsort/:4:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"参考文章 数据结构与算法——希尔排序 希尔排序增量序列简介 希尔排序为什么会那么牛那么快，能够证明吗？ ","date":"2021-01-07","objectID":"/posts/shellsort/:5:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"插入排序 ","date":"2021-01-06","objectID":"/posts/insertionsort/:1:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"插入排序的特征 1.从第二个元素(比较元素)开始一一与前面元素(被比较元素)比较, 若当前元素小于被比较元素，被比较元素后移，直到比较元素比被比较元素大或等于时，比较元素插入到被比较元素的位置 比较元素位置: 从第二个元素到最后一个(n-1个) 被比较元素位置: 从第一个到比较元素位置-1, 考虑从比较元素位置依次递减，满足\u003e=0即可. 即用while 这里一直用的arr[j+1] = arr[j], 采取前面元素覆盖后面元素的方式，当满足条件时，arr[j+1]才等于key ","date":"2021-01-06","objectID":"/posts/insertionsort/:2:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"C语言实现 #include\u003cstdio.h\u003e void insertion_sort(int arr[], int len); void print_list(int arr[], int len); void insertion_sort(int arr[], int len) { int i, j, key; int k=1; for(i=1; i\u003clen; i++) { key = arr[i]; j=i-1; while((j\u003e=0) \u0026\u0026 (arr[j]\u003ekey)){ arr[j+1] = arr[j]; j--; } arr[j+1] = key; printf(\"第%d次list:\", k); print_list(arr, len); printf(\"\\n\"); k+=1; } } void print_list(int arr[], int len) { int i; for(i=0; i\u003clen; i++) printf(\"%d \", arr[i]); } int main(void) { int arr[] = {22, 34, 321, 32, 1, 5, 23}; int len = (int) sizeof(arr) / sizeof(*arr); printf(\"初始list:\"); print_list(arr, len); printf(\"\\n\"); insertion_sort(arr, len); printf(\"最终list:\"); print_list(arr, len); return 0; } ","date":"2021-01-06","objectID":"/posts/insertionsort/:3:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"复杂度分析 ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"时间复杂度 最坏时间复杂度 在数组完全逆序的情况下: 插入第2个元素时，考虑对比1个元素 插入第3个元素时，考虑对比2个元素 插入第n个元素时，考虑对比n-1个元素 最坏情况下的比较次数是:$1+2+…+n-1=\\frac{(n-1)n}{2}$ 所以其时间复杂度是: $O(n^2)$ 最优时间复杂度 在数组完全正序的情况下: 插入第2个元素时，考虑对比1个元素 插入第3个元素时，考虑对比1个元素 插入第n个元素时，考虑对比1个元素 最好情况下的比较次数是: $1+1+…+1=n$ 所以其时间复杂度是: $O(n)$ ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:1","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"空间复杂度 Note 一个程序在执行时除需要存储空间来存放本身的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。 算法原地工作: 是指算法所需的辅助空间为常量, 即$O(1)$ 此插入排序算法的辅助空间为常量，即其空间复杂度为$O(1)$ ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:2","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"参考文章 插入排序 | 菜鸟教程 ","date":"2021-01-06","objectID":"/posts/insertionsort/:5:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"选择排序 ","date":"2021-01-05","objectID":"/posts/selectionsort/:1:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"C语言实现 #include \u003cstdio.h\u003e void print_list(int arr[], int len); void selection_sort(int arr[], int len); void swap(int *a, int *b); void selection_sort(int arr[], int len) { int i, j; printf(\"初始list:\"); print_list(arr, len); printf(\"\\n\"); int k = 1; for(i=0; i\u003clen -1; i++) { int min = i; for(j = i + 1; j \u003c len; j++) if (arr[j] \u003c arr[min]) min = j; swap(\u0026arr[min], \u0026arr[i]); printf(\"第%d次交换后的list:\", k); print_list(arr, len); printf(\"\\n\"); k+=1; } } void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } void print_list(int arr[], int len) { int i; for (i=0; i\u003c len; i++) printf(\"%d \", arr[i]); } int main() { int arr[] = { 22, 34, 3, 4, 5, 9}; int len = (int) sizeof(arr) / sizeof(*arr); selection_sort(arr, len); return 0; } Note 前面的元素与后面的元素一一对比, 若后面的元素小，将最小元素的的序号替换成它, 最后前的元素的值与最小序号所对的值替换 即只需要选择n-1个前元素即可（0 -\u003e len - 2），同时需要与后面的所有元素对比(0 -\u003e len - 1) 一次循环结束后确定了最小元素才互换，不是一得到一个较小的元素就互换 ","date":"2021-01-05","objectID":"/posts/selectionsort/:2:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"时间复杂度与空间复杂度分析 ","date":"2021-01-05","objectID":"/posts/selectionsort/:3:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"时间复杂度 第一次内循环(1 -\u003e len - 1), N - 1次 第二次内循环(2 -\u003e len - 1), N - 2次 第三次内循环(3 -\u003e len - 1), N - 3次 第后一次内循环(len - 2 -\u003e len - 1), 1次 比较的次数是(N - 1) + (N - 2) + ... + 1 , 其和是 $\\frac{N(N-1)}{2}$ 所以其时间复杂度是$O(N^2)$ ","date":"2021-01-05","objectID":"/posts/selectionsort/:3:1","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"空间复杂度 O(1) ","date":"2021-01-05","objectID":"/posts/selectionsort/:3:2","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"参考文章 选择排序 ","date":"2021-01-05","objectID":"/posts/selectionsort/:4:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"冒泡排序 ","date":"2021-01-04","objectID":"/posts/bubblesort/:1:0","tags":["algorithm"],"title":"BubbleSort","uri":"/posts/bubblesort/"},{"categories":["数据结构"],"content":"C语言实现 #include \u003cstdio.h\u003e void print_list(int arr[], int len); void bubble_sort(int arr[], int len); void bubble_sort(int arr[], int len) { int i, j, temp; printf(\"初始list为:\"); print_list(arr, len); printf(\"\\n\"); int k = 1; for(i = 0; i \u003c len - 1; i++) for (j = 0; j \u003c len - 1 - i; j++) if (arr[j] \u003e arr[j + 1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; printf(\"第%d次替换后的list : \", k); print_list(arr, len); printf(\"\\n\"); k+=1; } } void print_list(int arr[], int len) { int i; for (i=0; i\u003c len; i++) printf(\"%d \", arr[i]); } int main() { int arr[] = { 22, 34, 3, 4}; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); return 0; } 次数 list 状态 解释 i j 是否有移动 0 22 34 3 4 初始化 0 0 1 22 34 3 4 22(前)与34(后)比较, 22小, 不移动, j+1 0 0-\u003e1 2 22 3 34 4 34(前)与3(后)比较, 3小, 移至前面, j+1 0 1-\u003e2 * 3 22 3 4 34 34(前)与4(后)比较, 4小, 移至前面，j+1(此时j+1后=len - 1 - i), 跳出当前循环，i+1, j变为0 0-\u003e1 2-\u003e3-\u003e0 * 4 3 22 4 34 22(前)与3(后)比较，3小, 移至前面，j+1 1 0-\u003e1 * 5 3 4 22 34 22(前)与4(后)比较，4小, 移至前面，j+1(此时j+1后=len - 1 - i), 跳出当前循环, i+1, j变为0 1-\u003e2 1-\u003e2-\u003e0 * 6 3 4 22 34 3(前)与4(后), 3小，不移动, j+1, (此时j+1=len - 1 - i), 跳出当前循环， i+1 (此时i=len -1)退出上层循环 2-\u003e3 0-\u003e1 ","date":"2021-01-04","objectID":"/posts/bubblesort/:2:0","tags":["algorithm"],"title":"BubbleSort","uri":"/posts/bubblesort/"},{"categories":["数据结构"],"content":"标准冒泡排序时间复杂度与空间复杂度分析 ","date":"2021-01-04","objectID":"/posts/bubblesort/:3:0","tags":["algorithm"],"title":"BubbleSort","uri":"/posts/bubblesort/"},{"categories":["数据结构"],"content":"时间复杂度 void bubble_sort(int arr[], int len) { int i, j, temp; for(i = 0; i \u003c len - 1; i++) for (j = 0; j \u003c len -1 -i; j++) if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; } } 语句 cost times int i, j, temp $C_1$ 1 i \u003c len - 1 $C_2$ n(n次判断) i++ $C_3$ n - 1(不满足条件不加) j=0 $C_4$ i++只会执行n-1次，即j=0执行n-1次 j \u003c len - 1 - i $C_5$ $t_1$(i=0) + $t_1$(i=1) + … + $t_1$(i = n-2) + $t_1$(i = n-1), 最多执行n-1次 j++ $C_6$ $t_2$(i=0) + $t_2$(i=1) + … + $t_2$(i = n-2) + $t_2$(i = n-1) arr[j + 1] \u003c arr[j] $C_7$ $t_3$(i=0) + $t_3$(i=1) + … + $t_3$(i = n-2) + $t_3$(i = n-1) swap(arr, j, j+1) $C_8$ $t_4$(i=0) + $t_4$(i=1) + … + $t_4$(i = n-2) + $t_4$(i = n-1) 算法总的运行时间是第一条语句执行时间之和。如果执行一条语句需要c_i步，又共执行了n次这条语句。那么它在运行时间中占cin为计算总运行时间T[n], 对第一对cost与times这积求和。 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-2)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-2)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-2)] + c8[t4(i=0) + t4(i=1) + … + t4(i=n-2)]] 最优时间复杂度 第8步，不执行 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-1)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-1)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-1)] 即可T(n) = O(n^2) 最坏时间复杂度 第8步，均执行 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-2)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-2)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-2)] + c8[t4(i=0) + t4(i=1) + … + t4(i=n-2)]] 即可T(n) = O(n^2) ","date":"2021-01-04","objectID":"/posts/bubblesort/:3:1","tags":["algorithm"],"title":"BubbleSort","uri":"/posts/bubblesort/"},{"categories":["数据结构"],"content":"冒泡排序优化 在内部循环的时候，一次交换都没有发生时，直接退出循环即可 void bubble_sort(int arr[], int len) { int i, j, temp; int flag = 0; for(i = 0; i \u003c len - 1; i++){ for (j = 0; j \u003c len - 1 - i; j++) if (arr[j] \u003e arr[j + 1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; flag = 1; } if(flag == 0) return; } } 此时最优时间复杂度 T(n) = O(n), 外部只执行1次， 内部执行 T(n) = C1 + C2 + C3 + C4(n - 1) + C5(n - 1) + c6(n - 1) ","date":"2021-01-04","objectID":"/posts/bubblesort/:4:0","tags":["algorithm"],"title":"BubbleSort","uri":"/posts/bubblesort/"},{"categories":["数据结构"],"content":"参考 Bubble Sort 冒泡排序 ","date":"2021-01-04","objectID":"/posts/bubblesort/:5:0","tags":["algorithm"],"title":"BubbleSort","uri":"/posts/bubblesort/"},{"categories":["docker"],"content":"Docker 三大基本概念 镜像(Image) 容器(Container) 仓库(Repository) ","date":"2021-01-02","objectID":"/posts/docker/:1:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"安装Docker(Debian) ","date":"2021-01-02","objectID":"/posts/docker/:2:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"镜像 ","date":"2021-01-02","objectID":"/posts/docker/:3:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"获取镜像 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址 默认地址是 Docker Hub(docker.io) 仓库名 \u003c用户名\u003e/\u003c软件名\u003e 对于Docker Hub, 不给出用户名，默认为library, 即官方镜像 比如: docker pull mquandalle/wekan docker pull debian //不给出用户名，使用用官方镜像 docker pull ubuntu:14.04 //使用官方镜像中版本号为14.04的ubuntu Tip Docker是采取分层存储的概念, 镜像是由多层存储所构成。下载也是一层层去下载，并非单一文件。 ","date":"2021-01-02","objectID":"/posts/docker/:3:1","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"运行镜像 $ docker run -it --rm ubuntu:14.04 参数说明： -it: -i:交互式操作 -t: 表示终端 --rm: 表示容器退出后随之将其删除 ","date":"2021-01-02","objectID":"/posts/docker/:3:2","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"列出镜像 $ docker image ls Tip Docker Hub中显示的体积与docker image ls显示的镜像大小不同 Docker Hub中显示的体积是压缩后的体积，在镜像下载和上传的过程中镜像是保持着压缩状态的，在网络传输过程中，关心的是流量大小 docker image ls列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会使用相同的基础镜像，从而拥有共同的层。相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能比这个列表镜像大小的总和要小的多。 $ docker system df 可以查看镜像、容器、数据卷所占用的空间 ","date":"2021-01-02","objectID":"/posts/docker/:3:3","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"删除镜像 $ docker image rm [选项] \u003c镜像1\u003e [\u003c镜像2\u003e] \u003c镜像\u003e 可以是ID, 镜像名或镜像摘要 ID: 一般取前3个字符以上，只要足够区分别的镜像就可以了 如： docker image rm df0 镜像名: \u003c仓库名\u003e:\u003c标签\u003e 如： docker image rm mongo:latest 镜像摘要 $ docker image ls --digests ","date":"2021-01-02","objectID":"/posts/docker/:3:4","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["git"],"content":"为什么需要转换SHH地址和HTTPS? SSH地址在push, pull时均不需要输入账号密码 ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:1:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"SHH地址的特征 git@远程仓库域名:用户名/仓库名.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:2:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"HTTPS地址的特征 https://远程仓库域名/用户名/仓库名.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:3:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"HTTPS地址向git地址转化 修改项目的.git -\u003e config url = git@github.com:guangsizhongbin/Blog.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:4:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"参考 Github SSH地址和HTTPS地址的相互转换 ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:5:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["hugo"],"content":"系统版本 root@vultr:~# hostnamectl Static hostname: vultr.guest Icon name: computer-vm Chassis: vm Machine ID: 014b2aed70f7e09db32693a85feeb49a Boot ID: fe9876f6146f4fb4a3187f09d94f5ab3 Virtualization: kvm Operating System: Debian GNU/Linux 9 (stretch) Kernel: Linux 4.9.0-14-amd64 Architecture: x86-64 我使用的是Debian 9 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:1:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"安装宝塔 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 bash install.sh ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:2:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"上传Hugo源文件至Github 不需要上传public中的文件 Note 不跟踪某个public文件夹(git status不再提醒) 修改 .gitignore 加入 public/ 对public文件夹取消跟踪 git rm -r –cached public 删除public文件夹的跟踪，并保留在本地 git rm -r –f public 删除public文件夹的跟踪，并且删除本地文件 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:3:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"Github Actions构建Hugo并用WebHook回调 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"生成Access token 个人的Settings -\u003e Developer settings -\u003e Personal access tokens -\u003e Generate new token -\u003e Generate token 保存好获取到的 access token, 它只会出现一次 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:1","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"添加Access Token到项目 项目Secrets -\u003e New repository secret -\u003e Add secret ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:2","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"宝塔安装WebHook 宝塔 -\u003e 应用搜索 -\u003e webhook ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:3","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"设置脚本 #!/bin/bash echo \"\" date --date='0 days ago' \"+%Y-%m-%d %H:%M:%S\" echo \"Start\" gitPath=\"/www/wwwroot/fengqigang.cn\" gitHttp=\"https://github.com/guangsizhongbin/Blog.git\" echo \"Web站点路径:$gitPath\" if [ -d \"$gitPath\" ]; then cd $gitPath if [ ! -d \".git\" ]; then echo \"在该目录下克隆 git\" git clone -b gh-pages $gitHttp gittemp mv gittemp/.git . rm -rf gittemp fi git reset --hard gh-pages git pull chown -R www:www $gitPath echo \"End\" exit else echo \"该项目路径不存在\" echo \"End\" exit fi Note date agruments --date=STRING display time described by STRING, not 'now' // 显示当前时间 $ date --date=\"0 days ago\" Sun Jan 3 10:54:04 AM CST 2021 // 显示2天之后的时间 $ date --date=\"2 days\" Tue Jan 5 10:55:14 AM CST 2021 // 显示2个星期之后的时间 $ date --date=\"2 weeks\" Sun Jan 17 10:55:22 AM CST 2021 +%Y-%m-%d %H:%M:%S %Y year %m month (01..12) %d day of month (e.g., 01) %H hour (00..23) %M minute (00..59) %S second (00..60) day of month 和 month 都是小写 // 显示当前时间 $ date '+%Y-%m-%d %H:%M:%S' 2021-01-03 11:07:00 // 显示当前时间 $ date --date=\"0 days ago\" '+%Y-%m-%d %H:%M:%S' 2021-01-03 11:08:47 git arguments -b \u003cname\u003e Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository's HEAD, point to \u003cname\u003e brach instead. git reset --hard gh-pages Restes the index and working tree. Any changes to tracked files in the working tree since \u003ccommit\u003e are discarded. 退回到远程仓库中的版本 项目Actions -\u003e Set up a workflow yourself -\u003e 添加代码 -\u003e Start commit name: Deploy Hugo # 自己命名即可 on: # 设置触发条件 push: branches: - master # master 分支被更新时触发 job: # 设置触发时间 build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v1 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest - name: Build run: hugo - name: Deploy uses: peaceiris/action-gh-pages@v3 with: personal_token: ${{ secrets.personal_token}} PUBLISH_BRANCH: gh-pages # 推送至分支名称 PUBLISH_DIR: ./public # 将hugo 生成的 public 作为根目录 comit_message: ${{ github.event.head_commit.message }} ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:4","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"将秘钥添加至项目中的Secrets 项目的Setting -\u003e Secrets ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:5","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"添加Github Actions workflow 事件 - name: Webhook uses: distributhor/workflow-webhoob@v1 env: webhook_url: ${{ secrets.WEBHOOK_URL }}$ webhook_secret: ${{ secrets.WEBHOOK_SECRET }}$ ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:6","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"参考 Hugo + Github Actions 实现自动化部署 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:5:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["git"],"content":"使用git协议克隆的好处 配置完后，每次提交均不需要输入账号密码 ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:1:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"},{"categories":["git"],"content":"如何配置 创建一个SSH Key $ ssh-keygen -t rsa -C \"guangsizhongbin@gmail.com\" 参数含义： -t Specifies the type of key to create. -C Provides a new comment. Enter file in which to save the key (/home/feng/.ssh/id_rsa): 参数含义： -f filename Specifies the filename of the key file. 指定生成文件的文件名（文件路径，否则会直接生成在当前目录下） 例如: ssh-keygen -t rsa -C \"guangsizhongbin@gmail.com\" -f a 会在当前路径下生成私钥a, 公钥a.pub Enter passphrase (empty for no passphrase): Enter same passphrase again: passphrase: a sequence of words used to gain access to a computer system 填写push文件时需要输入的密码 将公钥id_ras.pub传至github中（默认路径.ssh/id_ras.pub） bash: cat .ssh/id_rsa.pub github: Repositories -\u003e Settings -\u003e Deploy keys -\u003e Add deploy key -\u003e Add key 若要有push权限必须要勾选Allow write access, 否则只有read 权限 测试SSH key ssh -T git@github.com The authenticity of host 'github.com (192.30.255.112)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,192.30.255.112' (RSA) to the list of known hosts. Enter passphrase for key '/home/feng/.ssh/id_rsa': 输入创建SSH key的时候设置的密码(若有设置) Hi guangsizhongbin/Blog! You've successfully authenticated, but GitHub does not provide shell access. 此时已经设置成功了 使用git协议进行克隆 git clone git clone git@github.com:guangsizhongbin/Blog.git Cloning into 'Blog'... Enter passphrase for key '/home/feng/.ssh/id_rsa': 输入创建SSH key的时候设置的密码(若有设置) ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:2:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"},{"categories":["git"],"content":"参考文章 1. github设置添加SSH ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:3:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"}]