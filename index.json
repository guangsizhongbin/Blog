[{"categories":["数据结构"],"content":"ShellSort Shell 排序动图 Tip 14\u003e\u003e2 如何计算？ \u003e\u003e为右移运算符 14 的二进制为(0000 1110) 正数向右移动，低位舍弃，高位补零 移动之后的二进制为(0000 0011), 为3 #include \u003cstdio.h\u003e int main(void) { int number = 14 \u003e\u003e 2; printf(\"右移二位后的值为: %d \", number); } gap = len \u003e\u003e 1 是什么意思？ 表示 gap = len 不断的对半分 ","date":"2021-01-07","objectID":"/posts/shellsort/:1:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"ShellSort C语言实现 #include \u003cstdio.h\u003e void print_list(int arr[], int len); void shell_sort(int arr[], int len) { int gap, i, j; int temp; int k = 1; for (gap = len \u003e\u003e 1; gap \u003e 0; gap \u003e\u003e= 1){ printf(\"gap 为%d时: \\n\", gap); for (i = gap; i\u003clen; i++) { temp = arr[i]; for(j = i-gap; j\u003e=0 \u0026\u0026 arr[j] \u003e temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; printf(\"第%d次list: \", k); print_list(arr,len); k+=1; printf(\"\\n\"); } } } void print_list(int arr[], int len) { for(int i=0;i\u003clen;i++) printf(\"%d \", arr[i]); } int main (void) { int arr[] = {3, 21, 412, 1, 4,39, 123, 6}; int len = (int) sizeof(arr) /sizeof (*arr); printf(\"初始list: \"); print_list(arr,len); printf(\"\\n\"); shell_sort(arr,len); printf(\"最终list: \"); print_list(arr,len); printf(\"\\n\"); } gap = 4 gap = 2 gap = 1 ","date":"2021-01-07","objectID":"/posts/shellsort/:2:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"Shell 排序复杂度和稳定性分析 啥是序偶(Ordered pair)? 序: 就是有序的意思 偶: 一对儿 证明N个互异的数组的平均逆序数是$N(N-1)/4$ 表$L$: 34, 8, 64, 51, 32, 21 其反序表$L_r$: 21, 32, 51, 64, 8, 34 该表中任意两个数的序偶$(x, y)$, 且$y \u003e x$, 显然在$L$与$L_r$中，在表L和它的反序表$L_r$中的序偶的总个数为$C_N^2=N(N-1)/2$, 因此，平均每个表的逆序是$N(N-1)/4$ 证明通过交换相邻元素进行排序的任何平均需要$\\Omega(N^2)$ 已知初始的平均逆序数$N(N - 1)/4 = \\Omega(N^2)$, 而每次交换只减少一个逆序，因此需要$\\Omega(N^2)$交换 ","date":"2021-01-07","objectID":"/posts/shellsort/:3:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"时间复杂度 为啥希尔排序的时间复杂度可以突破$O(N^2)$? 证明以希尔增量时希尔排序的最坏情形为$O(N^2)$ 啥是希尔增量? 希尔排序使用一个序列$h_1, h_2, … h_t$, 叫做增量序列 希尔增量：$h_t = \\lfloor N/2 \\rfloor$ $h_k = \\lfloor h_{k+1} \\rfloor$ 相隔 $h_k$个元素都被排序，此时称文件是$h_k$排序 以Hibbard增量的希尔排序的最坏情形为$O( N^\\frac{3}{2})$ 啥是Hibbard增量？ $1, 3, 7, …, 2^k - 1$ ","date":"2021-01-07","objectID":"/posts/shellsort/:3:1","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"空间复杂度 $O(1)$ ","date":"2021-01-07","objectID":"/posts/shellsort/:3:2","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"稳定性 Tip 在一个数组中，存在相同的数，经过排序后，这些数的相对次序保持不变，即原来数组中r[i] = r[j], r[i] 在r[j] 之前，经过排序后，r[i]仍在r[j]之前， 则称这种排序算法是稳定的，否则称为不稳定的。 序列： 3 5 10 $8_1$ 7 2 $8_2$ 1 20 6 对于gap=5时 (3, 2), (5, $8_2$), (10, 1), ($8_1$, 20), (7, 6) 排序后(2, 3), (5, $8_2$), (1, 10), ($8_1$, 20), (7, 6) 2 5 1 $8_1$ 7 3 $8_2$ 10 20 6 对于gap=2时，向下取整 (2, 1, 7, $8_2$, 20), (5, $8_1$, 3, 10, 6) 排序后 (1, 2, 7, $8_2$, 20), (3, 5, 6, $8_1$, 10) 1, 3, 2, 5, 7, 6, $8_2$, $8_1$, 20, 10 此时$8_2$已经跑到$8_1$之前，表示Shell排序不稳定 ","date":"2021-01-07","objectID":"/posts/shellsort/:3:3","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"如何用C语言实现Hibbard增量的Shell排序? 为什么要从希尔增量变成Hibbard增量？ 在希尔增量的情况下: 间隔为8时，分为8组 (1, 5), (9, 13), (2, 6), (10, 14), (3, 7), (11, 15), (4, 8), (12, 16) 间隔为4时，分为4组 (1, 3, 5, 7), (9, 11, 13, 15), (2, 4, 6, 8), (10, 12, 14, 16) 间隔为2时，分为2组 (1, 2, 3, 4, 5, 6, 7, 8), (9, 10, 11, 12, 13, 14, 15, 16) 间隔为1时，分为1组 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16) 前3个增量没有起任何作用 啥是一个好的增量？ 最后一个增量必须为1 避免序列中的值(尤其是相邻的值)互为倍数的情况 ","date":"2021-01-07","objectID":"/posts/shellsort/:4:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"参考文章 数据结构与算法——希尔排序 希尔排序增量序列简介 希尔排序为什么会那么牛那么快，能够证明吗？ ","date":"2021-01-07","objectID":"/posts/shellsort/:5:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"插入排序 ","date":"2021-01-06","objectID":"/posts/insertionsort/:1:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"插入排序的特征 1.从第二个元素(比较元素)开始一一与前面元素(被比较元素)比较, 若当前元素小于被比较元素，被比较元素后移，直到比较元素比被比较元素大或等于时，比较元素插入到被比较元素的位置 比较元素位置: 从第二个元素到最后一个(n-1个) 被比较元素位置: 从第一个到比较元素位置-1, 考虑从比较元素位置依次递减，满足\u003e=0即可. 即用while 这里一直用的arr[j+1] = arr[j], 采取前面元素覆盖后面元素的方式，当满足条件时，arr[j+1]才等于key ","date":"2021-01-06","objectID":"/posts/insertionsort/:2:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"C语言实现 #include\u003cstdio.h\u003e void insertion_sort(int arr[], int len); void print_list(int arr[], int len); void insertion_sort(int arr[], int len) { int i, j, key; int k=1; for(i=1; i\u003clen; i++) { key = arr[i]; j=i-1; while((j\u003e=0) \u0026\u0026 (arr[j]\u003ekey)){ arr[j+1] = arr[j]; j--; } arr[j+1] = key; printf(\"第%d次list:\", k); print_list(arr, len); printf(\"\\n\"); k+=1; } } void print_list(int arr[], int len) { int i; for(i=0; i\u003clen; i++) printf(\"%d \", arr[i]); } int main(void) { int arr[] = {22, 34, 321, 32, 1, 5, 23}; int len = (int) sizeof(arr) / sizeof(*arr); printf(\"初始list:\"); print_list(arr, len); printf(\"\\n\"); insertion_sort(arr, len); printf(\"最终list:\"); print_list(arr, len); return 0; } ","date":"2021-01-06","objectID":"/posts/insertionsort/:3:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"复杂度分析 ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"时间复杂度 最坏时间复杂度 在数组完全逆序的情况下: 插入第2个元素时，考虑对比1个元素 插入第3个元素时，考虑对比2个元素 插入第n个元素时，考虑对比n-1个元素 最坏情况下的比较次数是:$1+2+…+n-1=\\frac{(n-1)n}{2}$ 所以其时间复杂度是: $O(n^2)$ 最优时间复杂度 在数组完全正序的情况下: 插入第2个元素时，考虑对比1个元素 插入第3个元素时，考虑对比1个元素 插入第n个元素时，考虑对比1个元素 最好情况下的比较次数是: $1+1+…+1=n$ 所以其时间复杂度是: $O(n)$ ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:1","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"空间复杂度 Note 一个程序在执行时除需要存储空间来存放本身的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。 算法原地工作: 是指算法所需的辅助空间为常量, 即$O(1)$ 此插入排序算法的辅助空间为常量，即其空间复杂度为$O(1)$ ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:2","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"参考文章 插入排序 | 菜鸟教程 ","date":"2021-01-06","objectID":"/posts/insertionsort/:5:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"选择排序 ","date":"2021-01-05","objectID":"/posts/selectionsort/:1:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"C语言实现 #include \u003cstdio.h\u003e void swap(int *a, int *b) void selection_sort(int arr[], int len) void selection_sort(int arr[], int len) { int i, j; for(i=0; i\u003clen -1; i++) { int min = i; for(j = i+1; j \u003c len; j++) if (arr[j] \u003c arr[min]) min = j; swap(\u0026arr[min], \u0026arr[i]); } } Note 前面的元素与后面的元素一一对比, 若后面的元素小，将最小元素的的序号替换成它, 最后前的元素的值与最小序号所对的值替换 即只需要选择n-1个前元素即可（0 -\u003e len - 2），同时需要与后面的所有元素对比(0 -\u003e len - 1) 一次循环结束后确定了最小元素才互换，不是一得到一个较小的元素就互换 ","date":"2021-01-05","objectID":"/posts/selectionsort/:2:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"冒泡排序 ","date":"2021-01-04","objectID":"/posts/bubble_sort/:1:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"C语言实现 #include \u003cstdio.h\u003e void print_list(int arr[], int len); void bubble_sort(int arr[], int len); void bubble_sort(int arr[], int len) { int i, j, temp; printf(\"初始list为:\"); print_list(arr, len); printf(\"\\n\"); int k = 1; for(i = 0; i \u003c len - 1; i++) for (j = 0; j \u003c len - 1 - i; j++) if (arr[j] \u003e arr[j + 1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; printf(\"第%d次替换后的list : \", k); print_list(arr, len); printf(\"\\n\"); k+=1; } } void print_list(int arr[], int len) { int i; for (i=0; i\u003c len; i++) printf(\"%d \", arr[i]); } int main() { int arr[] = { 22, 34, 3, 4}; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); return 0; } 次数 list 状态 解释 i j 是否有移动 0 22 34 3 4 初始化 0 0 1 22 34 3 4 22(前)与34(后)比较, 22小, 不移动, j+1 0 0-\u003e1 2 22 3 34 4 34(前)与3(后)比较, 3小, 移至前面, j+1 0 1-\u003e2 * 3 22 3 4 34 34(前)与4(后)比较, 4小, 移至前面，j+1(此时j+1后=len - 1 - i), 跳出当前循环，i+1, j变为0 0-\u003e1 2-\u003e3-\u003e0 * 4 3 22 4 34 22(前)与3(后)比较，3小, 移至前面，j+1 1 0-\u003e1 * 5 3 4 22 34 22(前)与4(后)比较，4小, 移至前面，j+1(此时j+1后=len - 1 - i), 跳出当前循环, i+1, j变为0 1-\u003e2 1-\u003e2-\u003e0 * 6 3 4 22 34 3(前)与4(后), 3小，不移动, j+1, (此时j+1=len - 1 - i), 跳出当前循环， i+1 (此时i=len -1)退出上层循环 2-\u003e3 0-\u003e1 ","date":"2021-01-04","objectID":"/posts/bubble_sort/:2:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"标准冒泡排序时间复杂度与空间复杂度分析 ","date":"2021-01-04","objectID":"/posts/bubble_sort/:3:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"时间复杂度 void bubble_sort(int arr[], int len) { int i, j, temp; for(i = 0; i \u003c len - 1; i++) for (j = 0; j \u003c len -1 -i; j++) if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; } } 语句 cost times int i, j, temp $C_1$ 1 i \u003c len - 1 $C_2$ n(n次判断) i++ $C_3$ n - 1(不满足条件不加) j=0 $C_4$ i++只会执行n-1次，即j=0执行n-1次 j \u003c len - 1 - i $C_5$ $t_1$(i=0) + $t_1$(i=1) + … + $t_1$(i = n-2) + $t_1$(i = n-1), 最多执行n-1次 j++ $C_6$ $t_2$(i=0) + $t_2$(i=1) + … + $t_2$(i = n-2) + $t_2$(i = n-1) arr[j + 1] \u003c arr[j] $C_7$ $t_3$(i=0) + $t_3$(i=1) + … + $t_3$(i = n-2) + $t_3$(i = n-1) swap(arr, j, j+1) $C_8$ $t_4$(i=0) + $t_4$(i=1) + … + $t_4$(i = n-2) + $t_4$(i = n-1) 算法总的运行时间是第一条语句执行时间之和。如果执行一条语句需要c_i步，又共执行了n次这条语句。那么它在运行时间中占cin为计算总运行时间T[n], 对第一对cost与times这积求和。 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-2)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-2)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-2)] + c8[t4(i=0) + t4(i=1) + … + t4(i=n-2)]] 最优时间复杂度 第8步，不执行 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-1)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-1)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-1)] 即可T(n) = O(n^2) 最坏时间复杂度 第8步，均执行 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-2)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-2)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-2)] + c8[t4(i=0) + t4(i=1) + … + t4(i=n-2)]] 即可T(n) = O(n^2) ","date":"2021-01-04","objectID":"/posts/bubble_sort/:3:1","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"冒泡排序优化 在内部循环的时候，一次交换都没有发生时，直接退出循环即可 void bubble_sort(int arr[], int len) { int i, j, temp; int flag = 0; for(i = 0; i \u003c len - 1; i++){ for (j = 0; j \u003c len - 1 - i; j++) if (arr[j] \u003e arr[j + 1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; flag = 1; } if(flag == 0) return; } } 此时最优时间复杂度 T(n) = O(n), 外部只执行1次， 内部执行 T(n) = C1 + C2 + C3 + C4(n - 1) + C5(n - 1) + c6(n - 1) ","date":"2021-01-04","objectID":"/posts/bubble_sort/:4:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"参考 Bubble Sort 冒泡排序 ","date":"2021-01-04","objectID":"/posts/bubble_sort/:5:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["docker"],"content":"Docker 三大基本概念 镜像(Image) 容器(Container) 仓库(Repository) ","date":"2021-01-02","objectID":"/posts/docker/:1:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"安装Docker(Debian) ","date":"2021-01-02","objectID":"/posts/docker/:2:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"镜像 ","date":"2021-01-02","objectID":"/posts/docker/:3:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"获取镜像 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址 默认地址是 Docker Hub(docker.io) 仓库名 \u003c用户名\u003e/\u003c软件名\u003e 对于Docker Hub, 不给出用户名，默认为library, 即官方镜像 比如: docker pull mquandalle/wekan docker pull debian //不给出用户名，使用用官方镜像 docker pull ubuntu:14.04 //使用官方镜像中版本号为14.04的ubuntu Tip Docker是采取分层存储的概念, 镜像是由多层存储所构成。下载也是一层层去下载，并非单一文件。 ","date":"2021-01-02","objectID":"/posts/docker/:3:1","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"运行镜像 $ docker run -it --rm ubuntu:14.04 参数说明： -it: -i:交互式操作 -t: 表示终端 --rm: 表示容器退出后随之将其删除 ","date":"2021-01-02","objectID":"/posts/docker/:3:2","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"列出镜像 $ docker image ls Tip Docker Hub中显示的体积与docker image ls显示的镜像大小不同 Docker Hub中显示的体积是压缩后的体积，在镜像下载和上传的过程中镜像是保持着压缩状态的，在网络传输过程中，关心的是流量大小 docker image ls列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会使用相同的基础镜像，从而拥有共同的层。相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能比这个列表镜像大小的总和要小的多。 $ docker system df 可以查看镜像、容器、数据卷所占用的空间 ","date":"2021-01-02","objectID":"/posts/docker/:3:3","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"删除镜像 $ docker image rm [选项] \u003c镜像1\u003e [\u003c镜像2\u003e] \u003c镜像\u003e 可以是ID, 镜像名或镜像摘要 ID: 一般取前3个字符以上，只要足够区分别的镜像就可以了 如： docker image rm df0 镜像名: \u003c仓库名\u003e:\u003c标签\u003e 如： docker image rm mongo:latest 镜像摘要 $ docker image ls --digests ","date":"2021-01-02","objectID":"/posts/docker/:3:4","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["git"],"content":"为什么需要转换SHH地址和HTTPS? SSH地址在push, pull时均不需要输入账号密码 ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:1:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"SHH地址的特征 git@远程仓库域名:用户名/仓库名.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:2:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"HTTPS地址的特征 https://远程仓库域名/用户名/仓库名.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:3:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"HTTPS地址向git地址转化 修改项目的.git -\u003e config url = git@github.com:guangsizhongbin/Blog.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:4:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"参考 Github SSH地址和HTTPS地址的相互转换 ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:5:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["hugo"],"content":"系统版本 root@vultr:~# hostnamectl Static hostname: vultr.guest Icon name: computer-vm Chassis: vm Machine ID: 014b2aed70f7e09db32693a85feeb49a Boot ID: fe9876f6146f4fb4a3187f09d94f5ab3 Virtualization: kvm Operating System: Debian GNU/Linux 9 (stretch) Kernel: Linux 4.9.0-14-amd64 Architecture: x86-64 我使用的是Debian 9 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:1:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"安装宝塔 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 bash install.sh ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:2:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"上传Hugo源文件至Github 不需要上传public中的文件 Note 不跟踪某个public文件夹(git status不再提醒) 修改 .gitignore 加入 public/ 对public文件夹取消跟踪 git rm -r –cached public 删除public文件夹的跟踪，并保留在本地 git rm -r –f public 删除public文件夹的跟踪，并且删除本地文件 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:3:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"Github Actions构建Hugo并用WebHook回调 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"生成Access token 个人的Settings -\u003e Developer settings -\u003e Personal access tokens -\u003e Generate new token -\u003e Generate token 保存好获取到的 access token, 它只会出现一次 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:1","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"添加Access Token到项目 项目Secrets -\u003e New repository secret -\u003e Add secret ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:2","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"宝塔安装WebHook 宝塔 -\u003e 应用搜索 -\u003e webhook ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:3","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"设置脚本 #!/bin/bash echo \"\" date --date='0 days ago' \"+%Y-%m-%d %H:%M:%S\" echo \"Start\" gitPath=\"/www/wwwroot/fengqigang.cn\" gitHttp=\"https://github.com/guangsizhongbin/Blog.git\" echo \"Web站点路径:$gitPath\" if [ -d \"$gitPath\" ]; then cd $gitPath if [ ! -d \".git\" ]; then echo \"在该目录下克隆 git\" git clone -b gh-pages $gitHttp gittemp mv gittemp/.git . rm -rf gittemp fi git reset --hard gh-papes git pull chown -R www:www $gitPath echo \"End\" exit else echo \"该项目路径不存在\" echo \"End\" exit fi Note date agruments --date=STRING display time described by STRING, not 'now' // 显示当前时间 $ date --date=\"0 days ago\" Sun Jan 3 10:54:04 AM CST 2021 // 显示2天之后的时间 $ date --date=\"2 days\" Tue Jan 5 10:55:14 AM CST 2021 // 显示2个星期之后的时间 $ date --date=\"2 weeks\" Sun Jan 17 10:55:22 AM CST 2021 +%Y-%m-%d %H:%M:%S %Y year %m month (01..12) %d day of month (e.g., 01) %H hour (00..23) %M minute (00..59) %S second (00..60) day of month 和 month 都是小写 // 显示当前时间 $ date '+%Y-%m-%d %H:%M:%S' 2021-01-03 11:07:00 // 显示当前时间 $ date --date=\"0 days ago\" '+%Y-%m-%d %H:%M:%S' 2021-01-03 11:08:47 git arguments -b \u003cname\u003e Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository's HEAD, point to \u003cname\u003e brach instead. git reset --hard gh-pages Restes the index and working tree. Any changes to tracked files in the working tree since \u003ccommit\u003e are discarded. 退回到远程仓库中的版本 项目Actions -\u003e Set up a workflow yourself -\u003e 添加代码 -\u003e Start commit name: Deploy Hugo # 自己命名即可 on: # 设置触发条件 push: branches: - master # master 分支被更新时触发 job: # 设置触发时间 build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v1 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest - name: Build run: hugo - name: Deploy uses: peaceiris/action-gh-pages@v3 with: personal_token: ${{ secrets.personal_token}} PUBLISH_BRANCH: gh-pages # 推送至分支名称 PUBLISH_DIR: ./public # 将hugo 生成的 public 作为根目录 comit_message: ${{ github.event.head_commit.message }} ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:4","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"将秘钥添加至项目中的Secrets 项目的Setting -\u003e Secrets ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:5","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"添加Github Actions workflow 事件 - name: Webhook uses: distributhor/workflow-webhoob@v1 env: webhook_url: ${{ secrets.WEBHOOK_URL }}$ webhook_secret: ${{ secrets.WEBHOOK_SECRET }}$ ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:6","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"参考 Hugo + Github Actions 实现自动化部署 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:5:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["git"],"content":"使用git协议克隆的好处 配置完后，每次提交均不需要输入账号密码 ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:1:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"},{"categories":["git"],"content":"如何配置 创建一个SSH Key $ ssh-keygen -t rsa -C \"guangsizhongbin@gmail.com\" 参数含义： -t Specifies the type of key to create. -C Provides a new comment. Enter file in which to save the key (/home/feng/.ssh/id_rsa): 参数含义： -f filename Specifies the filename of the key file. 指定生成文件的文件名（文件路径，否则会直接生成在当前目录下） 例如: ssh-keygen -t rsa -C \"guangsizhongbin@gmail.com\" -f a 会在当前路径下生成私钥a, 公钥a.pub Enter passphrase (empty for no passphrase): Enter same passphrase again: passphrase: a sequence of words used to gain access to a computer system 填写push文件时需要输入的密码 将公钥id_ras.pub传至github中（默认路径.ssh/id_ras.pub） bash: cat .ssh/id_rsa.pub github: Repositories -\u003e Settings -\u003e Deploy keys -\u003e Add deploy key -\u003e Add key 若要有push权限必须要勾选Allow write access, 否则只有read 权限 测试SSH key ssh -T git@github.com The authenticity of host 'github.com (192.30.255.112)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,192.30.255.112' (RSA) to the list of known hosts. Enter passphrase for key '/home/feng/.ssh/id_rsa': 输入创建SSH key的时候设置的密码(若有设置) Hi guangsizhongbin/Blog! You've successfully authenticated, but GitHub does not provide shell access. 此时已经设置成功了 使用git协议进行克隆 git clone git clone git@github.com:guangsizhongbin/Blog.git Cloning into 'Blog'... Enter passphrase for key '/home/feng/.ssh/id_rsa': 输入创建SSH key的时候设置的密码(若有设置) ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:2:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"},{"categories":["git"],"content":"参考文章 1. github设置添加SSH ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:3:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"}]