[{"categories":["数据结构"],"content":"顺序表代码实现 #define 与 typedef 的区别: 1 #define OK 1 当使用OK的时候会替换成1 #define 归预处理器管 typedef int Status 定义int 为Status类型 typedef 归编译器管 命名规范： SqList 这样的两个单词的合并，首字母要大写, 如ElemType, GetElem, ListDelete 使用#define后全要大写, 如#define TRUE 1 . 与 -\u003e 使用 当传递的是数组本身的时候用. 当传递的是指针的时候用-\u003e 定义SqList思路 ElemType 类型的 data[MAXSIZE]数组 必须确定当前的线性表的长度 int length GetElem的思路 不需要对数组进行修改，所以不传递数组指针SqList * 返回位序为i的元素的值, 需要指针来返回 ElemType *e, 数组下标是从0开始的，所以用*e=L.data[i-1] ListInsert的思路 边界上: 位序可以插入到第一个位置到当前长度+1的所有位置(在不满的情况下) 移动上: 从后往前移，此时操作的是数组，将位序转化为数组语言 for(k=L-\u003elength-1; k\u003e=i-1;k--) //位序所对应位置的元素也需要移动 L-\u003edata[k+1] = L-\u003edata[k]; L-\u003edata[i-1]=e; //插入新的元素 `` ListDelete的思路 边界上: 可以删除第一个位置到当前长度 移动上: 从位序开始，后面元素依次覆盖掉前面的元素 for (k = i; k \u003c L-\u003elength; k++) L-\u003edata[k-1] = L-\u003edata[k]; `` //linerlist.h #ifndef LEETCODE_LINERLIST_H #define LEETCODE_LINERLIST_H #include \u003cstdio.h\u003e #define MAXSIZE 20 /* 存储空间初始分配量*/ #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef int Status; typedef int ElemType; /* 将ElemType 类型定为int */ typedef struct { ElemType data[MAXSIZE]; /*数组存储数据元素，最大值为MAXSIZE;*/ int length; /*线性表当前长度*/ }SqList; // 获得元素操作 Status GetElem(SqList L, int i, ElemType *e); // 插入操作 Status ListInsert(SqList *L, int i, ElemType e); // 删除操作 Status ListDelete(SqList *L, int i, ElemType *e); // 遍历操作 void TravelList(SqList L); // 按值查找 int LocateElem(SqList L, ElemType e); #endif //LEETCODE_LINERLIST_H // linerlist.cpp #include \"SequenceList.h\" /*Status 是函数的类型，其值是函数结果状态代码，如OK等*/ /*初始条件： 顺序线性表L已存在， 1\u003c=i\u003c=ListLength(L)*/ /*操作结果: 用e返回L中第i个数据元素的值*/ Status GetElem(SqList L, int i, ElemType *e) { if(L.length==0 || i\u003c1 || i\u003eL.length) return ERROR; *e=L.data[i-1]; return OK; } /*初始条件： 顺序线性表L已存在， i\u003c=i\u003c=ListLength(L)*/ /*操作结果： 在L中第i位置之前插入新的数据元素e, L的长度加1*/ Status ListInsert(SqList *L, int i, ElemType e) { int k; if(L-\u003elength==MAXSIZE) /*顺序线性表已经满*/ return ERROR; if (i\u003c1 || i\u003eL-\u003elength+1) /*当i不在范围内时*/ return ERROR; if (i\u003c=L-\u003elength) /*若插入数据位置不在表尾*/ { for (k=L-\u003elength-1; k\u003e=i-1; k--) L-\u003edata [k+1] = L-\u003edata[k]; } L-\u003edata[i-1]=e; /*将新元素插入*/ L-\u003elength++; return OK; } /*初始条件： 顺序线性表L已在在, i\u003c=i\u003c=ListLength(L)*/ /*操作结果: 删除L的第i个数据元素，并用e返回其值，L的长度减1*/ Status ListDelete (SqList *L, int i, ElemType *e) { int k; if (L-\u003elength == 0) return ERROR; if (i \u003c 1 || i \u003e L-\u003elength) /*删除位置不正确*/ return ERROR; *e = L-\u003edata[i - 1]; if (i \u003c L-\u003elength) { /*如果删除不是最后位置*/ for (k = i; k \u003c L-\u003elength; k++) /*将删除位置后继元素前移*/ L-\u003edata[k - 1] = L-\u003edata[k]; } L-\u003elength--; return OK; } /*初始条件： 顺序线性表L已在在, i\u003c=i\u003c=ListLength(L)*/ /*操作结果: 返回顺序表L中的所有元素， 用空格分开*/ void TravelList(SqList L) { int i; for (i=0; i \u003c L.length; i++) printf(\"%d \", L.data[i]); printf(\"\\n\"); } /*初始条件： 顺序线性表L已存在， i\u003c=i\u003c=ListLength(L)*/ /*操作结果： 返回顺序表L中值为e的元素的位序*/ int LocateElem(SqList L, ElemType e) { int i; for(i=0; i\u003cL.length; i++) if(L.data[i]==e) return i+1; return 0; } //main.cpp #include \"SequenceList.h\" int main(void){ SqList L; L.length = 0; //插入测试 ListInsert(\u0026L, 1 ,2); ListInsert(\u0026L, 2, 3); printf(\"当前线性表中所有的元素:\\n\"); TravelList(L); //删除测试 int e; ListDelete(\u0026L, 1, \u0026e); printf(\"被删除的元素是 %d\\n\", e); printf(\"当前线性表中所有的元素:\\n\"); TravelList(L); //查找测试 int a; GetElem(L, 1, \u0026a); printf(\"第1个元素是: %d \\n\", a); printf(\"数值为3的元素在哪里？ %d\\n\", LocateElem(L, 3)); return 0; } 知乎 ↩︎ ","date":"2021-01-14","objectID":"/posts/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/:1:0","tags":["顺序表"],"title":"顺序表代码实现","uri":"/posts/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"},{"categories":["树莓派"],"content":"什么是旁路由？ ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:1:0","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["树莓派"],"content":"旁路由在哪里？ ","date":"2021-01-14","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/:1:1","tags":["旁路由"],"title":"树莓派实现旁路由功能","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E6%97%81%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD/"},{"categories":["linux"],"content":"Install cron1 sudo pacman -S cronie ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:1:0","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["linux"],"content":"Quick running ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:2:0","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["linux"],"content":"config setting default Editor export EDITOR=/usr/bin/nvim systemctl systemctl enable cronie.service systemctl start cronie.service ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:2:1","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["linux"],"content":"create cron job2 crontab -e Crontab format1 Symbol Description * Wildcard, specifies every possible time interval , List multiple values separated by a comma. - Specify a range between two numbers, separated by a hyphen / Specify a periodicity/frequency using a slash example run every ten minutes */10 * * * * echo ‘Hello’ » /tmp/test.txt run every hours from 1-5 am 0 1-5 * * * * echo ‘Hello’ » /tmp/test.txt run every 30 minutes Mon-Fri 9am-5pm */30 9-17 * * 1-5 echo ‘Hello’ » /tmp/test.txt ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:2:2","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["linux"],"content":"command user crontab -u user list crontab -l remove crontab -r Cron-Archwiki ↩︎ Linux/Mac Tutorial: Cron Jobs - How to Schedule Commands with crontab ↩︎ ","date":"2021-01-12","objectID":"/posts/corn%E4%BD%BF%E7%94%A8/:2:3","tags":["corn"],"title":"Corn使用","uri":"/posts/corn%E4%BD%BF%E7%94%A8/"},{"categories":["C"],"content":"重复包含问题的解决 ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:0","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["C"],"content":"1. 在main.cpp中只需要包含xxx.h即可，不需要包含xxx.cpp 原因分析： PS: 命令中没有提到\"speak.h\"文件(原因是:在\"speak.cpp\"中已经包含了\"speak.h\") ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:1","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["C"],"content":"2. 在xxx.h中，需要写上, 而xxx.cpp不需要写 #ifndef xxxxx #define xxxxx (...) #endif 原因分析： C++是采用独立编译，就是每个cpp单独编译成对应的.o文件，最后链接器再将多个.o文件链接成可执行程序。(防止同一个.o文件中包含多个相同的.h内容) ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:2","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["C"],"content":"3. 使用xxx.h与xxx.cpp这种方式的时候，声明放在xxx.h中，定义放在xxx.cpp中 原因分析： C++是采用独立编译，就是每个cpp单独编译成对应的.o文件，最后链接器再将多个.o文件链接成可执行程序。(在将多个.o文件链接成可执行程序的时候，有可能会在不同的.o文件中含有相同的定义) ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:1:3","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["C"],"content":"参考文章 注意头文件规则，避免链接错误：重复定义(multiple defination) 编译链接 C++ Compiling Cpp ","date":"2021-01-12","objectID":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/:2:0","tags":["C"],"title":"重复包含问题解决","uri":"/posts/%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"categories":["树莓派"],"content":"安装Nginx和PHP sudo apt-get update sudo apt-get install nginx php7.3-fpm php7.3-cli php7.3-curl php-7.3-gd php7.3-cgi sudo service nginx start sudo service php7.3-fpm restart 使Nginx能处理PHP sudo nano /etc/nginx/sites-available/default location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } 修改为 location / { index index.html index.htm index.php default.html default.htm default.php; } location ~\\.php$ { fastcgi_pass unix:/run/php/php7.3-fpm.sock; #fastcgi_pass 127.0.0.1:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; } 重启nginx sudo service nginx restart ","date":"2021-01-11","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/:1:0","tags":["Dashboard"],"title":"树莓派安装pi_Dashboard","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/"},{"categories":["树莓派"],"content":"下载pi-dashboard sudo apt-get install git cd /var/www/html sudo git clone https://github.com/nxez/pi-dashboard.git sudo chown -R www-data pi-dashboard 通过http://树莓派IP/pi-dashboard访问部署好的Pi Dashboard ","date":"2021-01-11","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/:2:0","tags":["Dashboard"],"title":"树莓派安装pi_Dashboard","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/"},{"categories":["树莓派"],"content":"参考 Pi Dashboard (Pi 仪表盘) ","date":"2021-01-11","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/:3:0","tags":["Dashboard"],"title":"树莓派安装pi_Dashboard","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85pi_dashboard/"},{"categories":["树莓派"],"content":"内网穿通SSH 修改服务器端的frps.ini [common] bind_port = 7000 服务器端开启frp ./frps -c ./frps.ini 客户端修改frpc.ini [common] server_addr = x.x.x.x server_port = 7000 [ssh] type = tcp local_ip = 127.x.x.x local_port = 22 remote_port = 6000 开启客户端的frpc ./frpc -c ./frpc.ini 通过ssh连接 ssh user@x.x.x.x -p 6000 ","date":"2021-01-10","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:1:0","tags":["frp"],"title":"树莓派实现内网穿透","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["树莓派"],"content":"参考 github ","date":"2021-01-10","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/:2:0","tags":["frp"],"title":"树莓派实现内网穿透","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"categories":["树莓派"],"content":"今天总有拿到树莓派4B+, 想着搭建一个下载机器，供家里人使用。 ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:0:0","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"各个接口功能 第一次入手，刚开始连电源键都没有找到, 官网提供了说明. ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:1:0","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"安装Raspberry Pi OS ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:0","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"下载系统 系统下载地址Raspberry Pi OS ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:1","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"烧录镜像 sudo fdisk -l 先查看SD卡的名称 sudo dd bs=4M if=系统路径 of=/dev/SD名称 status=progress oflag=sync Tip 使用dd时，写SD卡的名称，不要写SD卡分区的名称 使用dd时，报错 d: opening /dev/sdc: Read-only file system dd参数 bs=BYTES read and write up to BYTES bytes at a time (default:512); overrides ibs and obs status=LEVEL The LEVEL of information to print to sederr; none suppresses everything but error messages, noxfer suppresses the final transfer statistics, progress shows periodic transfer statistics. nocache Request to drop cache. See also oflag=sync ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:2","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"开启SSH，并连接 SD卡的boot，创建名为ssh`的文件即可 ssh pi@pi_ip_address 默认密码raspberry ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:3","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"配置 设置镜像 切换到清华源 下载并配置samba sudo apt install samba samba-common-bin // 下载samba sudo apt install vim // 下载vim sudo vim /etc/samba/smb.conf //配置samba 末尾加入 [MyNAS] valid users = pi, root path = /media/pi browseable = yes writable = yes create mask = 0644 directory mask = 0775 testparm //测试是否通过 sudo smbpassed -a pi //smb加入pi用户 systemctl enable smbd //开机启动smbd systemctl start smbd //启动smbd 下载并配置aria2 sudo apt install nginx sudo apt install aria2 cd /var/www/html sudo wget https://github.com/mayswind/AriaNg/releases/download/1.1.7/AriaNg-1.1.7-AllInOne.zip unzip AriaNg-1.1.7-AllInOne.zip systemctl start nginx //启动nginx systemctl enable nginx //开机启动nginx Tip 创建root用户 sudo passwd root ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:2:4","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["树莓派"],"content":"参考 raspberrypi.org raspberrypi.stackexchange.com ","date":"2021-01-09","objectID":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/:3:0","tags":["nginx","smbd"],"title":"树莓派踩坑记","uri":"/posts/%E6%A0%91%E8%8E%93%E6%B4%BE%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["数据结构"],"content":"ShellSort Shell 排序动图 Tip 14\u003e\u003e2 如何计算？ \u003e\u003e为右移运算符 14 的二进制为(0000 1110) 正数向右移动，低位舍弃，高位补零 移动之后的二进制为(0000 0011), 为3 #include \u003cstdio.h\u003e int main(void) { int number = 14 \u003e\u003e 2; printf(\"右移二位后的值为: %d \", number); } gap = len \u003e\u003e 1 是什么意思？ 表示 gap = len 不断的对半分 ","date":"2021-01-07","objectID":"/posts/shellsort/:1:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"ShellSort C语言实现 #include \u003cstdio.h\u003e void print_list(int arr[], int len); void shell_sort(int arr[], int len) { int gap, i, j; int temp; int k = 1; for (gap = len \u003e\u003e 1; gap \u003e 0; gap \u003e\u003e= 1){ printf(\"gap 为%d时: \\n\", gap); for (i = gap; i\u003clen; i++) { temp = arr[i]; for(j = i-gap; j\u003e=0 \u0026\u0026 arr[j] \u003e temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; printf(\"第%d次list: \", k); print_list(arr,len); k+=1; printf(\"\\n\"); } } } void print_list(int arr[], int len) { for(int i=0;i\u003clen;i++) printf(\"%d \", arr[i]); } int main (void) { int arr[] = {3, 21, 412, 1, 4,39, 123, 6}; int len = (int) sizeof(arr) /sizeof (*arr); printf(\"初始list: \"); print_list(arr,len); printf(\"\\n\"); shell_sort(arr,len); printf(\"最终list: \"); print_list(arr,len); printf(\"\\n\"); } gap = 4 gap = 2 gap = 1 ","date":"2021-01-07","objectID":"/posts/shellsort/:2:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"Shell 排序复杂度和稳定性分析 啥是序偶(Ordered pair)? 序: 就是有序的意思 偶: 一对儿 证明N个互异的数组的平均逆序数是$N(N-1)/4$ 表$L$: 34, 8, 64, 51, 32, 21 其反序表$L_r$: 21, 32, 51, 64, 8, 34 该表中任意两个数的序偶$(x, y)$, 且$y \u003e x$, 显然在$L$与$L_r$中，在表L和它的反序表$L_r$中的序偶的总个数为$C_N^2=N(N-1)/2$, 因此，平均每个表的逆序是$N(N-1)/4$ 证明通过交换相邻元素进行排序的任何平均需要$\\Omega(N^2)$ 已知初始的平均逆序数$N(N - 1)/4 = \\Omega(N^2)$, 而每次交换只减少一个逆序，因此需要$\\Omega(N^2)$交换 ","date":"2021-01-07","objectID":"/posts/shellsort/:3:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"时间复杂度 为啥希尔排序的时间复杂度可以突破$O(N^2)$? 以希尔增量时希尔排序的最坏情形为$O(N^2)$ 啥是希尔增量? 希尔排序使用一个序列$h_1, h_2, … h_t$, 叫做增量序列 希尔增量：$h_t = \\lfloor N/2 \\rfloor$ $h_k = \\lfloor h_{k+1} \\rfloor$ 相隔 $h_k$个元素都被排序，此时称文件是$h_k$排序 以Hibbard增量的希尔排序的最坏情形为$O( N^\\frac{3}{2})$ 啥是Hibbard增量？ $1, 3, 7, …, 2^k - 1$ ","date":"2021-01-07","objectID":"/posts/shellsort/:3:1","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"空间复杂度 $O(1)$ ","date":"2021-01-07","objectID":"/posts/shellsort/:3:2","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"稳定性 Tip 在一个数组中，存在相同的数，经过排序后，这些数的相对次序保持不变，即原来数组中r[i] = r[j], r[i] 在r[j] 之前，经过排序后，r[i]仍在r[j]之前， 则称这种排序算法是稳定的，否则称为不稳定的。 序列： 3 5 10 $8_1$ 7 2 $8_2$ 1 20 6 对于gap=5时 (3, 2), (5, $8_2$), (10, 1), ($8_1$, 20), (7, 6) 排序后(2, 3), (5, $8_2$), (1, 10), ($8_1$, 20), (7, 6) 2 5 1 $8_1$ 7 3 $8_2$ 10 20 6 对于gap=2时，向下取整 (2, 1, 7, $8_2$, 20), (5, $8_1$, 3, 10, 6) 排序后 (1, 2, 7, $8_2$, 20), (3, 5, 6, $8_1$, 10) 1, 3, 2, 5, 7, 6, $8_2$, $8_1$, 20, 10 此时$8_2$已经跑到$8_1$之前，表示Shell排序不稳定 ","date":"2021-01-07","objectID":"/posts/shellsort/:3:3","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"如何用C语言实现Hibbard增量的Shell排序? 为什么要从希尔增量变成Hibbard增量？ 在希尔增量的情况下: 间隔为8时，分为8组 (1, 5), (9, 13), (2, 6), (10, 14), (3, 7), (11, 15), (4, 8), (12, 16) 间隔为4时，分为4组 (1, 3, 5, 7), (9, 11, 13, 15), (2, 4, 6, 8), (10, 12, 14, 16) 间隔为2时，分为2组 (1, 2, 3, 4, 5, 6, 7, 8), (9, 10, 11, 12, 13, 14, 15, 16) 间隔为1时，分为1组 (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16) 前3个增量没有起任何作用 啥是一个好的增量？ 最后一个增量必须为1 避免序列中的值(尤其是相邻的值)互为倍数的情况 ","date":"2021-01-07","objectID":"/posts/shellsort/:4:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"参考文章 数据结构与算法——希尔排序 希尔排序增量序列简介 希尔排序为什么会那么牛那么快，能够证明吗？ ","date":"2021-01-07","objectID":"/posts/shellsort/:5:0","tags":["algorithm"],"title":"ShellSort","uri":"/posts/shellsort/"},{"categories":["数据结构"],"content":"插入排序 ","date":"2021-01-06","objectID":"/posts/insertionsort/:1:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"插入排序的特征 1.从第二个元素(比较元素)开始一一与前面元素(被比较元素)比较, 若当前元素小于被比较元素，被比较元素后移，直到比较元素比被比较元素大或等于时，比较元素插入到被比较元素的位置 比较元素位置: 从第二个元素到最后一个(n-1个) 被比较元素位置: 从第一个到比较元素位置-1, 考虑从比较元素位置依次递减，满足\u003e=0即可. 即用while 这里一直用的arr[j+1] = arr[j], 采取前面元素覆盖后面元素的方式，当满足条件时，arr[j+1]才等于key ","date":"2021-01-06","objectID":"/posts/insertionsort/:2:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"C语言实现 #include\u003cstdio.h\u003e void insertion_sort(int arr[], int len); void print_list(int arr[], int len); void insertion_sort(int arr[], int len) { int i, j, key; int k=1; for(i=1; i\u003clen; i++) { key = arr[i]; j=i-1; while((j\u003e=0) \u0026\u0026 (arr[j]\u003ekey)){ arr[j+1] = arr[j]; j--; } arr[j+1] = key; printf(\"第%d次list:\", k); print_list(arr, len); printf(\"\\n\"); k+=1; } } void print_list(int arr[], int len) { int i; for(i=0; i\u003clen; i++) printf(\"%d \", arr[i]); } int main(void) { int arr[] = {22, 34, 321, 32, 1, 5, 23}; int len = (int) sizeof(arr) / sizeof(*arr); printf(\"初始list:\"); print_list(arr, len); printf(\"\\n\"); insertion_sort(arr, len); printf(\"最终list:\"); print_list(arr, len); return 0; } ","date":"2021-01-06","objectID":"/posts/insertionsort/:3:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"复杂度分析 ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"时间复杂度 最坏时间复杂度 在数组完全逆序的情况下: 插入第2个元素时，考虑对比1个元素 插入第3个元素时，考虑对比2个元素 插入第n个元素时，考虑对比n-1个元素 最坏情况下的比较次数是:$1+2+…+n-1=\\frac{(n-1)n}{2}$ 所以其时间复杂度是: $O(n^2)$ 最优时间复杂度 在数组完全正序的情况下: 插入第2个元素时，考虑对比1个元素 插入第3个元素时，考虑对比1个元素 插入第n个元素时，考虑对比1个元素 最好情况下的比较次数是: $1+1+…+1=n$ 所以其时间复杂度是: $O(n)$ ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:1","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"空间复杂度 Note 一个程序在执行时除需要存储空间来存放本身的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。 算法原地工作: 是指算法所需的辅助空间为常量, 即$O(1)$ 此插入排序算法的辅助空间为常量，即其空间复杂度为$O(1)$ ","date":"2021-01-06","objectID":"/posts/insertionsort/:4:2","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"参考文章 插入排序 | 菜鸟教程 ","date":"2021-01-06","objectID":"/posts/insertionsort/:5:0","tags":["algorithm"],"title":"InsertionSort","uri":"/posts/insertionsort/"},{"categories":["数据结构"],"content":"选择排序 ","date":"2021-01-05","objectID":"/posts/selectionsort/:1:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"C语言实现 #include \u003cstdio.h\u003e void print_list(int arr[], int len); void selection_sort(int arr[], int len); void swap(int *a, int *b); void selection_sort(int arr[], int len) { int i, j; printf(\"初始list:\"); print_list(arr, len); printf(\"\\n\"); int k = 1; for(i=0; i\u003clen -1; i++) { int min = i; for(j = i + 1; j \u003c len; j++) if (arr[j] \u003c arr[min]) min = j; swap(\u0026arr[min], \u0026arr[i]); printf(\"第%d次交换后的list:\", k); print_list(arr, len); printf(\"\\n\"); k+=1; } } void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp; } void print_list(int arr[], int len) { int i; for (i=0; i\u003c len; i++) printf(\"%d \", arr[i]); } int main() { int arr[] = { 22, 34, 3, 4, 5, 9}; int len = (int) sizeof(arr) / sizeof(*arr); selection_sort(arr, len); return 0; } Note 前面的元素与后面的元素一一对比, 若后面的元素小，将最小元素的的序号替换成它, 最后前的元素的值与最小序号所对的值替换 即只需要选择n-1个前元素即可（0 -\u003e len - 2），同时需要与后面的所有元素对比(0 -\u003e len - 1) 一次循环结束后确定了最小元素才互换，不是一得到一个较小的元素就互换 ","date":"2021-01-05","objectID":"/posts/selectionsort/:2:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"时间复杂度与空间复杂度分析 ","date":"2021-01-05","objectID":"/posts/selectionsort/:3:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"时间复杂度 第一次内循环(1 -\u003e len - 1), N - 1次 第二次内循环(2 -\u003e len - 1), N - 2次 第三次内循环(3 -\u003e len - 1), N - 3次 第后一次内循环(len - 2 -\u003e len - 1), 1次 比较的次数是(N - 1) + (N - 2) + ... + 1 , 其和是 $\\frac{N(N-1)}{2}$ 所以其时间复杂度是$O(N^2)$ ","date":"2021-01-05","objectID":"/posts/selectionsort/:3:1","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"空间复杂度 O(1) ","date":"2021-01-05","objectID":"/posts/selectionsort/:3:2","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"参考文章 选择排序 ","date":"2021-01-05","objectID":"/posts/selectionsort/:4:0","tags":["algorithm"],"title":"Selection_Sort","uri":"/posts/selectionsort/"},{"categories":["数据结构"],"content":"冒泡排序 ","date":"2021-01-04","objectID":"/posts/bubble_sort/:1:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"C语言实现 #include \u003cstdio.h\u003e void print_list(int arr[], int len); void bubble_sort(int arr[], int len); void bubble_sort(int arr[], int len) { int i, j, temp; printf(\"初始list为:\"); print_list(arr, len); printf(\"\\n\"); int k = 1; for(i = 0; i \u003c len - 1; i++) for (j = 0; j \u003c len - 1 - i; j++) if (arr[j] \u003e arr[j + 1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; printf(\"第%d次替换后的list : \", k); print_list(arr, len); printf(\"\\n\"); k+=1; } } void print_list(int arr[], int len) { int i; for (i=0; i\u003c len; i++) printf(\"%d \", arr[i]); } int main() { int arr[] = { 22, 34, 3, 4}; int len = (int) sizeof(arr) / sizeof(*arr); bubble_sort(arr, len); return 0; } 次数 list 状态 解释 i j 是否有移动 0 22 34 3 4 初始化 0 0 1 22 34 3 4 22(前)与34(后)比较, 22小, 不移动, j+1 0 0-\u003e1 2 22 3 34 4 34(前)与3(后)比较, 3小, 移至前面, j+1 0 1-\u003e2 * 3 22 3 4 34 34(前)与4(后)比较, 4小, 移至前面，j+1(此时j+1后=len - 1 - i), 跳出当前循环，i+1, j变为0 0-\u003e1 2-\u003e3-\u003e0 * 4 3 22 4 34 22(前)与3(后)比较，3小, 移至前面，j+1 1 0-\u003e1 * 5 3 4 22 34 22(前)与4(后)比较，4小, 移至前面，j+1(此时j+1后=len - 1 - i), 跳出当前循环, i+1, j变为0 1-\u003e2 1-\u003e2-\u003e0 * 6 3 4 22 34 3(前)与4(后), 3小，不移动, j+1, (此时j+1=len - 1 - i), 跳出当前循环， i+1 (此时i=len -1)退出上层循环 2-\u003e3 0-\u003e1 ","date":"2021-01-04","objectID":"/posts/bubble_sort/:2:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"标准冒泡排序时间复杂度与空间复杂度分析 ","date":"2021-01-04","objectID":"/posts/bubble_sort/:3:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"时间复杂度 void bubble_sort(int arr[], int len) { int i, j, temp; for(i = 0; i \u003c len - 1; i++) for (j = 0; j \u003c len -1 -i; j++) if (arr[j] \u003e arr[j + 1]) { temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; } } 语句 cost times int i, j, temp $C_1$ 1 i \u003c len - 1 $C_2$ n(n次判断) i++ $C_3$ n - 1(不满足条件不加) j=0 $C_4$ i++只会执行n-1次，即j=0执行n-1次 j \u003c len - 1 - i $C_5$ $t_1$(i=0) + $t_1$(i=1) + … + $t_1$(i = n-2) + $t_1$(i = n-1), 最多执行n-1次 j++ $C_6$ $t_2$(i=0) + $t_2$(i=1) + … + $t_2$(i = n-2) + $t_2$(i = n-1) arr[j + 1] \u003c arr[j] $C_7$ $t_3$(i=0) + $t_3$(i=1) + … + $t_3$(i = n-2) + $t_3$(i = n-1) swap(arr, j, j+1) $C_8$ $t_4$(i=0) + $t_4$(i=1) + … + $t_4$(i = n-2) + $t_4$(i = n-1) 算法总的运行时间是第一条语句执行时间之和。如果执行一条语句需要c_i步，又共执行了n次这条语句。那么它在运行时间中占cin为计算总运行时间T[n], 对第一对cost与times这积求和。 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-2)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-2)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-2)] + c8[t4(i=0) + t4(i=1) + … + t4(i=n-2)]] 最优时间复杂度 第8步，不执行 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-1)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-1)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-1)] 即可T(n) = O(n^2) 最坏时间复杂度 第8步，均执行 T(n) = C1 + C2n + C3(n - 1) + C4(n - 1) + C5[t1(i=0) + t1(i=1) + … + t1(i=n-2)] + c6[t2(i=0) + t2(i=1) + … t2(i=n-2)] + c7[t3(i=0) + t3(i=1) + … + t3(i=n-2)] + c8[t4(i=0) + t4(i=1) + … + t4(i=n-2)]] 即可T(n) = O(n^2) ","date":"2021-01-04","objectID":"/posts/bubble_sort/:3:1","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"冒泡排序优化 在内部循环的时候，一次交换都没有发生时，直接退出循环即可 void bubble_sort(int arr[], int len) { int i, j, temp; int flag = 0; for(i = 0; i \u003c len - 1; i++){ for (j = 0; j \u003c len - 1 - i; j++) if (arr[j] \u003e arr[j + 1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j + 1] = temp; flag = 1; } if(flag == 0) return; } } 此时最优时间复杂度 T(n) = O(n), 外部只执行1次， 内部执行 T(n) = C1 + C2 + C3 + C4(n - 1) + C5(n - 1) + c6(n - 1) ","date":"2021-01-04","objectID":"/posts/bubble_sort/:4:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["数据结构"],"content":"参考 Bubble Sort 冒泡排序 ","date":"2021-01-04","objectID":"/posts/bubble_sort/:5:0","tags":["algorithm"],"title":"Bubble_Sort","uri":"/posts/bubble_sort/"},{"categories":["docker"],"content":"Docker 三大基本概念 镜像(Image) 容器(Container) 仓库(Repository) ","date":"2021-01-02","objectID":"/posts/docker/:1:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"安装Docker(Debian) ","date":"2021-01-02","objectID":"/posts/docker/:2:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"镜像 ","date":"2021-01-02","objectID":"/posts/docker/:3:0","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"获取镜像 docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签] Docker 镜像仓库地址 默认地址是 Docker Hub(docker.io) 仓库名 \u003c用户名\u003e/\u003c软件名\u003e 对于Docker Hub, 不给出用户名，默认为library, 即官方镜像 比如: docker pull mquandalle/wekan docker pull debian //不给出用户名，使用用官方镜像 docker pull ubuntu:14.04 //使用官方镜像中版本号为14.04的ubuntu Tip Docker是采取分层存储的概念, 镜像是由多层存储所构成。下载也是一层层去下载，并非单一文件。 ","date":"2021-01-02","objectID":"/posts/docker/:3:1","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"运行镜像 $ docker run -it --rm ubuntu:14.04 参数说明： -it: -i:交互式操作 -t: 表示终端 --rm: 表示容器退出后随之将其删除 ","date":"2021-01-02","objectID":"/posts/docker/:3:2","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"列出镜像 $ docker image ls Tip Docker Hub中显示的体积与docker image ls显示的镜像大小不同 Docker Hub中显示的体积是压缩后的体积，在镜像下载和上传的过程中镜像是保持着压缩状态的，在网络传输过程中，关心的是流量大小 docker image ls列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会使用相同的基础镜像，从而拥有共同的层。相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能比这个列表镜像大小的总和要小的多。 $ docker system df 可以查看镜像、容器、数据卷所占用的空间 ","date":"2021-01-02","objectID":"/posts/docker/:3:3","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["docker"],"content":"删除镜像 $ docker image rm [选项] \u003c镜像1\u003e [\u003c镜像2\u003e] \u003c镜像\u003e 可以是ID, 镜像名或镜像摘要 ID: 一般取前3个字符以上，只要足够区分别的镜像就可以了 如： docker image rm df0 镜像名: \u003c仓库名\u003e:\u003c标签\u003e 如： docker image rm mongo:latest 镜像摘要 $ docker image ls --digests ","date":"2021-01-02","objectID":"/posts/docker/:3:4","tags":["docker"],"title":"Docker","uri":"/posts/docker/"},{"categories":["git"],"content":"为什么需要转换SHH地址和HTTPS? SSH地址在push, pull时均不需要输入账号密码 ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:1:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"SHH地址的特征 git@远程仓库域名:用户名/仓库名.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:2:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"HTTPS地址的特征 https://远程仓库域名/用户名/仓库名.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:3:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"HTTPS地址向git地址转化 修改项目的.git -\u003e config url = git@github.com:guangsizhongbin/Blog.git ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:4:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["git"],"content":"参考 Github SSH地址和HTTPS地址的相互转换 ","date":"2021-01-02","objectID":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/:5:0","tags":["git"],"title":"SHH地址和HTTPS地址相互转换","uri":"/posts/github_ssh%E5%9C%B0%E5%9D%80%E5%92%8Chttps%E5%9C%B0%E5%9D%80%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"},{"categories":["hugo"],"content":"系统版本 root@vultr:~# hostnamectl Static hostname: vultr.guest Icon name: computer-vm Chassis: vm Machine ID: 014b2aed70f7e09db32693a85feeb49a Boot ID: fe9876f6146f4fb4a3187f09d94f5ab3 Virtualization: kvm Operating System: Debian GNU/Linux 9 (stretch) Kernel: Linux 4.9.0-14-amd64 Architecture: x86-64 我使用的是Debian 9 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:1:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"安装宝塔 wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 bash install.sh ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:2:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"上传Hugo源文件至Github 不需要上传public中的文件 Note 不跟踪某个public文件夹(git status不再提醒) 修改 .gitignore 加入 public/ 对public文件夹取消跟踪 git rm -r –cached public 删除public文件夹的跟踪，并保留在本地 git rm -r –f public 删除public文件夹的跟踪，并且删除本地文件 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:3:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"Github Actions构建Hugo并用WebHook回调 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"生成Access token 个人的Settings -\u003e Developer settings -\u003e Personal access tokens -\u003e Generate new token -\u003e Generate token 保存好获取到的 access token, 它只会出现一次 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:1","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"添加Access Token到项目 项目Secrets -\u003e New repository secret -\u003e Add secret ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:2","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"宝塔安装WebHook 宝塔 -\u003e 应用搜索 -\u003e webhook ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:3","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"设置脚本 #!/bin/bash echo \"\" date --date='0 days ago' \"+%Y-%m-%d %H:%M:%S\" echo \"Start\" gitPath=\"/www/wwwroot/fengqigang.cn\" gitHttp=\"https://github.com/guangsizhongbin/Blog.git\" echo \"Web站点路径:$gitPath\" if [ -d \"$gitPath\" ]; then cd $gitPath if [ ! -d \".git\" ]; then echo \"在该目录下克隆 git\" git clone -b gh-pages $gitHttp gittemp mv gittemp/.git . rm -rf gittemp fi git reset --hard gh-papes git pull chown -R www:www $gitPath echo \"End\" exit else echo \"该项目路径不存在\" echo \"End\" exit fi Note date agruments --date=STRING display time described by STRING, not 'now' // 显示当前时间 $ date --date=\"0 days ago\" Sun Jan 3 10:54:04 AM CST 2021 // 显示2天之后的时间 $ date --date=\"2 days\" Tue Jan 5 10:55:14 AM CST 2021 // 显示2个星期之后的时间 $ date --date=\"2 weeks\" Sun Jan 17 10:55:22 AM CST 2021 +%Y-%m-%d %H:%M:%S %Y year %m month (01..12) %d day of month (e.g., 01) %H hour (00..23) %M minute (00..59) %S second (00..60) day of month 和 month 都是小写 // 显示当前时间 $ date '+%Y-%m-%d %H:%M:%S' 2021-01-03 11:07:00 // 显示当前时间 $ date --date=\"0 days ago\" '+%Y-%m-%d %H:%M:%S' 2021-01-03 11:08:47 git arguments -b \u003cname\u003e Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository's HEAD, point to \u003cname\u003e brach instead. git reset --hard gh-pages Restes the index and working tree. Any changes to tracked files in the working tree since \u003ccommit\u003e are discarded. 退回到远程仓库中的版本 项目Actions -\u003e Set up a workflow yourself -\u003e 添加代码 -\u003e Start commit name: Deploy Hugo # 自己命名即可 on: # 设置触发条件 push: branches: - master # master 分支被更新时触发 job: # 设置触发时间 build-deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v1 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest - name: Build run: hugo - name: Deploy uses: peaceiris/action-gh-pages@v3 with: personal_token: ${{ secrets.personal_token}} PUBLISH_BRANCH: gh-pages # 推送至分支名称 PUBLISH_DIR: ./public # 将hugo 生成的 public 作为根目录 comit_message: ${{ github.event.head_commit.message }} ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:4","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"将秘钥添加至项目中的Secrets 项目的Setting -\u003e Secrets ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:5","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"添加Github Actions workflow 事件 - name: Webhook uses: distributhor/workflow-webhoob@v1 env: webhook_url: ${{ secrets.WEBHOOK_URL }}$ webhook_secret: ${{ secrets.WEBHOOK_SECRET }}$ ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:4:6","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["hugo"],"content":"参考 Hugo + Github Actions 实现自动化部署 ","date":"2021-01-01","objectID":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/:5:0","tags":["git","hugo"],"title":"Github Actions 自动部署hugo至vps","uri":"/posts/github_actions_%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hugo%E8%87%B3vps/"},{"categories":["git"],"content":"使用git协议克隆的好处 配置完后，每次提交均不需要输入账号密码 ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:1:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"},{"categories":["git"],"content":"如何配置 创建一个SSH Key $ ssh-keygen -t rsa -C \"guangsizhongbin@gmail.com\" 参数含义： -t Specifies the type of key to create. -C Provides a new comment. Enter file in which to save the key (/home/feng/.ssh/id_rsa): 参数含义： -f filename Specifies the filename of the key file. 指定生成文件的文件名（文件路径，否则会直接生成在当前目录下） 例如: ssh-keygen -t rsa -C \"guangsizhongbin@gmail.com\" -f a 会在当前路径下生成私钥a, 公钥a.pub Enter passphrase (empty for no passphrase): Enter same passphrase again: passphrase: a sequence of words used to gain access to a computer system 填写push文件时需要输入的密码 将公钥id_ras.pub传至github中（默认路径.ssh/id_ras.pub） bash: cat .ssh/id_rsa.pub github: Repositories -\u003e Settings -\u003e Deploy keys -\u003e Add deploy key -\u003e Add key 若要有push权限必须要勾选Allow write access, 否则只有read 权限 测试SSH key ssh -T git@github.com The authenticity of host 'github.com (192.30.255.112)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added 'github.com,192.30.255.112' (RSA) to the list of known hosts. Enter passphrase for key '/home/feng/.ssh/id_rsa': 输入创建SSH key的时候设置的密码(若有设置) Hi guangsizhongbin/Blog! You've successfully authenticated, but GitHub does not provide shell access. 此时已经设置成功了 使用git协议进行克隆 git clone git clone git@github.com:guangsizhongbin/Blog.git Cloning into 'Blog'... Enter passphrase for key '/home/feng/.ssh/id_rsa': 输入创建SSH key的时候设置的密码(若有设置) ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:2:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"},{"categories":["git"],"content":"参考文章 1. github设置添加SSH ","date":"2021-01-01","objectID":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/:3:0","tags":["git"],"title":"使用git协议克隆","uri":"/posts/%E4%BD%BF%E7%94%A8git%E5%8D%8F%E8%AE%AE%E5%85%8B%E9%9A%86/"}]