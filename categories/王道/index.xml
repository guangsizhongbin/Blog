<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>王道 - Category - xiaonan&#39;s Blog</title>
        <link>http://fengqigang.cn/categories/%E7%8E%8B%E9%81%93/</link>
        <description>王道 - Category - xiaonan&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>gaungsizhongbin@gmail.com (xiaonan)</managingEditor>
            <webMaster>gaungsizhongbin@gmail.com (xiaonan)</webMaster><lastBuildDate>Sun, 04 Jul 2021 11:23:00 &#43;0800</lastBuildDate><atom:link href="http://fengqigang.cn/categories/%E7%8E%8B%E9%81%93/" rel="self" type="application/rss+xml" /><item>
    <title>DB-02多表</title>
    <link>http://fengqigang.cn/posts/db-02%E5%A4%9A%E8%A1%A8/</link>
    <pubDate>Sun, 04 Jul 2021 11:23:00 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/db-02%E5%A4%9A%E8%A1%A8/</guid>
    <description><![CDATA[如何建立一对一的表(商品表[价格，数量，商品名称], 商品详情表[商品具体描述，图片，规规格])? 商品表:
 id 价格 数量 商品名称  商品详情表
 id 商品的具体描述 图片 规格 商品id  如何建一对多的表(班级表[名称], 学生表[姓名])? 一对多，两个表之间的关系应该维护在多的一方
班级表
 id 名称  学生表
 id 姓名 班级id  如何建多对多的表(学生表[姓名], 课程表[课程名称])? 多对多的关系应该去建立一个关系表, 在关系表中去维护两者之间的关系
  先建各自的表
  再建立关系表
  学生表
 id 姓名  课程表
 id 课程名称  学生选课表
 id 学生id 课程id  ]]></description>
</item><item>
    <title>21_reflect</title>
    <link>http://fengqigang.cn/posts/21_reflect/</link>
    <pubDate>Wed, 30 Jun 2021 09:32:16 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/21_reflect/</guid>
    <description><![CDATA[什么是反射? 获取类运行时信息的一种技术，这种技术叫做反射技术
获取字节码文件有哪些方式?   Class.forName(&ldquo;全限定类名&rdquo;)
  类名.class
  对象.getClass（）
  如何用 Class.forName(&ldquo;全限定类名&rdquo;) 获取字节码文件？ 1 2 3 4 5 6 7  public class TestDemo { public static void main(String[] args) throws ClassNotFoundException { // 第一种 Class.forName（&#34;全类名&#34;）  Class personCls = Class.forName(&#34;idea.Person&#34;); System.out.println(personCls); } }   如何用 类名.class 获取字节码文件？ 1 2 3 4 5 6 7 8 9 10 11  public class TestDemo { public static void main(String[] args) throws ClassNotFoundException { // 第一种 Class.]]></description>
</item><item>
    <title>Aop</title>
    <link>http://fengqigang.cn/posts/aop/</link>
    <pubDate>Mon, 28 Jun 2021 23:14:37 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/aop/</guid>
    <description><![CDATA[AOP编程实战   引入依赖
  注册委托类组件
  提供一个通知组件并注册(MethdoInterceptor 是来自于 org.aopalliance.intercept)
  ASPECT 强化advisor - pointcut advisor 的时间属性   Before
  After
  Around
  AfterReturning
  AfterThrowing
  joinPoint 的参数 ProceedingJoinPoint extends 于 JoinPint
  getSignature() 方法信息
  getName() 方法名
  getArgs() 参数
  getThis() proxy
  getTarget() 委托类对象
  CustomAspect  指定组件为切面组件 @Aspect , 保留@Component  配置切入点 @Pointcut(&ldquo;execution(* cn.]]></description>
</item><item>
    <title>Spring02</title>
    <link>http://fengqigang.cn/posts/spring02/</link>
    <pubDate>Fri, 25 Jun 2021 23:23:09 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/spring02/</guid>
    <description><![CDATA[02_Spring
builder 设计模式  注意
 如果setIq 和 sethair 方法中的 head, 如果没有初始化的话会出现空指针异常
  处理方法:
  HumanBuilder
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class HumanBuilder { Human human = new Human(); public Head setIq(Integer iq) { Head head = human.getHead(); head.setIq(iq); return head; } public Head setHair(String hair) { Head head = human.getHead(); head.setHair(hair); return head; } }   Human]]></description>
</item><item>
    <title>Spring01</title>
    <link>http://fengqigang.cn/posts/spring01/</link>
    <pubDate>Thu, 24 Jun 2021 23:51:14 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/spring01/</guid>
    <description><![CDATA[单例模式 构造方法后没有;
public class 后没有()
线程不安全的立即加载单例模式 高并发下并不安全
1 2 3 4 5 6 7 8 9 10 11  public class TestSigteon { static TestSigteon testSigteon; private TestSigteon(){} public static TestSigteon getSigteonInstance(){ if(testSigteon == null){ testSigteon = new TestSigteon(); } return testSigteon; } }   线程安全的立即加载单例模式 将 synchronized 放在 public 与 static 之间
1 2 3 4 5 6 7 8 9 10 11  public class TestSigteon { static TestSigteon testSigteon; private TestSigteon(){} public synchronized static TestSigteon getSigteonInstance(){ if(testSigteon == null){ testSigteon = new TestSigteon(); } return testSigteon; } }   什么是懒加载和立即加载?]]></description>
</item><item>
    <title>Day39</title>
    <link>http://fengqigang.cn/posts/day39/</link>
    <pubDate>Mon, 17 May 2021 23:31:44 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day39/</guid>
    <description><![CDATA[引入css有哪几种方式?  在 div 后写 style  写在 head 标签内， 用 style 包裹  导入外部文件，用link标签(可使用相对路径，也可使用绝对路径)  有哪些方式可以挑选选择器?  标签选择器  类选择器(在一个 html 页面上， 每一个标签的 class 可以有多个)  ID选择器(在一个 html 页面上，每一个标签的 id 是唯一的)   层级复合选择器   属性选择器  选择器的优先级是什么样的? 如何强制升到最高的优先级? 行内 &gt; ID &gt; 伪类|类 属性选择 &gt; 标签 &gt; 统配符
文件中 css 与导入的 css (优先级一样), 需要 满足就近原则
强制升到最高的优先级
当前位置所设置的属性为最高级
什么是标准流(标准文档流, 文档流)?   在一个 HTML 页面中，页面会根据页面的(行和块)特性，会从上到下，从左到右按顺序排列
  每一个 HTML 标签， 要在页面上占据空间]]></description>
</item><item>
    <title>Day38</title>
    <link>http://fengqigang.cn/posts/day38/</link>
    <pubDate>Thu, 13 May 2021 23:34:52 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day38/</guid>
    <description><![CDATA[为什么是出现 html? 当时是为了传论文
html 是谁的? html + css + js 都是W3C的
W3C (The World Wide web Consortium)
它是一个组织， 只提供一系列的草案，因此没有相关的文档
为什么在不同的浏览器中执行相同的前端代码， 有些浏览器会走形, 并且错误的代码也可以输出? 因为为了在浏览器大战中获得胜利，各家的浏览器并没有完全遵循W3C的标准
同时各家的浏览器为了获得更多的市场，会包容错误代码
前端, 网页, Html, Css, JavaScript, 它们之间是什么样的关系? 前端: 写页面
网页: 人
Html: 骨架
Css: 皮肤和血肉
Js(JavaScript): 思想逻辑
什么是 Html ? 是一种语言
文本语言: 超文本
是一个以 .html 为后缀的文本
&lsquo;超文本&rsquo; 包括文本字体, 图片, 链接， 甚至音乐，程序等元素代码的文本
是一个文本， 也是一个网页，该文本用浏览器打开， 文本里代码会进行解释执行
html 的标准结构是什么样的? html 重要的body标签   块级标签
  行级标签
  行内块标签]]></description>
</item><item>
    <title>Day37</title>
    <link>http://fengqigang.cn/posts/day37/</link>
    <pubDate>Wed, 12 May 2021 23:29:10 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day37/</guid>
    <description><![CDATA[Shiro 权限验证框架
什么是符号表(Map) 就是 Key-value数据
互联网三要素: url
怎么找到某个资源，资源位置在哪里?
http
描述资源在网络上的传输方式
html
描述论文
怎么在互联网上唯一表示一台计算机 ip + 地址
url 分类三大部分 什么哈希表? Hash函数具有的特点 Hash算法不是加密算法 加密意味着解密
主流的 hash 算法: sha1（谷歌的两个程序员）, md5(王小云), 已经被证明不具有强抗碰撞性(先简单认为不安全)
碰撞性:
主流的 hash 函数 加盐： 盐值
账号: Admin
密码: 123
理论上的 hash 冲突如何解决? 线性探测法
平方探测法
再散列法]]></description>
</item><item>
    <title>Day36</title>
    <link>http://fengqigang.cn/posts/day36/</link>
    <pubDate>Tue, 11 May 2021 23:26:09 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day36/</guid>
    <description><![CDATA[set 特点  Set 接口是 Collection 的子接口 描述的是集合这种数据结构 它的一些自实现是有序的(LinkedHashSet, TreeSet) 有些子实现是无序的(HashSet) 有些子实现允许存储null(LinkedHashSet, HashSet), 有些子实现不允许存储 null(TreeSet) 都是不允许重复元素  set Api  初始化  collection 是 add 方法, map 是 poll 方法
 addAll   clear   containsAll      iterator()  map 不能使用增强for循环, 可以用interset,
set 可以使用增强for循环
HashSet特点  HashSet 是 Set 接口一个具体子实现 HashSet 的底层持有一个 HashMap 对象, HashMap 的底层是一个数组 + 链表 + 红黑树结构, 所以存储到 HashSet 中的元素， 实际上都存储到 HashSet 所持有 HashMap 中作为 Key 存在 由于它的底层持有的是 HashMap 对象，所以无序 不允许存储重复元素： 存储的元素 hash 值一样，并且两个元素直接相等或者相 equals.]]></description>
</item><item>
    <title>Day35</title>
    <link>http://fengqigang.cn/posts/day35/</link>
    <pubDate>Tue, 11 May 2021 23:25:23 &#43;0800</pubDate>
    <author>Author</author>
    <guid>http://fengqigang.cn/posts/day35/</guid>
    <description><![CDATA[day35_linkedHashMap
LinkedHashMap的特点   LinkedHashMap 是 HashMap 一个子类
  LinkedHashMap 基本上完全复用了 HashMap 的底层结构， 参数，方法
  LinkedHashMap的特点基本遵从于 HashMap
  LinkedHashMap 底层在 HashMap 的基础上(数组 + 链表 + 红黑树) 额外维护了一个双向链表: 这个双向链表用来记录存储
  LinkedHashMap 如何额外维护一个双向链表? 构造方法?  默认的构造方法  accessOrder(如果我们给accessOrder 设置为真，那么我们如果访问了这个LinkedHashMap中的某一个Key-value数据，那么这份Key-value数据就会在双向链表中的位置移到最后， 它在红黑树上的位置不变)   API TreeMap 有什么特点?  TreeMap 是 Map 一个子实现 描述数据结构是树/二叉搜索树/红黑树 底层是链表 TreeMap 大小有序(中序遍历是有序的) 不允许重复的 key 不允许null键 线程不安全 Treemap 的重复的定义: 大小比较结果是0, 自然顺序/比较器 如果我们希望在TreeMap中存储数据 ，key-value, 我们可以有两个选择：   让key本身可以比较(继承Comparabe接口实现 compareTo 方法)（但会让代码看一起来不清爽） 不想让 key 本身实现 Comparable 接口实现, 手动用比较器实现  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public class DemoTreeMap { public static void main(String[] args) { TreeMap&lt;User3, Integer&gt; map = new TreeMap&lt;&gt;(); map.]]></description>
</item></channel>
</rss>
